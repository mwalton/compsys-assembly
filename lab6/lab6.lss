
./lab6.elf:     file format elf32-tradlittlemips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000010  9d001000  9d001000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .app_excpt    00000010  9d000180  9d000180  00000180  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .vector_0     00000008  9d000200  9d000200  00000200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .vector_4     00000008  9d000280  9d000280  00000280  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  4 .vector_24    00000008  9d000500  9d000500  00000500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .vector_32    00000008  9d000600  9d000600  00000600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .startup      000001e0  9d001010  9d001010  00001010  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text         00001664  9d0011f0  9d0011f0  000011f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .init         00000024  9d002854  9d002854  00002854  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .fini         0000001c  9d002878  9d002878  00002878  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .ctors        0000000c  9d002894  9d002894  00002894  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .dtors        00000008  9d0028a0  9d0028a0  000028a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .rodata       00000558  9d0028a8  9d0028a8  000028a8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .dbg_data     00000200  a0000000  a0000000  00011800  2**0
                  CONTENTS
 14 .sdata        00000008  a0000200  9d002e00  00010200  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 15 .sbss         0000016c  a0000208  9d002e08  00010208  2**2
                  ALLOC
 16 .bss          00000020  a0000374  9d002e08  00010374  2**2
                  ALLOC
 17 .heap         00000800  a0000398  9d002e08  00010398  2**0
                  ALLOC
 18 .stack        00000800  a0000b98  9d002e08  00010b98  2**0
                  ALLOC
 19 .comment      000000dc  00000000  00000000  00011a00  2**0
                  CONTENTS, READONLY
 20 .debug_aranges 00001148  00000000  00000000  00011adc  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_pubnames 00001b29  00000000  00000000  00012c24  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_info   0002c5dd  00000000  00000000  0001474d  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_abbrev 00007e5e  00000000  00000000  00040d2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_line   0000cbf7  00000000  00000000  00048b88  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_frame  000020cc  00000000  00000000  00055780  2**2
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_str    000056be  00000000  00000000  0005784c  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_loc    0001c1b1  00000000  00000000  0005cf0a  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .debug_pubtypes 00002cac  00000000  00000000  000790bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_ranges 00003860  00000000  00000000  0007bd67  2**0
                  CONTENTS, READONLY, DEBUGGING
 30 .gnu.attributes 00000010  00000000  00000000  0007f5c7  2**0
                  CONTENTS, READONLY
 31 .mdebug.abi32 00000000  a0001800  a0001800  00011800  2**0
                  CONTENTS, ALLOC, LOAD, DATA

Disassembly of section .reset:

9d001000 <_reset>:
9d001000:	3c1a9d00 	lui	k0,0x9d00
9d001004:	275a1010 	addiu	k0,k0,4112
9d001008:	03400008 	jr	k0
9d00100c:	00000000 	nop

Disassembly of section .app_excpt:

9d000180 <_gen_exception>:
9d000180:	3c1a9d00 	lui	k0,0x9d00
9d000184:	275a20dc 	addiu	k0,k0,8412
9d000188:	03400008 	jr	k0
9d00018c:	00000000 	nop

Disassembly of section .vector_0:

9d000200 <__vector_dispatch_0>:
9d000200:	0b4005ca 	j	9d001728 <CoreTimerHandler>
9d000204:	00000000 	nop

Disassembly of section .vector_4:

9d000280 <.vector_4>:
9d000280:	0b400548 	j	9d001520 <T1_ISR>
9d000284:	00000000 	nop

Disassembly of section .vector_24:

9d000500 <__vector_dispatch_24>:
9d000500:	0b4006f1 	j	9d001bc4 <IntSer0Handler>
9d000504:	00000000 	nop

Disassembly of section .vector_32:

9d000600 <__vector_dispatch_32>:
9d000600:	0b400731 	j	9d001cc4 <IntSer1Handler>
9d000604:	00000000 	nop

Disassembly of section .startup:

9d001010 <_startup>:
9d001010:	401a6000 	mfc0	k0,c0_status
9d001014:	7f5a04c0 	ext	k0,k0,0x13,0x1
9d001018:	13400005 	beqz	k0,9d001030 <_no_nmi>
9d00101c:	00000000 	nop
9d001020:	3c1a9d00 	lui	k0,0x9d00
9d001024:	275a21c4 	addiu	k0,k0,8644
9d001028:	03400008 	jr	k0
9d00102c:	00000000 	nop

9d001030 <_no_nmi>:
9d001030:	3c1da000 	lui	sp,0xa000
9d001034:	27bd4000 	addiu	sp,sp,16384
9d001038:	3c1ca001 	lui	gp,0xa001
9d00103c:	279c81f0 	addiu	gp,gp,-32272
9d001040:	40096002 	mfc0	t1,c0_srsctl
9d001044:	01205820 	add	t3,t1,zero
9d001048:	7d2a1e80 	ext	t2,t1,0x1a,0x4
9d00104c:	7d494984 	ins	t1,t2,0x6,0x4
9d001050:	40896002 	mtc0	t1,c0_srsctl
9d001054:	41dce000 	wrpgpr	gp,gp
9d001058:	408b6002 	mtc0	t3,c0_srsctl
9d00105c:	3c089d00 	lui	t0,0x9d00
9d001060:	250821b4 	addiu	t0,t0,8628
9d001064:	0100f809 	jalr	t0
9d001068:	00000000 	nop
9d00106c:	3c08a000 	lui	t0,0xa000
9d001070:	25080208 	addiu	t0,t0,520
9d001074:	3c09a000 	lui	t1,0xa000
9d001078:	25290394 	addiu	t1,t1,916
9d00107c:	10000006 	b	9d001098 <_bss_check>
9d001080:	00000000 	nop

9d001084 <_bss_init>:
9d001084:	ad000000 	sw	zero,0(t0)
9d001088:	ad000004 	sw	zero,4(t0)
9d00108c:	ad000008 	sw	zero,8(t0)
9d001090:	ad00000c 	sw	zero,12(t0)
9d001094:	25080010 	addiu	t0,t0,16

9d001098 <_bss_check>:
9d001098:	0109082b 	sltu	at,t0,t1
9d00109c:	1420fff9 	bnez	at,9d001084 <_bss_init>
9d0010a0:	00000000 	nop
9d0010a4:	3c089d00 	lui	t0,0x9d00
9d0010a8:	25082e00 	addiu	t0,t0,11776
9d0010ac:	3c09a000 	lui	t1,0xa000
9d0010b0:	25290200 	addiu	t1,t1,512
9d0010b4:	3c0aa000 	lui	t2,0xa000
9d0010b8:	254a0208 	addiu	t2,t2,520
9d0010bc:	10000005 	b	9d0010d4 <_init_check>
9d0010c0:	00000000 	nop

9d0010c4 <_init_data>:
9d0010c4:	8d0b0000 	lw	t3,0(t0)
9d0010c8:	ad2b0000 	sw	t3,0(t1)
9d0010cc:	25080004 	addiu	t0,t0,4
9d0010d0:	25290004 	addiu	t1,t1,4

9d0010d4 <_init_check>:
9d0010d4:	012a082b 	sltu	at,t1,t2
9d0010d8:	1420fffa 	bnez	at,9d0010c4 <_init_data>
9d0010dc:	00000000 	nop
9d0010e0:	3c090000 	lui	t1,0x0
9d0010e4:	25290000 	addiu	t1,t1,0
9d0010e8:	1120001d 	beqz	t1,9d001160 <_ramfunc_done>
9d0010ec:	00000000 	nop
9d0010f0:	3c089d00 	lui	t0,0x9d00
9d0010f4:	25082e08 	addiu	t0,t0,11784
9d0010f8:	3c09a000 	lui	t1,0xa000
9d0010fc:	25291800 	addiu	t1,t1,6144
9d001100:	3c0aa000 	lui	t2,0xa000
9d001104:	254a1800 	addiu	t2,t2,6144

9d001108 <_init_ramfunc>:
9d001108:	8d0b0000 	lw	t3,0(t0)
9d00110c:	ad2b0000 	sw	t3,0(t1)
9d001110:	25080004 	addiu	t0,t0,4
9d001114:	25290004 	addiu	t1,t1,4

9d001118 <_ramfunc_check>:
9d001118:	012a082b 	sltu	at,t1,t2
9d00111c:	1420fffa 	bnez	at,9d001108 <_init_ramfunc>
9d001120:	00000000 	nop
9d001124:	3c090000 	lui	t1,0x0
9d001128:	25291800 	addiu	t1,t1,6144
9d00112c:	3c0abf88 	lui	t2,0xbf88
9d001130:	254a2010 	addiu	t2,t2,8208
9d001134:	ad490000 	sw	t1,0(t2)
9d001138:	3c090000 	lui	t1,0x0
9d00113c:	25294000 	addiu	t1,t1,16384
9d001140:	3c0abf88 	lui	t2,0xbf88
9d001144:	254a2020 	addiu	t2,t2,8224
9d001148:	ad490000 	sw	t1,0(t2)
9d00114c:	3c090000 	lui	t1,0x0
9d001150:	25294000 	addiu	t1,t1,16384
9d001154:	3c0abf88 	lui	t2,0xbf88
9d001158:	254a2030 	addiu	t2,t2,8240
9d00115c:	ad490000 	sw	t1,0(t2)

9d001160 <_ramfunc_done>:
9d001160:	40804800 	mtc0	zero,c0_count
9d001164:	240affff 	li	t2,-1
9d001168:	408a5800 	mtc0	t2,c0_compare
9d00116c:	3c099d00 	lui	t1,0x9d00
9d001170:	25290000 	addiu	t1,t1,0
9d001174:	40897801 	mtc0	t1,c0_ebase
9d001178:	3c090000 	lui	t1,0x0
9d00117c:	25290001 	addiu	t1,t1,1
9d001180:	240a0000 	li	t2,0
9d001184:	7d2a4944 	ins	t2,t1,0x5,0x5
9d001188:	408a6001 	mtc0	t2,c0_intctl
9d00118c:	3c090080 	lui	t1,0x80
9d001190:	40896800 	mtc0	t1,c0_cause
9d001194:	40088000 	mfc0	t0,c0_config
9d001198:	7d090580 	ext	t1,t0,0x16,0x1
9d00119c:	00094c40 	sll	t1,t1,0x11
9d0011a0:	40086000 	mfc0	t0,c0_status
9d0011a4:	3c010058 	lui	at,0x58
9d0011a8:	01014024 	and	t0,t0,at
9d0011ac:	01284025 	or	t0,t1,t0
9d0011b0:	40886000 	mtc0	t0,c0_status
9d0011b4:	3c089d00 	lui	t0,0x9d00
9d0011b8:	250821bc 	addiu	t0,t0,8636
9d0011bc:	0100f809 	jalr	t0
9d0011c0:	00000000 	nop
9d0011c4:	40086000 	mfc0	t0,c0_status
9d0011c8:	3c01ffbf 	lui	at,0xffbf
9d0011cc:	3421ffff 	ori	at,at,0xffff
9d0011d0:	01014024 	and	t0,t0,at
9d0011d4:	40886000 	mtc0	t0,c0_status
9d0011d8:	30840000 	andi	a0,a0,0x0
9d0011dc:	30a50000 	andi	a1,a1,0x0
9d0011e0:	3c089d00 	lui	t0,0x9d00
9d0011e4:	250811f0 	addiu	t0,t0,4592
9d0011e8:	01000008 	jr	t0
9d0011ec:	00000000 	nop

Disassembly of section .text:

9d0011f0 <_main_entry>:
9d0011f0:	0f400a15 	jal	9d002854 <_text_end>
9d0011f4:	00000000 	nop
9d0011f8:	30840000 	andi	a0,a0,0x0
9d0011fc:	30a50000 	andi	a1,a1,0x0
9d001200:	0f4004ca 	jal	9d001328 <main>
9d001204:	00000000 	nop
9d001208:	1000fffd 	b	9d001200 <_main_entry+0x10>
9d00120c:	00000000 	nop

9d001210 <__do_global_dtors_aux>:
9d001210:	27bdffd8 	addiu	sp,sp,-40
9d001214:	afb2001c 	sw	s2,28(sp)
9d001218:	3c12a000 	lui	s2,0xa000
9d00121c:	92420374 	lbu	v0,884(s2)
9d001220:	afbf0024 	sw	ra,36(sp)
9d001224:	afb30020 	sw	s3,32(sp)
9d001228:	afb10018 	sw	s1,24(sp)
9d00122c:	14400020 	bnez	v0,9d0012b0 <__do_global_dtors_aux+0xa0>
9d001230:	afb00014 	sw	s0,20(sp)
9d001234:	3c119d00 	lui	s1,0x9d00
9d001238:	3c109d00 	lui	s0,0x9d00
9d00123c:	3c13a000 	lui	s3,0xa000
9d001240:	263128a0 	addiu	s1,s1,10400
9d001244:	261028a4 	addiu	s0,s0,10404
9d001248:	8e620378 	lw	v0,888(s3)
9d00124c:	02118023 	subu	s0,s0,s1
9d001250:	00108083 	sra	s0,s0,0x2
9d001254:	2610ffff 	addiu	s0,s0,-1
9d001258:	0050182b 	sltu	v1,v0,s0
9d00125c:	5060000c 	beqzl	v1,9d001290 <__do_global_dtors_aux+0x80>
9d001260:	3c020000 	lui	v0,0x0
9d001264:	24420001 	addiu	v0,v0,1
9d001268:	00021880 	sll	v1,v0,0x2
9d00126c:	02231821 	addu	v1,s1,v1
9d001270:	8c630000 	lw	v1,0(v1)
9d001274:	0060f809 	jalr	v1
9d001278:	ae620378 	sw	v0,888(s3)
9d00127c:	8e620378 	lw	v0,888(s3)
9d001280:	0050182b 	sltu	v1,v0,s0
9d001284:	1460fff8 	bnez	v1,9d001268 <__do_global_dtors_aux+0x58>
9d001288:	24420001 	addiu	v0,v0,1
9d00128c:	3c020000 	lui	v0,0x0
9d001290:	24420000 	addiu	v0,v0,0
9d001294:	10400005 	beqz	v0,9d0012ac <__do_global_dtors_aux+0x9c>
9d001298:	24020001 	li	v0,1
9d00129c:	3c04a000 	lui	a0,0xa000
9d0012a0:	0c000000 	jal	90000000 <_bmxdudba_address+0x8fffc000>
9d0012a4:	24840200 	addiu	a0,a0,512
9d0012a8:	24020001 	li	v0,1
9d0012ac:	a2420374 	sb	v0,884(s2)
9d0012b0:	8fbf0024 	lw	ra,36(sp)
9d0012b4:	8fb30020 	lw	s3,32(sp)
9d0012b8:	8fb2001c 	lw	s2,28(sp)
9d0012bc:	8fb10018 	lw	s1,24(sp)
9d0012c0:	8fb00014 	lw	s0,20(sp)
9d0012c4:	03e00008 	jr	ra
9d0012c8:	27bd0028 	addiu	sp,sp,40

9d0012cc <frame_dummy>:
9d0012cc:	3c020000 	lui	v0,0x0
9d0012d0:	27bdffe8 	addiu	sp,sp,-24
9d0012d4:	24420000 	addiu	v0,v0,0
9d0012d8:	10400006 	beqz	v0,9d0012f4 <frame_dummy+0x28>
9d0012dc:	afbf0014 	sw	ra,20(sp)
9d0012e0:	3c04a000 	lui	a0,0xa000
9d0012e4:	3c05a000 	lui	a1,0xa000
9d0012e8:	24840200 	addiu	a0,a0,512
9d0012ec:	0c000000 	jal	90000000 <_bmxdudba_address+0x8fffc000>
9d0012f0:	24a5037c 	addiu	a1,a1,892
9d0012f4:	3c04a000 	lui	a0,0xa000
9d0012f8:	8c820200 	lw	v0,512(a0)
9d0012fc:	10400007 	beqz	v0,9d00131c <frame_dummy+0x50>
9d001300:	3c190000 	lui	t9,0x0
9d001304:	27390000 	addiu	t9,t9,0
9d001308:	13200004 	beqz	t9,9d00131c <frame_dummy+0x50>
9d00130c:	8fbf0014 	lw	ra,20(sp)
9d001310:	24840200 	addiu	a0,a0,512
9d001314:	03200008 	jr	t9
9d001318:	27bd0018 	addiu	sp,sp,24
9d00131c:	8fbf0014 	lw	ra,20(sp)
9d001320:	03e00008 	jr	ra
9d001324:	27bd0018 	addiu	sp,sp,24

9d001328 <main>:
9d001328:	27bdffe8 	addiu	sp,sp,-24
9d00132c:	afbf0014 	sw	ra,20(sp)
9d001330:	afbe0010 	sw	s8,16(sp)
9d001334:	03a0f021 	move	s8,sp
9d001338:	0f400580 	jal	9d001600 <init>
9d00133c:	00000000 	nop
9d001340:	3c02a000 	lui	v0,0xa000
9d001344:	2444021c 	addiu	a0,v0,540
9d001348:	24052580 	li	a1,9600
9d00134c:	0f40069f 	jal	9d001a7c <_ZN14HardwareSerial5beginEm>
9d001350:	00000000 	nop
9d001354:	0f4004e4 	jal	9d001390 <SetupPort>
9d001358:	00000000 	nop
9d00135c:	0f4004ea 	jal	9d0013a8 <SetupTimer>
9d001360:	00000000 	nop
9d001364:	0f400508 	jal	9d001420 <ProgramNote>
9d001368:	00000000 	nop
9d00136c:	0f400523 	jal	9d00148c <PlayNote>
9d001370:	00000000 	nop
9d001374:	00001021 	move	v0,zero
9d001378:	03c0e821 	move	sp,s8
9d00137c:	8fbf0014 	lw	ra,20(sp)
9d001380:	8fbe0010 	lw	s8,16(sp)
9d001384:	27bd0018 	addiu	sp,sp,24
9d001388:	03e00008 	jr	ra
9d00138c:	00000000 	nop

9d001390 <SetupPort>:
9d001390:	240a0008 3c18bf88 271860c0 af0a0004     ...$...<.`.'....
9d0013a0:	03e00008 00000000                       ........

9d0013a8 <SetupTimer>:
9d0013a8:	34088000 3c18bf80 27180600 af080004     ...4...<...'....
9d0013b8:	24080002 af080004 24080030 af080008     ...$....0..$....
9d0013c8:	3408ffff 3c18bf80 27180610 af080004     ...4...<...'....
9d0013d8:	24080000 3c18bf80 27180620 af080008     ...$...< ..'....
9d0013e8:	2408001c 3c18bf88 271810a0 af080008     ...$...<...'....
9d0013f8:	24080010 3c18bf88 27181030 af080004     ...$...<0..'....
9d001408:	24080010 3c18bf88 27181060 af080008     ...$...<`..'....
9d001418:	03e00008 00000000                       ........

9d001420 <ProgramNote>:
9d001420:	afbf0000 23bdfffc 0f400527 00000000     .......#'.@.....

9d001430 <testSound>:
9d001430:	24040000 	li	a0,0
9d001434:	0f400635 	jal	9d0018d4 <analogRead>
9d001438:	00000000 	nop
9d00143c:	00402021 	move	a0,v0
9d001440:	0f400533 	jal	9d0014cc <Freq2Period>
9d001444:	00000000 	nop
9d001448:	3c18bf80 	lui	t8,0xbf80
9d00144c:	27180620 	addiu	t8,t8,1568
9d001450:	3408ffff 	li	t0,0xffff
9d001454:	af080004 	sw	t0,4(t8)
9d001458:	af040008 	sw	a0,8(t8)
9d00145c:	3c04a000 	lui	a0,0xa000
9d001460:	2484021c 	addiu	a0,a0,540
9d001464:	00402821 	move	a1,v0
9d001468:	2406000a 	li	a2,10
9d00146c:	0f40082d 	jal	9d0020b4 <_ZN5Print7printlnEii>
9d001470:	00000000 	nop
9d001474:	0b40050c 	j	9d001430 <testSound>
9d001478:	00000000 	nop
9d00147c:	23bd0004 	addi	sp,sp,4
9d001480:	8fbf0000 	lw	ra,0(sp)
9d001484:	03e00008 	jr	ra
9d001488:	00000000 	nop

9d00148c <PlayNote>:
9d00148c:	afbf0000 23bdfffc 03e00008 00000000     .......#........

9d00149c <EnableTimer>:
9d00149c:	24080010 	li	t0,16
9d0014a0:	3c18bf88 	lui	t8,0xbf88
9d0014a4:	27181030 	addiu	t8,t8,4144
9d0014a8:	af080004 	sw	t0,4(t8)
9d0014ac:	34088000 	li	t0,0x8000
9d0014b0:	3c18bf80 	lui	t8,0xbf80
9d0014b4:	27180600 	addiu	t8,t8,1536
9d0014b8:	af080008 	sw	t0,8(t8)
9d0014bc:	03e00008 	jr	ra
9d0014c0:	00000000 	nop

9d0014c4 <DisableTimer>:
9d0014c4:	03e00008 	jr	ra
9d0014c8:	00000000 	nop

9d0014cc <Freq2Period>:
9d0014cc:	24020000 	li	v0,0
9d0014d0:	10800011 	beqz	a0,9d001518 <ReturnPeriod>
9d0014d4:	00000000 	nop
9d0014d8:	3c0204c4 	lui	v0,0x4c4
9d0014dc:	3442b400 	ori	v0,v0,0xb400
9d0014e0:	24090100 	li	t1,256
9d0014e4:	240a0002 	li	t2,2
9d0014e8:	70894002 	mul	t0,a0,t1
9d0014ec:	710a4002 	mul	t0,t0,t2
9d0014f0:	15000002 	bnez	t0,9d0014fc <Freq2Period+0x30>
9d0014f4:	0048001a 	div	zero,v0,t0
9d0014f8:	0007000d 	break	0x7
9d0014fc:	2401ffff 	li	at,-1
9d001500:	15010004 	bne	t0,at,9d001514 <Freq2Period+0x48>
9d001504:	3c018000 	lui	at,0x8000
9d001508:	14410002 	bne	v0,at,9d001514 <Freq2Period+0x48>
9d00150c:	00000000 	nop
9d001510:	0006000d 	break	0x6
9d001514:	00001012 	mflo	v0

9d001518 <ReturnPeriod>:
9d001518:	03e00008 	jr	ra
9d00151c:	00000000 	nop

9d001520 <T1_ISR>:
9d001520:	240a0008 	li	t2,8
9d001524:	3c18bf88 	lui	t8,0xbf88
9d001528:	271860d0 	addiu	t8,t8,24784
9d00152c:	af0a000c 	sw	t2,12(t8)
9d001530:	24080010 	li	t0,16
9d001534:	3c18bf88 	lui	t8,0xbf88
9d001538:	27181030 	addiu	t8,t8,4144
9d00153c:	af080004 	sw	t0,4(t8)
9d001540:	3408ffff 	li	t0,0xffff
9d001544:	3c18bf80 	lui	t8,0xbf80
9d001548:	27180610 	addiu	t8,t8,1552
9d00154c:	af080004 	sw	t0,4(t8)
9d001550:	42000018 	eret
9d001554:	00000000 	nop

9d001558 <micros>:
// overflows. The first value of CoreTimer after an overflow is recorded,
// and all micros() calls after that (until the next overflow) are 
// referenced from that value. This insures accuracy and that micros()
// lines up perfectly with millis().
//************************************************************************
unsigned long micros()
9d001558:	27bdffe8 	addiu	sp,sp,-24
9d00155c:	afbf0014 	sw	ra,20(sp)
9d001560:	afb00010 	sw	s0,16(sp)
    10. Understand, your callback is being called while executing inside the CoreTimerHandler ISR. Your code should be as fast as possible. If too much
        time is taken, the ISR may never exit and no sketch will ever run!
*/
//************************************************************************
#define read_count(dest) __asm__ __volatile__("mfc0 %0,$9" : "=r" (dest))
#define read_comp(dest) __asm__ __volatile__("mfc0 %0,$11" : "=r" (dest))
9d001564:	41626000 	di	v0
unsigned int cur_timer_val	=	0;
unsigned int micros_delta	=	0;

	unsigned int result;
	
	INTDisableInterrupts();
9d001568:	0f40087a 	jal	9d0021e8 <ReadCoreTimer>
	result = gTimer0_millis * 1000;
9d00156c:	8f908018 	lw	s0,-32744(gp)
	cur_timer_val = ReadCoreTimer();
9d001570:	8f83801c 	lw	v1,-32740(gp)
9d001574:	00431023 	subu	v0,v0,v1
	cur_timer_val -= gCore_timer_last_val;
9d001578:	24420014 	addiu	v0,v0,20
    5.	Unfortunately, because of things like the EEProm writes, you can be called late and you must “catch-up” however best you can and return 
        the next requested “compare” time on your next call.
    6.	There are limits to how far in the future you can set your next "compare" time. Right now this is limited to 90 seconds. If you need a longer delay you
        should be using something other than a CoreTimer Services to do this. You probably should really limit your next "compare" time to less than few seconds.
    7.	Your next requested “compare” time MUST be equal to or after (in time) the “current” time as passed in to you. You may add up to 90 seconds to the 
        current time, even if this causes uint32 wrap; but do not subtract from the current time and return that. There is a region known to CoreTimerHandler 
9d00157c:	41636020 	ei	v1
	
	INTDisableInterrupts();
	result = gTimer0_millis * 1000;
	cur_timer_val = ReadCoreTimer();
	cur_timer_val -= gCore_timer_last_val;
	cur_timer_val += CORETIMER_TICKS_PER_MICROSECOND/2;  // rounding
9d001580:	3c04cccc 	lui	a0,0xcccc
9d001584:	3484cccd 	ori	a0,a0,0xcccd
9d001588:	00440019 	multu	v0,a0
unsigned int cur_timer_val	=	0;
unsigned int micros_delta	=	0;

	unsigned int result;
	
	INTDisableInterrupts();
9d00158c:	00101880 	sll	v1,s0,0x2
9d001590:	001021c0 	sll	a0,s0,0x7
9d001594:	00831823 	subu	v1,a0,v1
	cur_timer_val -= gCore_timer_last_val;
	cur_timer_val += CORETIMER_TICKS_PER_MICROSECOND/2;  // rounding
	cur_timer_val /= CORETIMER_TICKS_PER_MICROSECOND;  // convert to microseconds
	INTEnableInterrupts();
	return (result + cur_timer_val);

9d001598:	8fbf0014 	lw	ra,20(sp)
unsigned int cur_timer_val	=	0;
unsigned int micros_delta	=	0;

	unsigned int result;
	
	INTDisableInterrupts();
9d00159c:	00708021 	addu	s0,v1,s0
9d0015a0:	001080c0 	sll	s0,s0,0x3
	result = gTimer0_millis * 1000;
	cur_timer_val = ReadCoreTimer();
	cur_timer_val -= gCore_timer_last_val;
	cur_timer_val += CORETIMER_TICKS_PER_MICROSECOND/2;  // rounding
9d0015a4:	00001010 	mfhi	v0
9d0015a8:	00021142 	srl	v0,v0,0x5
	cur_timer_val /= CORETIMER_TICKS_PER_MICROSECOND;  // convert to microseconds
	INTEnableInterrupts();
	return (result + cur_timer_val);

9d0015ac:	00501021 	addu	v0,v0,s0
9d0015b0:	8fb00010 	lw	s0,16(sp)
9d0015b4:	03e00008 	jr	ra
9d0015b8:	27bd0018 	addiu	sp,sp,24

9d0015bc <delayMicroseconds>:
//************************************************************************
//*	Delay for the given number of microseconds. Will fail on micros()
//*	rollover every 71 minutes
void delayMicroseconds(unsigned int us)
{
unsigned long	startMicros	=	micros();
9d0015bc:	27bdffe0 	addiu	sp,sp,-32
9d0015c0:	afb10018 	sw	s1,24(sp)
9d0015c4:	afb00014 	sw	s0,20(sp)
9d0015c8:	afbf001c 	sw	ra,28(sp)

9d0015cc:	0f400556 	jal	9d001558 <micros>
9d0015d0:	00808821 	move	s1,a0
9d0015d4:	00408021 	move	s0,v0
	while ((micros() - startMicros) < us)
	{
9d0015d8:	0f400556 	jal	9d001558 <micros>
9d0015dc:	00000000 	nop
9d0015e0:	00501023 	subu	v0,v0,s0
9d0015e4:	0051102b 	sltu	v0,v0,s1
9d0015e8:	1440fffb 	bnez	v0,9d0015d8 <delayMicroseconds+0x1c>
9d0015ec:	8fbf001c 	lw	ra,28(sp)
		//*	do nothing
	}
}

9d0015f0:	8fb10018 	lw	s1,24(sp)
9d0015f4:	8fb00014 	lw	s0,20(sp)
9d0015f8:	03e00008 	jr	ra
9d0015fc:	27bd0020 	addiu	sp,sp,32

9d001600 <init>:

//************************************************************************
void init()
{

9d001600:	27bdffe0 	addiu	sp,sp,-32
9d001604:	afbf001c 	sw	ra,28(sp)
9d001608:	afb10018 	sw	s1,24(sp)
9d00160c:	afb00014 	sw	s0,20(sp)
    10. Understand, your callback is being called while executing inside the CoreTimerHandler ISR. Your code should be as fast as possible. If too much
        time is taken, the ISR may never exit and no sketch will ever run!
*/
//************************************************************************
#define read_count(dest) __asm__ __volatile__("mfc0 %0,$9" : "=r" (dest))
#define read_comp(dest) __asm__ __volatile__("mfc0 %0,$11" : "=r" (dest))
9d001610:	41716000 	di	s1
    unsigned int cache_status;
#endif

    int_status=INTDisableInterrupts();

    mBMXDisableDRMWaitState();
9d001614:	24030040 	li	v1,64
9d001618:	3c02bf88 	lui	v0,0xbf88
9d00161c:	ac432004 	sw	v1,8196(v0)
9d001620:	41646000 	di	a0
        wait_states++;
        sys_clock -= FLASH_SPEED_HZ;
    }

    int_status=INTDisableInterrupts();
    mCheConfigure(wait_states);
9d001624:	3c10bf88 	lui	s0,0xbf88
9d001628:	24020002 	li	v0,2
9d00162c:	0f400882 	jal	9d002208 <INTRestoreInterrupts>
    INTRestoreInterrupts(int_status);
9d001630:	ae024000 	sw	v0,16384(s0)


#ifdef _PCACHE
    if(flags & SYS_CFG_PCACHE)
    {
        cache_status = mCheGetCon();
9d001634:	8e024000 	lw	v0,16384(s0)
        cache_status |= CHE_CONF_PF_ALL;
9d001638:	34420030 	ori	v0,v0,0x30
        mCheConfigure(cache_status);
9d00163c:	0f40087c 	jal	9d0021f0 <CheKseg0CacheOn>
        CheKseg0CacheOn();
9d001640:	ae024000 	sw	v0,16384(s0)
    }
#endif

    pb_clk = sys_clock;
    pb_clk >>= OSCCONbits.PBDIV;
9d001644:	3c02bf81 	lui	v0,0xbf81
9d001648:	8c50f000 	lw	s0,-4096(v0)

    INTRestoreInterrupts(int_status);
9d00164c:	0f400882 	jal	9d002208 <INTRestoreInterrupts>
9d001650:	02202021 	move	a0,s1
        CheKseg0CacheOn();
    }
#endif

    pb_clk = sys_clock;
    pb_clk >>= OSCCONbits.PBDIV;
9d001654:	3c0204c4 	lui	v0,0x4c4
9d001658:	3442b400 	ori	v0,v0,0xb400
9d00165c:	7e100cc0 	ext	s0,s0,0x13,0x2
9d001660:	02028006 	srlv	s0,v0,s0
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif


	OpenCoreTimer(CORE_TICK_RATE);

9d001664:	34049c40 	li	a0,0x9c40
9d001668:	0f400877 	jal	9d0021dc <OpenCoreTimer>
9d00166c:	af90817c 	sw	s0,-32388(gp)
	// set up the core timer interrupt with a prioirty of 2 and zero sub-priority
	mConfigIntCoreTimer(CT_INT_ON | _CT_IPL_IPC | (_CT_SPL_IPC << 4));

9d001670:	24020001 	li	v0,1
9d001674:	3c05bf88 	lui	a1,0xbf88
9d001678:	aca21034 	sw	v0,4148(a1)
9d00167c:	3c04bf88 	lui	a0,0xbf88
9d001680:	2405001c 	li	a1,28
9d001684:	ac851094 	sw	a1,4244(a0)
9d001688:	3c03bf88 	lui	v1,0xbf88
9d00168c:	24050008 	li	a1,8
9d001690:	ac651098 	sw	a1,4248(v1)
9d001694:	24050003 	li	a1,3
9d001698:	ac851094 	sw	a1,4244(a0)
9d00169c:	ac601098 	sw	zero,4248(v1)
9d0016a0:	3c03bf88 	lui	v1,0xbf88
9d0016a4:	ac621064 	sw	v0,4196(v1)
9d0016a8:	3c03bf88 	lui	v1,0xbf88
9d0016ac:	0f400889 	jal	9d002224 <INTEnableSystemMultiVectoredInt>
	// enable multi-vector interrupts
	INTEnableSystemMultiVectoredInt();

9d0016b0:	ac621068 	sw	v0,4200(v1)

#ifdef _ENABLE_PIC_RTC_
	RtccInit();									// init the RTCC
//	while(RtccGetClkStat() != RTCC_CLK_ON);		// wait for the SOSC to be actually running and RTCC to have its clock source
9d0016b4:	0f400896 	jal	9d002258 <RtccInit>
9d0016b8:	00000000 	nop
void delay(unsigned long ms)
{
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d0016bc:	8f838018 	lw	v1,-32744(gp)
	{
9d0016c0:	8f828018 	lw	v0,-32744(gp)
9d0016c4:	00431023 	subu	v0,v0,v1
9d0016c8:	2c420032 	sltiu	v0,v0,50
9d0016cc:	1440fffc 	bnez	v0,9d0016c0 <init+0xc0>
9d0016d0:	3c051101 	lui	a1,0x1101
												// could wait here at most 32ms

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 

	delay(50);
9d0016d4:	3c101007 	lui	s0,0x1007
9d0016d8:	26043000 	addiu	a0,s0,12288
9d0016dc:	24a50901 	addiu	a1,a1,2305
9d0016e0:	0f4008e4 	jal	9d002390 <RtccOpen>
9d0016e4:	00003021 	move	a2,zero
	// time is MSb: hour, min, sec, rsvd. date is MSb: year, mon, mday, wday.
9d0016e8:	3c051010 	lui	a1,0x1010
9d0016ec:	36043000 	ori	a0,s0,0x3000
9d0016f0:	0f4008da 	jal	9d002368 <RtccSetTimeDate>
9d0016f4:	24a51701 	addiu	a1,a1,5889
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif


	//*	as per Al.Rodriguez@microchip.com, Jan 7, 2011
9d0016f8:	3c02bf81 	lui	v0,0xbf81
9d0016fc:	8c43f200 	lw	v1,-3584(v0)
	//* Initialize the periodic task manager
	_initTaskManager();

	//*	Issue #84
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
9d001700:	8fbf001c 	lw	ra,28(sp)
9d001704:	8fb10018 	lw	s1,24(sp)
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif


	//*	as per Al.Rodriguez@microchip.com, Jan 7, 2011
9d001708:	7c0318c4 	ins	v1,zero,0x3,0x1
9d00170c:	ac43f200 	sw	v1,-3584(v0)
#endif

	//* Initialize the periodic task manager
	_initTaskManager();

	//*	Issue #84
9d001710:	34038000 	li	v1,0x8000
9d001714:	3c02bf80 	lui	v0,0xbf80
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
9d001718:	8fb00014 	lw	s0,20(sp)
#endif

	//* Initialize the periodic task manager
	_initTaskManager();

	//*	Issue #84
9d00171c:	ac436004 	sw	v1,24580(v0)
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
9d001720:	03e00008 	jr	ra
9d001724:	27bd0020 	addiu	sp,sp,32

9d001728 <CoreTimerHandler>:
#endif
}



//************************************************************************
9d001728:	415de800 	rdpgpr	sp,sp
9d00172c:	401a7000 	mfc0	k0,c0_epc
9d001730:	401b6000 	mfc0	k1,c0_status
9d001734:	27bdff90 	addiu	sp,sp,-112
9d001738:	afbb0068 	sw	k1,104(sp)
9d00173c:	7c1b7844 	ins	k1,zero,0x1,0xf
9d001740:	377b0800 	ori	k1,k1,0x800
9d001744:	afba006c 	sw	k0,108(sp)
9d001748:	409b6000 	mtc0	k1,c0_status
9d00174c:	afbf005c 	sw	ra,92(sp)
9d001750:	afb90058 	sw	t9,88(sp)
9d001754:	afb80054 	sw	t8,84(sp)
9d001758:	afb00050 	sw	s0,80(sp)
9d00175c:	afaf004c 	sw	t7,76(sp)
9d001760:	afae0048 	sw	t6,72(sp)
9d001764:	afad0044 	sw	t5,68(sp)
9d001768:	afac0040 	sw	t4,64(sp)
9d00176c:	afab003c 	sw	t3,60(sp)
9d001770:	afaa0038 	sw	t2,56(sp)
9d001774:	afa90034 	sw	t1,52(sp)
9d001778:	afa80030 	sw	t0,48(sp)
9d00177c:	afa7002c 	sw	a3,44(sp)
9d001780:	afa60028 	sw	a2,40(sp)
9d001784:	afa50024 	sw	a1,36(sp)
9d001788:	afa40020 	sw	a0,32(sp)
9d00178c:	afa3001c 	sw	v1,28(sp)
9d001790:	afa20018 	sw	v0,24(sp)
9d001794:	afa10014 	sw	at,20(sp)
9d001798:	00001012 	mflo	v0
9d00179c:	afa20064 	sw	v0,100(sp)
{
    unsigned int status = 0;

    asm volatile("ei    %0" : "=r"(status));

    return status;
9d0017a0:	8f828020 	lw	v0,-32736(gp)
#endif
}



//************************************************************************
9d0017a4:	00001810 	mfhi	v1
//*	Interrupts are enabled by setting the IE bit in the status register
//************************************************************************
unsigned int __attribute__((nomips16))  INTEnableInterrupts(void)
{
    unsigned int status = 0;
9d0017a8:	8f908018 	lw	s0,-32744(gp)

    asm volatile("ei    %0" : "=r"(status));

    return status;
9d0017ac:	1040003d 	beqz	v0,9d0018a4 <CoreTimerHandler+0x17c>
9d0017b0:	afa30060 	sw	v1,96(sp)
}

9d0017b4:	0040f809 	jalr	v0
9d0017b8:	00000000 	nop

//************************************************************************
//*	Interrupts are disabled by clearing the IE bit in the status register
9d0017bc:	14400023 	bnez	v0,9d00184c <CoreTimerHandler+0x124>
9d0017c0:	24030001 	li	v1,1
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.

    The rules:

    1.	You do NOT set “compare”!
    2.  Do not do anything that could cause CoreTimerHandler to be called recursively. For example, do not enable interrupts as the CT flag is still set
9d0017c4:	3c02bf88 	lui	v0,0xbf88
9d0017c8:	ac431034 	sw	v1,4148(v0)
        and will immeditely cause the system to call CoreTimerHandler.
9d0017cc:	8fa50064 	lw	a1,100(sp)
9d0017d0:	8fbf005c 	lw	ra,92(sp)
9d0017d4:	8fb90058 	lw	t9,88(sp)
9d0017d8:	00a00013 	mtlo	a1
9d0017dc:	8fa50060 	lw	a1,96(sp)
9d0017e0:	8fb80054 	lw	t8,84(sp)
9d0017e4:	8fb00050 	lw	s0,80(sp)
9d0017e8:	00a00011 	mthi	a1
9d0017ec:	8faf004c 	lw	t7,76(sp)
9d0017f0:	8fae0048 	lw	t6,72(sp)
9d0017f4:	8fad0044 	lw	t5,68(sp)
9d0017f8:	8fac0040 	lw	t4,64(sp)
9d0017fc:	8fab003c 	lw	t3,60(sp)
9d001800:	8faa0038 	lw	t2,56(sp)
9d001804:	8fa90034 	lw	t1,52(sp)
9d001808:	8fa80030 	lw	t0,48(sp)
9d00180c:	8fa7002c 	lw	a3,44(sp)
9d001810:	8fa60028 	lw	a2,40(sp)
9d001814:	8fa50024 	lw	a1,36(sp)
9d001818:	8fa40020 	lw	a0,32(sp)
9d00181c:	8fa3001c 	lw	v1,28(sp)
9d001820:	8fa20018 	lw	v0,24(sp)
9d001824:	8fa10014 	lw	at,20(sp)
9d001828:	41606000 	di
9d00182c:	000000c0 	ehb
9d001830:	8fba006c 	lw	k0,108(sp)
9d001834:	8fbb0068 	lw	k1,104(sp)
9d001838:	409a7000 	mtc0	k0,c0_epc
9d00183c:	27bd0070 	addiu	sp,sp,112
9d001840:	41dde800 	wrpgpr	sp,sp
9d001844:	409b6000 	mtc0	k1,c0_status
9d001848:	42000018 	eret
    return status;
}


//************************************************************************
//*	Interrupts are disabled by clearing the IE bit in the status register
9d00184c:	8f898020 	lw	t1,-32736(gp)
9d001850:	8f828024 	lw	v0,-32732(gp)
}



//************************************************************************
//*	CoreTimerHandler Services (KeithV)
9d001854:	3c080013 	lui	t0,0x13
//************************************************************************
unsigned int __attribute__((nomips16)) INTDisableInterrupts(void)
{
    unsigned int status = 0;

    asm volatile("di    %0" : "=r"(status));
9d001858:	34049c40 	li	a0,0x9c40
}



//************************************************************************
//*	CoreTimerHandler Services (KeithV)
9d00185c:	35088801 	ori	t0,t0,0x8801
//************************************************************************
//*	Interrupts are disabled by clearing the IE bit in the status register
//************************************************************************
unsigned int __attribute__((nomips16)) INTDisableInterrupts(void)
{
    unsigned int status = 0;
9d001860:	26100001 	addiu	s0,s0,1

9d001864:	40034800 	mfc0	v1,c0_count
    asm volatile("di    %0" : "=r"(status));
9d001868:	00441021 	addu	v0,v0,a0
    return status;
}



//************************************************************************
9d00186c:	0044282b 	sltu	a1,v0,a0
/*
    uint32_t CoreTimerService(uint32_t count)

    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
9d001870:	0043302b 	sltu	a2,v0,v1
    return status;
}



//************************************************************************
9d001874:	10a00003 	beqz	a1,9d001884 <CoreTimerHandler+0x15c>
9d001878:	0068382b 	sltu	a3,v1,t0
//*	CoreTimerHandler Services (KeithV)
9d00187c:	10e00003 	beqz	a3,9d00188c <CoreTimerHandler+0x164>
9d001880:	00000000 	nop
/*
    uint32_t CoreTimerService(uint32_t count)

    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
9d001884:	54c0fff7 	bnezl	a2,9d001864 <CoreTimerHandler+0x13c>
9d001888:	26100001 	addiu	s0,s0,1
    register your callback serivce it should be called within 1 ms of attaching (registering). In some cases if interrupts are diaabled it may be as 
    long as 50 ms before your first call is made. Passed in to your Service is the current value of the CoreTimer count register, this is a rolling count 
9d00188c:	11200007 	beqz	t1,9d0018ac <CoreTimerHandler+0x184>
9d001890:	af828024 	sw	v0,-32732(gp)
    that rolls once every 2^32 / 40000000 ~ 107seconds. The return value from your service should be the next value of count that you want to be notified; 
    logically like setting the compare register; however, CoreTimerHandler is managing several services and will notify you when your value has been hit. 
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.
9d001894:	af83801c 	sw	v1,-32740(gp)

9d001898:	af908018 	sw	s0,-32744(gp)
    The rules:

    1.	You do NOT set “compare”!
    2.  Do not do anything that could cause CoreTimerHandler to be called recursively. For example, do not enable interrupts as the CT flag is still set
9d00189c:	0b4005f1 	j	9d0017c4 <CoreTimerHandler+0x9c>
9d0018a0:	24030001 	li	v1,1
{
    unsigned int status = 0;

    asm volatile("ei    %0" : "=r"(status));

    return status;
9d0018a4:	0b400614 	j	9d001850 <CoreTimerHandler+0x128>
9d0018a8:	00004821 	move	t1,zero
    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
    register your callback serivce it should be called within 1 ms of attaching (registering). In some cases if interrupts are diaabled it may be as 
    long as 50 ms before your first call is made. Passed in to your Service is the current value of the CoreTimer count register, this is a rolling count 
    that rolls once every 2^32 / 40000000 ~ 107seconds. The return value from your service should be the next value of count that you want to be notified; 
9d0018ac:	40825800 	mtc0	v0,c0_compare
    logically like setting the compare register; however, CoreTimerHandler is managing several services and will notify you when your value has been hit. 
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.
9d0018b0:	af83801c 	sw	v1,-32740(gp)
    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
    register your callback serivce it should be called within 1 ms of attaching (registering). In some cases if interrupts are diaabled it may be as 
    long as 50 ms before your first call is made. Passed in to your Service is the current value of the CoreTimer count register, this is a rolling count 
    that rolls once every 2^32 / 40000000 ~ 107seconds. The return value from your service should be the next value of count that you want to be notified; 
9d0018b4:	af828024 	sw	v0,-32732(gp)
    logically like setting the compare register; however, CoreTimerHandler is managing several services and will notify you when your value has been hit. 
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.

9d0018b8:	af908018 	sw	s0,-32744(gp)
    The rules:

    1.	You do NOT set “compare”!
    2.  Do not do anything that could cause CoreTimerHandler to be called recursively. For example, do not enable interrupts as the CT flag is still set
9d0018bc:	0b4005f1 	j	9d0017c4 <CoreTimerHandler+0x9c>
9d0018c0:	24030001 	li	v1,1

9d0018c4 <INTEnableInterrupts>:
    5.	Unfortunately, because of things like the EEProm writes, you can be called late and you must “catch-up” however best you can and return 
        the next requested “compare” time on your next call.
    6.	There are limits to how far in the future you can set your next "compare" time. Right now this is limited to 90 seconds. If you need a longer delay you
        should be using something other than a CoreTimer Services to do this. You probably should really limit your next "compare" time to less than few seconds.
    7.	Your next requested “compare” time MUST be equal to or after (in time) the “current” time as passed in to you. You may add up to 90 seconds to the 
        current time, even if this causes uint32 wrap; but do not subtract from the current time and return that. There is a region known to CoreTimerHandler 
9d0018c4:	03e00008 	jr	ra
        that is before the current time, but that uint32 "value" is after the current time + 90 seconds.
     8.	CoreTimerHandler will keep looping until count is less than whatever the next compare is “after” CT was cleared to insure that CT is not missed. 
        It is possible that you could be called a second time before exiting the CoreTimerHandler ISR if you request a new compare time that is very close to 
9d0018c8:	41626020 	ei	v0

9d0018cc <INTDisableInterrupts>:
    10. Understand, your callback is being called while executing inside the CoreTimerHandler ISR. Your code should be as fast as possible. If too much
        time is taken, the ISR may never exit and no sketch will ever run!
*/
//************************************************************************
#define read_count(dest) __asm__ __volatile__("mfc0 %0,$9" : "=r" (dest))
#define read_comp(dest) __asm__ __volatile__("mfc0 %0,$11" : "=r" (dest))
9d0018cc:	03e00008 	jr	ra
#define write_comp(src) __asm__ __volatile__("mtc0 %0,$11" : : "r" (src))

#define mCTSetIntFlag() (IFS0SET = _IFS0_CTIF_MASK)
9d0018d0:	41626000 	di	v0

9d0018d4 <analogRead>:
//*	only one result will be read with that value being mirrored in the second result.
//*	I commented out the code using the Microchip PIC32 Peripheral Libraries and substituted 
//*	direct writes to the registers as shown below. This fixed all problems and works great:
//*********************************************************************
int analogRead(uint8_t pin)
{
9d0018d4:	308400ff 	andi	a0,a0,0xff
9d0018d8:	27bdffe0 	addiu	sp,sp,-32

	/* Pin number is allowed to be either the digital pin number or the
	** analog pin number. Map the input so that it is guaranteed to be
	** an analog pin number.
	*/
	pin = (pin < NUM_DIGITAL_PINS) ? digitalPinToAnalog(pin) : NOT_ANALOG_PIN;
9d0018dc:	2c83002f 	sltiu	v1,a0,47
//*	only one result will be read with that value being mirrored in the second result.
//*	I commented out the code using the Microchip PIC32 Peripheral Libraries and substituted 
//*	direct writes to the registers as shown below. This fixed all problems and works great:
//*********************************************************************
int analogRead(uint8_t pin)
{
9d0018e0:	afbf001c 	sw	ra,28(sp)
9d0018e4:	afb10018 	sw	s1,24(sp)
9d0018e8:	afb00014 	sw	s0,20(sp)

	/* Pin number is allowed to be either the digital pin number or the
	** analog pin number. Map the input so that it is guaranteed to be
	** an analog pin number.
	*/
	pin = (pin < NUM_DIGITAL_PINS) ? digitalPinToAnalog(pin) : NOT_ANALOG_PIN;
9d0018ec:	10600028 	beqz	v1,9d001990 <analogRead+0xbc>
9d0018f0:	00001021 	move	v0,zero
9d0018f4:	2c83000c 	sltiu	v1,a0,12
9d0018f8:	5060002a 	beqzl	v1,9d0019a4 <analogRead+0xd0>
9d0018fc:	2484fff2 	addiu	a0,a0,-14

	/* Map the analog pin number to the correct analog mux channel in the
	** A/D converter. In some cases this is a direct mapping. In that case,
	** the conversion macro just returns it parameter.
	*/
	channelNumber = analogInPinToChannel(pin);
9d001900:	3c029d00 	lui	v0,0x9d00
9d001904:	244228cc 	addiu	v0,v0,10444
9d001908:	00822021 	addu	a0,a0,v0

	/* Ensure that the pin associated with the analog channel is in analog
	** input mode, and select the channel in the input mux.
	*/
	AD1PCFG = ~(1 << channelNumber);
9d00190c:	90850000 	lbu	a1,0(a0)
9d001910:	24060001 	li	a2,1
9d001914:	3c03bf81 	lui	v1,0xbf81
9d001918:	00a63004 	sllv	a2,a2,a1
9d00191c:	00063027 	nor	a2,zero,a2
9d001920:	ac669060 	sw	a2,-28576(v1)
	AD1CHS = (channelNumber & 0xFFFF) << 16;
9d001924:	00052c00 	sll	a1,a1,0x10
9d001928:	3c03bf81 	lui	v1,0xbf81
9d00192c:	ac659040 	sw	a1,-28608(v1)
	AD1CON1	=	0; //Ends sampling, and starts converting
9d001930:	3c10bf81 	lui	s0,0xbf81

	//Set up for manual sampling
	AD1CSSL	=	0;
9d001934:	3c03bf81 	lui	v1,0xbf81
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
	AD1CON2	=	analog_reference;
9d001938:	8f858028 	lw	a1,-32728(gp)
	/* Ensure that the pin associated with the analog channel is in analog
	** input mode, and select the channel in the input mux.
	*/
	AD1PCFG = ~(1 << channelNumber);
	AD1CHS = (channelNumber & 0xFFFF) << 16;
	AD1CON1	=	0; //Ends sampling, and starts converting
9d00193c:	ae009000 	sw	zero,-28672(s0)

	//Set up for manual sampling
	AD1CSSL	=	0;
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
9d001940:	24110002 	li	s1,2
	AD1PCFG = ~(1 << channelNumber);
	AD1CHS = (channelNumber & 0xFFFF) << 16;
	AD1CON1	=	0; //Ends sampling, and starts converting

	//Set up for manual sampling
	AD1CSSL	=	0;
9d001944:	ac609050 	sw	zero,-28592(v1)
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
9d001948:	3c03bf81 	lui	v1,0xbf81
9d00194c:	ac719020 	sw	s1,-28640(v1)
	AD1CON2	=	analog_reference;
9d001950:	3c03bf81 	lui	v1,0xbf81

	//Turn on ADC
	AD1CON1SET	=	0x8000;
9d001954:	3c02bf81 	lui	v0,0xbf81
	AD1CON1	=	0; //Ends sampling, and starts converting

	//Set up for manual sampling
	AD1CSSL	=	0;
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
	AD1CON2	=	analog_reference;
9d001958:	ac659010 	sw	a1,-28656(v1)
	
	//Start sampling
	AD1CON1SET	=	0x0002;
	
	//Delay for a bit
	delayMicroseconds(2);
9d00195c:	24040002 	li	a0,2
	AD1CSSL	=	0;
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
	AD1CON2	=	analog_reference;

	//Turn on ADC
	AD1CON1SET	=	0x8000;
9d001960:	34038000 	li	v1,0x8000
9d001964:	ac439008 	sw	v1,-28664(v0)
	
	//Start sampling
	AD1CON1SET	=	0x0002;
9d001968:	ac519008 	sw	s1,-28664(v0)
	
	//Delay for a bit
	delayMicroseconds(2);
9d00196c:	0f40056f 	jal	9d0015bc <delayMicroseconds>
9d001970:	00000000 	nop

	//Start conversion
	AD1CON1CLR	=	0x0002;
9d001974:	3c02bf81 	lui	v0,0xbf81
9d001978:	ac519004 	sw	s1,-28668(v0)
	
	//Wait for conversion to finish
	while (!(AD1CON1 & 0x0001));
9d00197c:	8e029000 	lw	v0,-28672(s0)
9d001980:	30420001 	andi	v0,v0,0x1
9d001984:	1040fffd 	beqz	v0,9d00197c <analogRead+0xa8>
9d001988:	3c02bf81 	lui	v0,0xbf81
	

	//Read the ADC Value
	analogValue	=	ADC1BUF0;
9d00198c:	8c429070 	lw	v0,-28560(v0)
	
	return (analogValue);
}
9d001990:	8fbf001c 	lw	ra,28(sp)
9d001994:	8fb10018 	lw	s1,24(sp)
9d001998:	8fb00014 	lw	s0,20(sp)
9d00199c:	03e00008 	jr	ra
9d0019a0:	27bd0020 	addiu	sp,sp,32

	/* Pin number is allowed to be either the digital pin number or the
	** analog pin number. Map the input so that it is guaranteed to be
	** an analog pin number.
	*/
	pin = (pin < NUM_DIGITAL_PINS) ? digitalPinToAnalog(pin) : NOT_ANALOG_PIN;
9d0019a4:	308400ff 	andi	a0,a0,0xff
9d0019a8:	2c83000c 	sltiu	v1,a0,12
9d0019ac:	5460ffd5 	bnezl	v1,9d001904 <analogRead+0x30>
9d0019b0:	3c029d00 	lui	v0,0x9d00

	//Read the ADC Value
	analogValue	=	ADC1BUF0;
	
	return (analogValue);
}
9d0019b4:	8fbf001c 	lw	ra,28(sp)
9d0019b8:	8fb10018 	lw	s1,24(sp)
9d0019bc:	8fb00014 	lw	s0,20(sp)
9d0019c0:	03e00008 	jr	ra
9d0019c4:	27bd0020 	addiu	sp,sp,32

9d0019c8 <_ZN14HardwareSerial9availableEv>:
**		receive buffer.
*/

int HardwareSerial::available(void)
{
	return (RX_BUFFER_SIZE + rx_buffer.head - rx_buffer.tail) % RX_BUFFER_SIZE;
9d0019c8:	8c8200a0 	lw	v0,160(a0)
9d0019cc:	8c8300a4 	lw	v1,164(a0)
9d0019d0:	24420080 	addiu	v0,v0,128
9d0019d4:	00431023 	subu	v0,v0,v1
9d0019d8:	00021fc3 	sra	v1,v0,0x1f
9d0019dc:	00031e42 	srl	v1,v1,0x19
9d0019e0:	00431021 	addu	v0,v0,v1
9d0019e4:	3042007f 	andi	v0,v0,0x7f
}
9d0019e8:	03e00008 	jr	ra
9d0019ec:	00431023 	subu	v0,v0,v1

9d0019f0 <_ZN14HardwareSerial4peekEv>:
**		removing it from the buffer, or -1 if no characters are in the buffer.
*/

int HardwareSerial::peek()
{
	if (rx_buffer.head == rx_buffer.tail)
9d0019f0:	8c8300a4 	lw	v1,164(a0)
9d0019f4:	8c8500a0 	lw	a1,160(a0)
9d0019f8:	10a30003 	beq	a1,v1,9d001a08 <_ZN14HardwareSerial4peekEv+0x18>
9d0019fc:	2402ffff 	li	v0,-1
	{
		return -1;
	}
	else
	{
		return rx_buffer.buffer[rx_buffer.tail];
9d001a00:	00832021 	addu	a0,a0,v1
9d001a04:	90820020 	lbu	v0,32(a0)
	}
}
9d001a08:	03e00008 	jr	ra
9d001a0c:	00000000 	nop

9d001a10 <_ZN14HardwareSerial4readEv>:
int HardwareSerial::read(void)
{
	unsigned char theChar;

	// if the head isn't ahead of the tail, we don't have any characters
	if (rx_buffer.head == rx_buffer.tail)
9d001a10:	8c8300a4 	lw	v1,164(a0)
9d001a14:	8c8500a0 	lw	a1,160(a0)
9d001a18:	10a3000a 	beq	a1,v1,9d001a44 <_ZN14HardwareSerial4readEv+0x34>
9d001a1c:	2402ffff 	li	v0,-1
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d001a20:	24660001 	addiu	a2,v1,1
9d001a24:	00062fc3 	sra	a1,a2,0x1f
9d001a28:	00052e42 	srl	a1,a1,0x19
9d001a2c:	00c53021 	addu	a2,a2,a1
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d001a30:	00831821 	addu	v1,a0,v1
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d001a34:	30c6007f 	andi	a2,a2,0x7f
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d001a38:	90620020 	lbu	v0,32(v1)
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d001a3c:	00c52823 	subu	a1,a2,a1
9d001a40:	ac8500a4 	sw	a1,164(a0)
		return (theChar);
	}
}
9d001a44:	03e00008 	jr	ra
9d001a48:	00000000 	nop

9d001a4c <_ZN14HardwareSerial5flushEv>:
	// don't reverse this or there may be problems if the RX interrupt
	// occurs after reading the value of rx_buffer_head but before writing
	// the value to rx_buffer_tail; the previous value of rx_buffer_head
	// may be written to rx_buffer_tail, making it appear as if the buffer
	// were full, not empty.
	rx_buffer.head = rx_buffer.tail;
9d001a4c:	8c8200a4 	lw	v0,164(a0)
}
9d001a50:	03e00008 	jr	ra
9d001a54:	ac8200a0 	sw	v0,160(a0)

9d001a58 <_ZN14HardwareSerial5writeEh>:
**		Wait until the transmitter is idle, and then transmit the
**		specified character.
*/

void HardwareSerial::write(uint8_t theChar)
{
9d001a58:	8c820004 	lw	v0,4(a0)
9d001a5c:	30a500ff 	andi	a1,a1,0xff

	while ((uart->uxSta.reg & (1 << _UARTSTA_TMRT)) == 0)	//check the TRMT bit
9d001a60:	8c430010 	lw	v1,16(v0)
9d001a64:	30630100 	andi	v1,v1,0x100
9d001a68:	1060fffd 	beqz	v1,9d001a60 <_ZN14HardwareSerial5writeEh+0x8>
9d001a6c:	00000000 	nop
		{
		//* wait for the transmitter to be clear
		}


	uart->uxTx.reg = theChar;
9d001a70:	ac450020 	sw	a1,32(v0)
}
9d001a74:	03e00008 	jr	ra
9d001a78:	00000000 	nop

9d001a7c <_ZN14HardwareSerial5beginEm>:
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	flush();
9d001a7c:	8c820000 	lw	v0,0(a0)
**		Initialize the UART for use, setting the baud rate to the
**		requested value, data size of 8-bits, and no parity.
*/

void HardwareSerial::begin(unsigned long baudRate)
{
9d001a80:	27bdffe0 	addiu	sp,sp,-32
9d001a84:	afbf001c 	sw	ra,28(sp)
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	flush();
9d001a88:	8c420018 	lw	v0,24(v0)
**		Initialize the UART for use, setting the baud rate to the
**		requested value, data size of 8-bits, and no parity.
*/

void HardwareSerial::begin(unsigned long baudRate)
{
9d001a8c:	afb00018 	sw	s0,24(sp)
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	flush();
9d001a90:	afa50010 	sw	a1,16(sp)
9d001a94:	0040f809 	jalr	v0
9d001a98:	00808021 	move	s0,a0
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001a9c:	8f82817c 	lw	v0,-32388(gp)
9d001aa0:	8fa50010 	lw	a1,16(sp)
	flush();

	/* Compute the address of the interrupt priority control
	** registers used by this UART
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);	//interrupt priority control reg set
9d001aa4:	92080009 	lbu	t0,9(s0)
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001aa8:	00021102 	srl	v0,v0,0x4
9d001aac:	0045001b 	divu	zero,v0,a1
9d001ab0:	00a001f4 	teq	a1,zero,0x7
	flush();

	/* Compute the address of the interrupt priority control
	** registers used by this UART
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);	//interrupt priority control reg set
9d001ab4:	3c07bf88 	lui	a3,0xbf88
9d001ab8:	00081882 	srl	v1,t0,0x2
9d001abc:	00031900 	sll	v1,v1,0x4

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this IRQ.
	*/
	irq_shift = 8 * (vec % 4);
9d001ac0:	31080003 	andi	t0,t0,0x3
	flush();

	/* Compute the address of the interrupt priority control
	** registers used by this UART
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);	//interrupt priority control reg set
9d001ac4:	24e71090 	addiu	a3,a3,4240
9d001ac8:	00e33821 	addu	a3,a3,v1

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this IRQ.
	*/
	irq_shift = 8 * (vec % 4);
9d001acc:	000840c0 	sll	t0,t0,0x3

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
9d001ad0:	2403001f 	li	v1,31
9d001ad4:	01031804 	sllv	v1,v1,t0
9d001ad8:	ace30004 	sw	v1,4(a3)
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001adc:	920a000a 	lbu	t2,10(s0)
9d001ae0:	920c000b 	lbu	t4,11(s0)

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001ae4:	8e040018 	lw	a0,24(s0)
9d001ae8:	8e06001c 	lw	a2,28(s0)
9d001aec:	8e0b0014 	lw	t3,20(s0)

	iec->clr = bit_rx + bit_tx + bit_err;	//disable all interrupts
9d001af0:	8e030010 	lw	v1,16(s0)
	ipc->set = ((ipl << 2) + spl) << irq_shift;

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001af4:	8e09000c 	lw	t1,12(s0)
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001af8:	000a5080 	sll	t2,t2,0x2
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001afc:	8e020004 	lw	v0,4(s0)
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001b00:	014c5021 	addu	t2,t2,t4

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001b04:	00863021 	addu	a2,a0,a2
9d001b08:	00cb3021 	addu	a2,a2,t3
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001b0c:	010a4004 	sllv	t0,t2,t0
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
	uart->uxSta.reg = 0;
	uart->uxMode.reg = (1 << _UARTMODE_ON);			//enable UART module
	uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);	//enable transmitter and receiver

}
9d001b10:	8fbf001c 	lw	ra,28(sp)
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001b14:	ace80008 	sw	t0,8(a3)

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001b18:	ad260004 	sw	a2,4(t1)

	iec->clr = bit_rx + bit_tx + bit_err;	//disable all interrupts
9d001b1c:	ac660004 	sw	a2,4(v1)
	iec->set = bit_rx;						//enable rx interrupts
9d001b20:	ac640008 	sw	a0,8(v1)
	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
	uart->uxSta.reg = 0;
	uart->uxMode.reg = (1 << _UARTMODE_ON);			//enable UART module
9d001b24:	34038000 	li	v1,0x8000
	uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);	//enable transmitter and receiver

}
9d001b28:	8fb00018 	lw	s0,24(sp)
9d001b2c:	27bd0020 	addiu	sp,sp,32
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001b30:	00002812 	mflo	a1
9d001b34:	24a5ffff 	addiu	a1,a1,-1
9d001b38:	ac450040 	sw	a1,64(v0)
	uart->uxSta.reg = 0;
9d001b3c:	ac400010 	sw	zero,16(v0)
	uart->uxMode.reg = (1 << _UARTMODE_ON);			//enable UART module
9d001b40:	ac430000 	sw	v1,0(v0)
	uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);	//enable transmitter and receiver
9d001b44:	24031400 	li	v1,5120
9d001b48:	ac430010 	sw	v1,16(v0)

}
9d001b4c:	03e00008 	jr	ra
9d001b50:	00000000 	nop

9d001b54 <_ZN14HardwareSerial11doSerialIntEv>:
	uint8_t	ch;

	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
9d001b54:	8c82000c 	lw	v0,12(a0)
9d001b58:	8c830018 	lw	v1,24(a0)
9d001b5c:	8c450000 	lw	a1,0(v0)
9d001b60:	00652824 	and	a1,v1,a1
9d001b64:	10a00010 	beqz	a1,9d001ba8 <_ZN14HardwareSerial11doSerialIntEv+0x54>
9d001b68:	00000000 	nop
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d001b6c:	8c8700a0 	lw	a3,160(a0)
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d001b70:	8c890004 	lw	t1,4(a0)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d001b74:	8c8800a4 	lw	t0,164(a0)
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d001b78:	24e60001 	addiu	a2,a3,1
9d001b7c:	00062fc3 	sra	a1,a2,0x1f
9d001b80:	00052e42 	srl	a1,a1,0x19
9d001b84:	00c53021 	addu	a2,a2,a1
9d001b88:	30c6007f 	andi	a2,a2,0x7f
9d001b8c:	00c52823 	subu	a1,a2,a1
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d001b90:	8d260030 	lw	a2,48(t1)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d001b94:	11050003 	beq	t0,a1,9d001ba4 <_ZN14HardwareSerial11doSerialIntEv+0x50>
9d001b98:	00873821 	addu	a3,a0,a3
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d001b9c:	a0e60020 	sb	a2,32(a3)
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
		{
			rx_buffer.buffer[rx_buffer.head] = ch;
			rx_buffer.head = bufIndex;
9d001ba0:	ac8500a0 	sw	a1,160(a0)
		}

		/* Clear the interrupt flag.
		*/
		ifs->clr = bit_rx;
9d001ba4:	ac430004 	sw	v1,4(v0)
	}

	/* If it's a transmit interrupt, ignore it, as we don't current
	** have interrupt driven i/o on the transmit side.
	*/
	if ((ifs->reg & bit_tx) != 0)
9d001ba8:	8c450000 	lw	a1,0(v0)
9d001bac:	8c83001c 	lw	v1,28(a0)
9d001bb0:	00652024 	and	a0,v1,a1
9d001bb4:	54800001 	bnezl	a0,9d001bbc <_ZN14HardwareSerial11doSerialIntEv+0x68>
9d001bb8:	ac430004 	sw	v1,4(v0)
9d001bbc:	03e00008 	jr	ra
9d001bc0:	00000000 	nop

9d001bc4 <IntSer0Handler>:
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __ISR(_SER0_VECTOR, _SER0_IPL_ISR) IntSer0Handler(void)
{
9d001bc4:	415de800 	rdpgpr	sp,sp
9d001bc8:	401a7000 	mfc0	k0,c0_epc
9d001bcc:	401b6000 	mfc0	k1,c0_status
9d001bd0:	27bdff98 	addiu	sp,sp,-104
9d001bd4:	afbb0060 	sw	k1,96(sp)
9d001bd8:	7c1b7844 	ins	k1,zero,0x1,0xf
9d001bdc:	377b0800 	ori	k1,k1,0x800
9d001be0:	afba0064 	sw	k0,100(sp)
9d001be4:	409b6000 	mtc0	k1,c0_status
9d001be8:	afbf0054 	sw	ra,84(sp)
9d001bec:	afb90050 	sw	t9,80(sp)
9d001bf0:	afb8004c 	sw	t8,76(sp)
9d001bf4:	afaf0048 	sw	t7,72(sp)
9d001bf8:	afae0044 	sw	t6,68(sp)
9d001bfc:	afad0040 	sw	t5,64(sp)
9d001c00:	afac003c 	sw	t4,60(sp)
9d001c04:	afab0038 	sw	t3,56(sp)
9d001c08:	afaa0034 	sw	t2,52(sp)
9d001c0c:	afa90030 	sw	t1,48(sp)
9d001c10:	afa8002c 	sw	t0,44(sp)
9d001c14:	afa70028 	sw	a3,40(sp)
9d001c18:	afa60024 	sw	a2,36(sp)
9d001c1c:	afa50020 	sw	a1,32(sp)
9d001c20:	afa4001c 	sw	a0,28(sp)
9d001c24:	afa30018 	sw	v1,24(sp)
9d001c28:	afa20014 	sw	v0,20(sp)
9d001c2c:	afa10010 	sw	at,16(sp)
9d001c30:	00001012 	mflo	v0
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
#else
	Serial.doSerialInt();
9d001c34:	2784802c 	addiu	a0,gp,-32724
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __ISR(_SER0_VECTOR, _SER0_IPL_ISR) IntSer0Handler(void)
{
9d001c38:	afa2005c 	sw	v0,92(sp)
9d001c3c:	00001810 	mfhi	v1
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
#else
	Serial.doSerialInt();
9d001c40:	0f4006d5 	jal	9d001b54 <_ZN14HardwareSerial11doSerialIntEv>
9d001c44:	afa30058 	sw	v1,88(sp)
#endif
}
9d001c48:	8fa5005c 	lw	a1,92(sp)
9d001c4c:	8fbf0054 	lw	ra,84(sp)
9d001c50:	8fb90050 	lw	t9,80(sp)
9d001c54:	00a00013 	mtlo	a1
9d001c58:	8fa50058 	lw	a1,88(sp)
9d001c5c:	8fb8004c 	lw	t8,76(sp)
9d001c60:	8faf0048 	lw	t7,72(sp)
9d001c64:	00a00011 	mthi	a1
9d001c68:	8fae0044 	lw	t6,68(sp)
9d001c6c:	8fad0040 	lw	t5,64(sp)
9d001c70:	8fac003c 	lw	t4,60(sp)
9d001c74:	8fab0038 	lw	t3,56(sp)
9d001c78:	8faa0034 	lw	t2,52(sp)
9d001c7c:	8fa90030 	lw	t1,48(sp)
9d001c80:	8fa8002c 	lw	t0,44(sp)
9d001c84:	8fa70028 	lw	a3,40(sp)
9d001c88:	8fa60024 	lw	a2,36(sp)
9d001c8c:	8fa50020 	lw	a1,32(sp)
9d001c90:	8fa4001c 	lw	a0,28(sp)
9d001c94:	8fa30018 	lw	v1,24(sp)
9d001c98:	8fa20014 	lw	v0,20(sp)
9d001c9c:	8fa10010 	lw	at,16(sp)
9d001ca0:	41606000 	di
9d001ca4:	000000c0 	ehb
9d001ca8:	8fba0064 	lw	k0,100(sp)
9d001cac:	8fbb0060 	lw	k1,96(sp)
9d001cb0:	409a7000 	mtc0	k0,c0_epc
9d001cb4:	27bd0068 	addiu	sp,sp,104
9d001cb8:	41dde800 	wrpgpr	sp,sp
9d001cbc:	409b6000 	mtc0	k1,c0_status
9d001cc0:	42000018 	eret

9d001cc4 <IntSer1Handler>:
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __ISR(_SER1_VECTOR, _SER1_IPL_ISR) IntSer1Handler(void)
{
9d001cc4:	415de800 	rdpgpr	sp,sp
9d001cc8:	401a7000 	mfc0	k0,c0_epc
9d001ccc:	401b6000 	mfc0	k1,c0_status
9d001cd0:	27bdff98 	addiu	sp,sp,-104
9d001cd4:	afbb0060 	sw	k1,96(sp)
9d001cd8:	7c1b7844 	ins	k1,zero,0x1,0xf
9d001cdc:	377b0800 	ori	k1,k1,0x800
9d001ce0:	afba0064 	sw	k0,100(sp)
9d001ce4:	409b6000 	mtc0	k1,c0_status
9d001ce8:	afbf0054 	sw	ra,84(sp)
9d001cec:	afb90050 	sw	t9,80(sp)
9d001cf0:	afb8004c 	sw	t8,76(sp)
9d001cf4:	afaf0048 	sw	t7,72(sp)
9d001cf8:	afae0044 	sw	t6,68(sp)
9d001cfc:	afad0040 	sw	t5,64(sp)
9d001d00:	afac003c 	sw	t4,60(sp)
9d001d04:	afab0038 	sw	t3,56(sp)
9d001d08:	afaa0034 	sw	t2,52(sp)
9d001d0c:	afa90030 	sw	t1,48(sp)
9d001d10:	afa8002c 	sw	t0,44(sp)
9d001d14:	afa70028 	sw	a3,40(sp)
9d001d18:	afa60024 	sw	a2,36(sp)
9d001d1c:	afa50020 	sw	a1,32(sp)
9d001d20:	afa4001c 	sw	a0,28(sp)
9d001d24:	afa30018 	sw	v1,24(sp)
9d001d28:	afa20014 	sw	v0,20(sp)
9d001d2c:	afa10010 	sw	at,16(sp)
9d001d30:	00001012 	mflo	v0
	Serial1.doSerialInt();
9d001d34:	278480d4 	addiu	a0,gp,-32556
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __ISR(_SER1_VECTOR, _SER1_IPL_ISR) IntSer1Handler(void)
{
9d001d38:	afa2005c 	sw	v0,92(sp)
9d001d3c:	00001810 	mfhi	v1
	Serial1.doSerialInt();
9d001d40:	0f4006d5 	jal	9d001b54 <_ZN14HardwareSerial11doSerialIntEv>
9d001d44:	afa30058 	sw	v1,88(sp)
}
9d001d48:	8fa5005c 	lw	a1,92(sp)
9d001d4c:	8fbf0054 	lw	ra,84(sp)
9d001d50:	8fb90050 	lw	t9,80(sp)
9d001d54:	00a00013 	mtlo	a1
9d001d58:	8fa50058 	lw	a1,88(sp)
9d001d5c:	8fb8004c 	lw	t8,76(sp)
9d001d60:	8faf0048 	lw	t7,72(sp)
9d001d64:	00a00011 	mthi	a1
9d001d68:	8fae0044 	lw	t6,68(sp)
9d001d6c:	8fad0040 	lw	t5,64(sp)
9d001d70:	8fac003c 	lw	t4,60(sp)
9d001d74:	8fab0038 	lw	t3,56(sp)
9d001d78:	8faa0034 	lw	t2,52(sp)
9d001d7c:	8fa90030 	lw	t1,48(sp)
9d001d80:	8fa8002c 	lw	t0,44(sp)
9d001d84:	8fa70028 	lw	a3,40(sp)
9d001d88:	8fa60024 	lw	a2,36(sp)
9d001d8c:	8fa50020 	lw	a1,32(sp)
9d001d90:	8fa4001c 	lw	a0,28(sp)
9d001d94:	8fa30018 	lw	v1,24(sp)
9d001d98:	8fa20014 	lw	v0,20(sp)
9d001d9c:	8fa10010 	lw	at,16(sp)
9d001da0:	41606000 	di
9d001da4:	000000c0 	ehb
9d001da8:	8fba0064 	lw	k0,100(sp)
9d001dac:	8fbb0060 	lw	k1,96(sp)
9d001db0:	409a7000 	mtc0	k0,c0_epc
9d001db4:	27bd0068 	addiu	sp,sp,104
9d001db8:	41dde800 	wrpgpr	sp,sp
9d001dbc:	409b6000 	mtc0	k1,c0_status
9d001dc0:	42000018 	eret

9d001dc4 <_GLOBAL__I__ZN14HardwareSerialC2EP8p32_uartiiii>:
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d001dc4:	3c04bf88 	lui	a0,0xbf88
9d001dc8:	24841060 	addiu	a0,a0,4192
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
9d001dcc:	24020002 	li	v0,2
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
9d001dd0:	3c06bf80 	lui	a2,0xbf80
**	Description:
**		Object constructor. Initialize member variables, and
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
9d001dd4:	3c039d00 	lui	v1,0x9d00
9d001dd8:	246328b0 	addiu	v1,v1,10416
{
	uart = uartP;
9d001ddc:	24c96000 	addiu	t1,a2,24576
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d001de0:	24870010 	addiu	a3,a0,16
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001de4:	3c05bf88 	lui	a1,0xbf88
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
9d001de8:	a3828036 	sb	v0,-32714(gp)
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d001dec:	af84803c 	sw	a0,-32708(gp)
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
9d001df0:	a38280de 	sb	v0,-32546(gp)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d001df4:	3c040400 	lui	a0,0x400
9d001df8:	24020100 	li	v0,256
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001dfc:	24a51030 	addiu	a1,a1,4144
**	Description:
**		Object constructor. Initialize member variables, and
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
9d001e00:	af83802c 	sw	v1,-32724(gp)
{
	uart = uartP;
9d001e04:	af898030 	sw	t1,-32720(gp)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d001e08:	af848040 	sw	a0,-32704(gp)
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d001e0c:	2409001a 	li	t1,26
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d001e10:	3c040800 	lui	a0,0x800
**	Description:
**		Object constructor. Initialize member variables, and
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
9d001e14:	af8380d4 	sw	v1,-32556(gp)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d001e18:	af8280e8 	sw	v0,-32536(gp)
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d001e1c:	24030028 	li	v1,40
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d001e20:	24020200 	li	v0,512
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
9d001e24:	24c66200 	addiu	a2,a2,25088
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001e28:	24a80010 	addiu	t0,a1,16
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d001e2c:	a3898034 	sb	t1,-32716(gp)
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d001e30:	af848044 	sw	a0,-32700(gp)

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
9d001e34:	24090018 	li	t1,24
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d001e38:	3c041000 	lui	a0,0x1000
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d001e3c:	a38380dc 	sb	v1,-32548(gp)
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d001e40:	af8280ec 	sw	v0,-32532(gp)

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
9d001e44:	24030020 	li	v1,32
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d001e48:	24020400 	li	v0,1024

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
9d001e4c:	a3898035 	sb	t1,-32715(gp)
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
	spl  = (uint8_t)splP;
9d001e50:	a3808037 	sb	zero,-32713(gp)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001e54:	af858038 	sw	a1,-32712(gp)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d001e58:	af848048 	sw	a0,-32696(gp)
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
9d001e5c:	af8680d8 	sw	a2,-32552(gp)
	irq  = irqP;
	vec  = vecP;
9d001e60:	a38380dd 	sb	v1,-32547(gp)
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
	spl  = (uint8_t)splP;
9d001e64:	a38080df 	sb	zero,-32545(gp)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001e68:	af8880e0 	sw	t0,-32544(gp)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d001e6c:	af8780e4 	sw	a3,-32540(gp)
#endif

#endif	//defined(_USB) && defined(_USE_USB_FOR_SERIAL_)

#if defined(_SER1_BASE)
HardwareSerial Serial1((p32_uart *)_SER1_BASE, _SER1_IRQ, _SER1_VECTOR, _SER1_IPL, _SER1_SPL);
9d001e70:	03e00008 	jr	ra
9d001e74:	af8280f0 	sw	v0,-32528(gp)

9d001e78 <_ZN5Print5writeEPKc>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
9d001e78:	27bdffe0 	addiu	sp,sp,-32
9d001e7c:	afb10018 	sw	s1,24(sp)
9d001e80:	afb00014 	sw	s0,20(sp)
9d001e84:	afbf001c 	sw	ra,28(sp)
9d001e88:	00a08021 	move	s0,a1
	while (*str)
9d001e8c:	80a50000 	lb	a1,0(a1)
9d001e90:	10a0000a 	beqz	a1,9d001ebc <_ZN5Print5writeEPKc+0x44>
9d001e94:	00808821 	move	s1,a0
	{
		write(*str++);
9d001e98:	8e220000 	lw	v0,0(s1)
9d001e9c:	30a500ff 	andi	a1,a1,0xff
9d001ea0:	26100001 	addiu	s0,s0,1
9d001ea4:	8c420000 	lw	v0,0(v0)
9d001ea8:	0040f809 	jalr	v0
9d001eac:	02202021 	move	a0,s1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
	while (*str)
9d001eb0:	82050000 	lb	a1,0(s0)
9d001eb4:	54a0fff9 	bnezl	a1,9d001e9c <_ZN5Print5writeEPKc+0x24>
9d001eb8:	8e220000 	lw	v0,0(s1)
	{
		write(*str++);
	}
}
9d001ebc:	8fbf001c 	lw	ra,28(sp)
9d001ec0:	8fb10018 	lw	s1,24(sp)
9d001ec4:	8fb00014 	lw	s0,20(sp)
9d001ec8:	03e00008 	jr	ra
9d001ecc:	27bd0020 	addiu	sp,sp,32

9d001ed0 <_ZN5Print5writeEPKhm>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
9d001ed0:	27bdffe0 	addiu	sp,sp,-32
9d001ed4:	afb20018 	sw	s2,24(sp)
9d001ed8:	afb10014 	sw	s1,20(sp)
9d001edc:	afb00010 	sw	s0,16(sp)
9d001ee0:	afbf001c 	sw	ra,28(sp)
9d001ee4:	00c08021 	move	s0,a2
9d001ee8:	00809021 	move	s2,a0
	while (size--)
9d001eec:	10c0000a 	beqz	a2,9d001f18 <_ZN5Print5writeEPKhm+0x48>
9d001ef0:	00a08821 	move	s1,a1
	{
		write(*buffer++);
9d001ef4:	8e420000 	lw	v0,0(s2)
9d001ef8:	92250000 	lbu	a1,0(s1)
9d001efc:	2610ffff 	addiu	s0,s0,-1
9d001f00:	8c420000 	lw	v0,0(v0)
9d001f04:	02402021 	move	a0,s2
9d001f08:	0040f809 	jalr	v0
9d001f0c:	26310001 	addiu	s1,s1,1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
	while (size--)
9d001f10:	5600fff9 	bnezl	s0,9d001ef8 <_ZN5Print5writeEPKhm+0x28>
9d001f14:	8e420000 	lw	v0,0(s2)
	{
		write(*buffer++);
	}
}
9d001f18:	8fbf001c 	lw	ra,28(sp)
9d001f1c:	8fb20018 	lw	s2,24(sp)
9d001f20:	8fb10014 	lw	s1,20(sp)
9d001f24:	8fb00010 	lw	s0,16(sp)
9d001f28:	03e00008 	jr	ra
9d001f2c:	27bd0020 	addiu	sp,sp,32

9d001f30 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
{
9d001f30:	27bdffc0 	addiu	sp,sp,-64
9d001f34:	afb10038 	sw	s1,56(sp)
9d001f38:	afb00034 	sw	s0,52(sp)
9d001f3c:	afbf003c 	sw	ra,60(sp)
9d001f40:	00808021 	move	s0,a0
9d001f44:	30c600ff 	andi	a2,a2,0xff
unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars.
unsigned long i = 0;

	if (n == 0)
9d001f48:	10a00020 	beqz	a1,9d001fcc <_ZN5Print11printNumberEmh+0x9c>
9d001f4c:	00008821 	move	s1,zero
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d001f50:	00a6001b 	divu	zero,a1,a2
9d001f54:	00c001f4 	teq	a2,zero,0x7
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d001f58:	27a40010 	addiu	a0,sp,16
9d001f5c:	00911021 	addu	v0,a0,s1
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d001f60:	26310001 	addiu	s1,s1,1
9d001f64:	00001810 	mfhi	v1
9d001f68:	00002812 	mflo	a1
	{
		print('0');
		return;
	}

	while (n > 0)
9d001f6c:	14a0fff8 	bnez	a1,9d001f50 <_ZN5Print11printNumberEmh+0x20>
9d001f70:	a0430000 	sb	v1,0(v0)
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d001f74:	12200011 	beqz	s1,9d001fbc <_ZN5Print11printNumberEmh+0x8c>
9d001f78:	8fbf003c 	lw	ra,60(sp)
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d001f7c:	27a30010 	addiu	v1,sp,16
9d001f80:	00711021 	addu	v0,v1,s1
		n /= base;
	}

	for (; i > 0; i--)
	{
		print((char) (buf[i - 1] < 10 ?
9d001f84:	9042ffff 	lbu	v0,-1(v0)
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
9d001f88:	24450030 	addiu	a1,v0,48
9d001f8c:	2c43000a 	sltiu	v1,v0,10
9d001f90:	7c052c20 	seb	a1,a1
9d001f94:	14600002 	bnez	v1,9d001fa0 <_ZN5Print11printNumberEmh+0x70>
9d001f98:	24420037 	addiu	v0,v0,55
9d001f9c:	7c022c20 	seb	a1,v0
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d001fa0:	2631ffff 	addiu	s1,s1,-1
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d001fa4:	02002021 	move	a0,s0
9d001fa8:	0f4007fa 	jal	9d001fe8 <_ZN5Print5printEli>
9d001fac:	00003021 	move	a2,zero
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d001fb0:	1620fff3 	bnez	s1,9d001f80 <_ZN5Print11printNumberEmh+0x50>
9d001fb4:	27a30010 	addiu	v1,sp,16
	{
		print((char) (buf[i - 1] < 10 ?
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
	}
}
9d001fb8:	8fbf003c 	lw	ra,60(sp)
9d001fbc:	8fb10038 	lw	s1,56(sp)
9d001fc0:	8fb00034 	lw	s0,52(sp)
9d001fc4:	03e00008 	jr	ra
9d001fc8:	27bd0040 	addiu	sp,sp,64
9d001fcc:	8fbf003c 	lw	ra,60(sp)
9d001fd0:	8fb10038 	lw	s1,56(sp)
9d001fd4:	8fb00034 	lw	s0,52(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d001fd8:	24050030 	li	a1,48
9d001fdc:	00003021 	move	a2,zero
9d001fe0:	0b4007fa 	j	9d001fe8 <_ZN5Print5printEli>
9d001fe4:	27bd0040 	addiu	sp,sp,64

9d001fe8 <_ZN5Print5printEli>:
	print((unsigned long) n, base);
}

//************************************************************************
void Print::print(long n, int base)
{
9d001fe8:	27bdffe0 	addiu	sp,sp,-32
9d001fec:	afb10018 	sw	s1,24(sp)
9d001ff0:	afb00014 	sw	s0,20(sp)
9d001ff4:	afbf001c 	sw	ra,28(sp)
9d001ff8:	00808821 	move	s1,a0
	if (base == 0)
9d001ffc:	10c00013 	beqz	a2,9d00204c <_ZN5Print5printEli+0x64>
9d002000:	00a08021 	move	s0,a1
	{
		write(n);
	}
	else if (base == 10)
9d002004:	2402000a 	li	v0,10
9d002008:	10c20006 	beq	a2,v0,9d002024 <_ZN5Print5printEli+0x3c>
9d00200c:	8fbf001c 	lw	ra,28(sp)
	}
	else
	{
		printNumber(n, base);
	}
}
9d002010:	8fb10018 	lw	s1,24(sp)
9d002014:	8fb00014 	lw	s0,20(sp)
		}
		printNumber(n, 10);
	}
	else
	{
		printNumber(n, base);
9d002018:	30c600ff 	andi	a2,a2,0xff
9d00201c:	0b4007cc 	j	9d001f30 <_ZN5Print11printNumberEmh>
9d002020:	27bd0020 	addiu	sp,sp,32
	{
		write(n);
	}
	else if (base == 10)
	{
		if (n < 0)
9d002024:	04a00011 	bltz	a1,9d00206c <_ZN5Print5printEli+0x84>
9d002028:	2405002d 	li	a1,45
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d00202c:	02202021 	move	a0,s1
9d002030:	02002821 	move	a1,s0
	}
	else
	{
		printNumber(n, base);
	}
}
9d002034:	8fbf001c 	lw	ra,28(sp)
9d002038:	8fb10018 	lw	s1,24(sp)
9d00203c:	8fb00014 	lw	s0,20(sp)
		if (n < 0)
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d002040:	2406000a 	li	a2,10
	}
	else
	{
		printNumber(n, base);
9d002044:	0b4007cc 	j	9d001f30 <_ZN5Print11printNumberEmh>
9d002048:	27bd0020 	addiu	sp,sp,32
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d00204c:	8c820000 	lw	v0,0(a0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d002050:	8fbf001c 	lw	ra,28(sp)
9d002054:	8fb10018 	lw	s1,24(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d002058:	8c590000 	lw	t9,0(v0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d00205c:	8fb00014 	lw	s0,20(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d002060:	30a500ff 	andi	a1,a1,0xff
9d002064:	03200008 	jr	t9
9d002068:	27bd0020 	addiu	sp,sp,32
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00206c:	0f4007fa 	jal	9d001fe8 <_ZN5Print5printEli>
9d002070:	00003021 	move	a2,zero
	else if (base == 10)
	{
		if (n < 0)
		{
			print('-');
			n = -n;
9d002074:	0b40080b 	j	9d00202c <_ZN5Print5printEli+0x44>
9d002078:	00108023 	negu	s0,s0

9d00207c <_ZN5Print7printlnEv>:
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d00207c:	27bdffe8 	addiu	sp,sp,-24
9d002080:	afb00010 	sw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002084:	2405000d 	li	a1,13
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d002088:	00808021 	move	s0,a0
9d00208c:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002090:	0f4007fa 	jal	9d001fe8 <_ZN5Print5printEli>
9d002094:	00003021 	move	a2,zero
9d002098:	02002021 	move	a0,s0
//************************************************************************
void Print::println(void)
{
	print('\r');
	print('\n');
}
9d00209c:	8fbf0014 	lw	ra,20(sp)
9d0020a0:	8fb00010 	lw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d0020a4:	2405000a 	li	a1,10
9d0020a8:	00003021 	move	a2,zero
9d0020ac:	0b4007fa 	j	9d001fe8 <_ZN5Print5printEli>
9d0020b0:	27bd0018 	addiu	sp,sp,24

9d0020b4 <_ZN5Print7printlnEii>:
	println();
}

//************************************************************************
void Print::println(int n, int base)
{
9d0020b4:	27bdffe8 	addiu	sp,sp,-24
9d0020b8:	afb00010 	sw	s0,16(sp)
9d0020bc:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(int n, int base)
{
	print((long) n, base);
9d0020c0:	0f4007fa 	jal	9d001fe8 <_ZN5Print5printEli>
9d0020c4:	00808021 	move	s0,a0

//************************************************************************
void Print::println(int n, int base)
{
	print(n, base);
	println();
9d0020c8:	02002021 	move	a0,s0
}
9d0020cc:	8fbf0014 	lw	ra,20(sp)
9d0020d0:	8fb00010 	lw	s0,16(sp)

//************************************************************************
void Print::println(int n, int base)
{
	print(n, base);
	println();
9d0020d4:	0b40081f 	j	9d00207c <_ZN5Print7printlnEv>
9d0020d8:	27bd0018 	addiu	sp,sp,24

9d0020dc <_general_exception_context>:
9d0020dc:	27bdffa8 	addiu	sp,sp,-88
9d0020e0:	afa10004 	sw	at,4(sp)
9d0020e4:	afa20008 	sw	v0,8(sp)
9d0020e8:	afa3000c 	sw	v1,12(sp)
9d0020ec:	afa40010 	sw	a0,16(sp)
9d0020f0:	afa50014 	sw	a1,20(sp)
9d0020f4:	afa60018 	sw	a2,24(sp)
9d0020f8:	afa7001c 	sw	a3,28(sp)
9d0020fc:	afa80020 	sw	t0,32(sp)
9d002100:	afa90024 	sw	t1,36(sp)
9d002104:	afaa0028 	sw	t2,40(sp)
9d002108:	afab002c 	sw	t3,44(sp)
9d00210c:	afac0030 	sw	t4,48(sp)
9d002110:	afad0034 	sw	t5,52(sp)
9d002114:	afae0038 	sw	t6,56(sp)
9d002118:	afaf003c 	sw	t7,60(sp)
9d00211c:	afb80040 	sw	t8,64(sp)
9d002120:	afb90044 	sw	t9,68(sp)
9d002124:	afbf0048 	sw	ra,72(sp)
9d002128:	00004012 	mflo	t0
9d00212c:	afa8004c 	sw	t0,76(sp)
9d002130:	00004010 	mfhi	t0
9d002134:	afa80050 	sw	t0,80(sp)
9d002138:	40046800 	mfc0	a0,c0_cause
9d00213c:	40056000 	mfc0	a1,c0_status
9d002140:	0f40086b 	jal	9d0021ac <_general_exception_handler>
9d002144:	00000000 	nop
9d002148:	8fa80050 	lw	t0,80(sp)
9d00214c:	01000011 	mthi	t0
9d002150:	8fa8004c 	lw	t0,76(sp)
9d002154:	01000013 	mtlo	t0
9d002158:	8fa10004 	lw	at,4(sp)
9d00215c:	8fa20008 	lw	v0,8(sp)
9d002160:	8fa3000c 	lw	v1,12(sp)
9d002164:	8fa40010 	lw	a0,16(sp)
9d002168:	8fa50014 	lw	a1,20(sp)
9d00216c:	8fa60018 	lw	a2,24(sp)
9d002170:	8fa7001c 	lw	a3,28(sp)
9d002174:	8fa80020 	lw	t0,32(sp)
9d002178:	8fa90024 	lw	t1,36(sp)
9d00217c:	8faa0028 	lw	t2,40(sp)
9d002180:	8fab002c 	lw	t3,44(sp)
9d002184:	8fac0030 	lw	t4,48(sp)
9d002188:	8fad0034 	lw	t5,52(sp)
9d00218c:	8fae0038 	lw	t6,56(sp)
9d002190:	8faf003c 	lw	t7,60(sp)
9d002194:	8fb80040 	lw	t8,64(sp)
9d002198:	8fb90044 	lw	t9,68(sp)
9d00219c:	8fbf0048 	lw	ra,72(sp)
9d0021a0:	27bd0058 	addiu	sp,sp,88
9d0021a4:	000000c0 	ehb
9d0021a8:	42000018 	eret

9d0021ac <_general_exception_handler>:
9d0021ac:	0b40086b 	j	9d0021ac <_general_exception_handler>
9d0021b0:	00000000 	nop

9d0021b4 <_on_reset>:
9d0021b4:	03e00008 	jr	ra
9d0021b8:	00000000 	nop

9d0021bc <_on_bootstrap>:
9d0021bc:	03e00008 	jr	ra
9d0021c0:	00000000 	nop

9d0021c4 <_nmi_handler>:
9d0021c4:	401a6000 	mfc0	k0,c0_status
9d0021c8:	3c1bffbf 	lui	k1,0xffbf
9d0021cc:	377bffff 	ori	k1,k1,0xffff
9d0021d0:	035bd024 	and	k0,k0,k1
9d0021d4:	409a6000 	mtc0	k0,c0_status
9d0021d8:	42000018 	eret

9d0021dc <OpenCoreTimer>:
9d0021dc:	40804800 	mtc0	zero,c0_count
9d0021e0:	03e00008 	jr	ra
9d0021e4:	40845800 	mtc0	a0,c0_compare

9d0021e8 <ReadCoreTimer>:
9d0021e8:	03e00008 	jr	ra
9d0021ec:	40024800 	mfc0	v0,c0_count

9d0021f0 <CheKseg0CacheOn>:
9d0021f0:	2402fff8 	li	v0,-8
9d0021f4:	40038000 	mfc0	v1,c0_config
9d0021f8:	00621024 	and	v0,v1,v0
9d0021fc:	34420003 	ori	v0,v0,0x3
9d002200:	03e00008 	jr	ra
9d002204:	40828000 	mtc0	v0,c0_config

9d002208 <INTRestoreInterrupts>:
9d002208:	30840001 	andi	a0,a0,0x1
9d00220c:	14800003 	bnez	a0,9d00221c <INTRestoreInterrupts+0x14>
9d002210:	00000000 	nop
9d002214:	03e00008 	jr	ra
9d002218:	41606000 	di
9d00221c:	03e00008 	jr	ra
9d002220:	41606020 	ei

9d002224 <INTEnableSystemMultiVectoredInt>:
9d002224:	27bdffe8 	addiu	sp,sp,-24
9d002228:	afbf0014 	sw	ra,20(sp)
9d00222c:	40036800 	mfc0	v1,c0_cause
9d002230:	3c020080 	lui	v0,0x80
9d002234:	00621025 	or	v0,v1,v0
9d002238:	40826800 	mtc0	v0,c0_cause
9d00223c:	24031000 	li	v1,4096
9d002240:	3c02bf88 	lui	v0,0xbf88
9d002244:	0f400631 	jal	9d0018c4 <INTEnableInterrupts>
9d002248:	ac431008 	sw	v1,4104(v0)
9d00224c:	8fbf0014 	lw	ra,20(sp)
9d002250:	03e00008 	jr	ra
9d002254:	27bd0018 	addiu	sp,sp,24

9d002258 <RtccInit>:
9d002258:	27bdffd8 	addiu	sp,sp,-40
9d00225c:	00002821 	move	a1,zero
9d002260:	24040036 	li	a0,54
9d002264:	afbf0024 	sw	ra,36(sp)
9d002268:	afb40020 	sw	s4,32(sp)
9d00226c:	afb3001c 	sw	s3,28(sp)
9d002270:	afb20018 	sw	s2,24(sp)
9d002274:	afb10014 	sw	s1,20(sp)
9d002278:	0f400943 	jal	9d00250c <INTEnable>
9d00227c:	afb00010 	sw	s0,16(sp)
9d002280:	0f400633 	jal	9d0018cc <INTDisableInterrupts>
9d002284:	00000000 	nop
9d002288:	00402021 	move	a0,v0
9d00228c:	3c02aa99 	lui	v0,0xaa99
9d002290:	3c03bf81 	lui	v1,0xbf81
9d002294:	24426655 	addiu	v0,v0,26197
9d002298:	ac60f230 	sw	zero,-3536(v1)
9d00229c:	ac62f230 	sw	v0,-3536(v1)
9d0022a0:	3c025566 	lui	v0,0x5566
9d0022a4:	344299aa 	ori	v0,v0,0x99aa
9d0022a8:	ac62f230 	sw	v0,-3536(v1)
9d0022ac:	24140002 	li	s4,2
9d0022b0:	3c02bf81 	lui	v0,0xbf81
9d0022b4:	ac54f008 	sw	s4,-4088(v0)
9d0022b8:	3c023333 	lui	v0,0x3333
9d0022bc:	3c11bf80 	lui	s1,0xbf80
9d0022c0:	34108000 	li	s0,0x8000
9d0022c4:	24423333 	addiu	v0,v0,13107
9d0022c8:	3c13bf80 	lui	s3,0xbf80
9d0022cc:	24120008 	li	s2,8
9d0022d0:	ae720208 	sw	s2,520(s3)
9d0022d4:	ac62f230 	sw	v0,-3536(v1)
9d0022d8:	0f400882 	jal	9d002208 <INTRestoreInterrupts>
9d0022dc:	00000000 	nop
9d0022e0:	ae300204 	sw	s0,516(s1)
9d0022e4:	0f4009c2 	jal	9d002708 <_RtccWaitClockOff>
9d0022e8:	00000000 	nop
9d0022ec:	3c02bf80 	lui	v0,0xbf80
9d0022f0:	24040036 	li	a0,54
9d0022f4:	ac500214 	sw	s0,532(v0)
9d0022f8:	0f400938 	jal	9d0024e0 <INTClearFlag>
9d0022fc:	00000000 	nop
9d002300:	24020001 	li	v0,1
9d002304:	ae700208 	sw	s0,520(s3)
9d002308:	3c03bf81 	lui	v1,0xbf81
9d00230c:	ae320204 	sw	s2,516(s1)
9d002310:	ae220204 	sw	v0,516(s1)
9d002314:	8c64f000 	lw	a0,-4096(v1)
9d002318:	30840002 	andi	a0,a0,0x2
9d00231c:	1080000b 	beqz	a0,9d00234c <RtccInit+0xf4>
9d002320:	8fbf0024 	lw	ra,36(sp)
9d002324:	8c63f000 	lw	v1,-4096(v1)
9d002328:	7c630580 	ext	v1,v1,0x16,0x1
9d00232c:	50600008 	beqzl	v1,9d002350 <RtccInit+0xf8>
9d002330:	8fb40020 	lw	s4,32(sp)
9d002334:	3c02bf80 	lui	v0,0xbf80
9d002338:	8c420200 	lw	v0,512(v0)
9d00233c:	30420040 	andi	v0,v0,0x40
9d002340:	0002a00b 	movn	s4,zero,v0
9d002344:	02801021 	move	v0,s4
9d002348:	8fbf0024 	lw	ra,36(sp)
9d00234c:	8fb40020 	lw	s4,32(sp)
9d002350:	8fb3001c 	lw	s3,28(sp)
9d002354:	8fb20018 	lw	s2,24(sp)
9d002358:	8fb10014 	lw	s1,20(sp)
9d00235c:	8fb00010 	lw	s0,16(sp)
9d002360:	03e00008 	jr	ra
9d002364:	27bd0028 	addiu	sp,sp,40

9d002368 <RtccSetTimeDate>:
9d002368:	27bdffe8 	addiu	sp,sp,-24
9d00236c:	afa40018 	sw	a0,24(sp)
9d002370:	afa5001c 	sw	a1,28(sp)
9d002374:	27a40018 	addiu	a0,sp,24
9d002378:	afbf0014 	sw	ra,20(sp)
9d00237c:	0f400959 	jal	9d002564 <_RtccSetTimeAndDate>
9d002380:	27a5001c 	addiu	a1,sp,28
9d002384:	8fbf0014 	lw	ra,20(sp)
9d002388:	03e00008 	jr	ra
9d00238c:	27bd0018 	addiu	sp,sp,24

9d002390 <RtccOpen>:
9d002390:	27bdffc8 	addiu	sp,sp,-56
9d002394:	afb2001c 	sw	s2,28(sp)
9d002398:	afb10018 	sw	s1,24(sp)
9d00239c:	00809021 	move	s2,a0
9d0023a0:	00a08821 	move	s1,a1
9d0023a4:	24040036 	li	a0,54
9d0023a8:	00002821 	move	a1,zero
9d0023ac:	afbf0034 	sw	ra,52(sp)
9d0023b0:	afb70030 	sw	s7,48(sp)
9d0023b4:	afb6002c 	sw	s6,44(sp)
9d0023b8:	afb50028 	sw	s5,40(sp)
9d0023bc:	afb40024 	sw	s4,36(sp)
9d0023c0:	afb30020 	sw	s3,32(sp)
9d0023c4:	afb00014 	sw	s0,20(sp)
9d0023c8:	0f400943 	jal	9d00250c <INTEnable>
9d0023cc:	00069c00 	sll	s3,a2,0x10
9d0023d0:	0f400633 	jal	9d0018cc <INTDisableInterrupts>
9d0023d4:	00000000 	nop
9d0023d8:	00402021 	move	a0,v0
9d0023dc:	3c02aa99 	lui	v0,0xaa99
9d0023e0:	3c03bf81 	lui	v1,0xbf81
9d0023e4:	24426655 	addiu	v0,v0,26197
9d0023e8:	ac60f230 	sw	zero,-3536(v1)
9d0023ec:	ac62f230 	sw	v0,-3536(v1)
9d0023f0:	3c025566 	lui	v0,0x5566
9d0023f4:	344299aa 	ori	v0,v0,0x99aa
9d0023f8:	ac62f230 	sw	v0,-3536(v1)
9d0023fc:	24170002 	li	s7,2
9d002400:	3c02bf81 	lui	v0,0xbf81
9d002404:	ac57f008 	sw	s7,-4088(v0)
9d002408:	3c023333 	lui	v0,0x3333
9d00240c:	3c14bf80 	lui	s4,0xbf80
9d002410:	3c15bf80 	lui	s5,0xbf80
9d002414:	34108000 	li	s0,0x8000
9d002418:	24423333 	addiu	v0,v0,13107
9d00241c:	24160008 	li	s6,8
9d002420:	aeb60208 	sw	s6,520(s5)
9d002424:	ac62f230 	sw	v0,-3536(v1)
9d002428:	0f400882 	jal	9d002208 <INTRestoreInterrupts>
9d00242c:	00000000 	nop
9d002430:	ae900204 	sw	s0,516(s4)
9d002434:	0f4009c2 	jal	9d002708 <_RtccWaitClockOff>
9d002438:	00000000 	nop
9d00243c:	3c02bf80 	lui	v0,0xbf80
9d002440:	24040036 	li	a0,54
9d002444:	ac500214 	sw	s0,532(v0)
9d002448:	0f400938 	jal	9d0024e0 <INTClearFlag>
9d00244c:	00000000 	nop
9d002450:	3c02bf80 	lui	v0,0xbf80
9d002454:	ac520220 	sw	s2,544(v0)
9d002458:	3c02bf80 	lui	v0,0xbf80
9d00245c:	ac510230 	sw	s1,560(v0)
9d002460:	3c0203ff 	lui	v0,0x3ff
9d002464:	ae820204 	sw	v0,516(s4)
9d002468:	24020001 	li	v0,1
9d00246c:	aeb30208 	sw	s3,520(s5)
9d002470:	3c03bf81 	lui	v1,0xbf81
9d002474:	aeb00208 	sw	s0,520(s5)
9d002478:	ae960204 	sw	s6,516(s4)
9d00247c:	ae820204 	sw	v0,516(s4)
9d002480:	8c64f000 	lw	a0,-4096(v1)
9d002484:	30840002 	andi	a0,a0,0x2
9d002488:	1080000b 	beqz	a0,9d0024b8 <RtccOpen+0x128>
9d00248c:	8fbf0034 	lw	ra,52(sp)
9d002490:	8c63f000 	lw	v1,-4096(v1)
9d002494:	7c630580 	ext	v1,v1,0x16,0x1
9d002498:	50600008 	beqzl	v1,9d0024bc <RtccOpen+0x12c>
9d00249c:	8fb70030 	lw	s7,48(sp)
9d0024a0:	3c02bf80 	lui	v0,0xbf80
9d0024a4:	8c420200 	lw	v0,512(v0)
9d0024a8:	30420040 	andi	v0,v0,0x40
9d0024ac:	0002b80b 	movn	s7,zero,v0
9d0024b0:	02e01021 	move	v0,s7
9d0024b4:	8fbf0034 	lw	ra,52(sp)
9d0024b8:	8fb70030 	lw	s7,48(sp)
9d0024bc:	8fb6002c 	lw	s6,44(sp)
9d0024c0:	8fb50028 	lw	s5,40(sp)
9d0024c4:	8fb40024 	lw	s4,36(sp)
9d0024c8:	8fb30020 	lw	s3,32(sp)
9d0024cc:	8fb2001c 	lw	s2,28(sp)
9d0024d0:	8fb10018 	lw	s1,24(sp)
9d0024d4:	8fb00014 	lw	s0,20(sp)
9d0024d8:	03e00008 	jr	ra
9d0024dc:	27bd0038 	addiu	sp,sp,56

9d0024e0 <INTClearFlag>:
9d0024e0:	00041080 	sll	v0,a0,0x2
9d0024e4:	00042100 	sll	a0,a0,0x4
9d0024e8:	00822023 	subu	a0,a0,v0
9d0024ec:	3c029d00 	lui	v0,0x9d00
9d0024f0:	244228d8 	addiu	v0,v0,10456
9d0024f4:	00822021 	addu	a0,a0,v0
9d0024f8:	8c820000 	lw	v0,0(a0)
9d0024fc:	8c830008 	lw	v1,8(a0)
9d002500:	ac430004 	sw	v1,4(v0)
9d002504:	03e00008 	jr	ra
9d002508:	00000000 	nop

9d00250c <INTEnable>:
9d00250c:	14a0000b 	bnez	a1,9d00253c <INTEnable+0x30>
9d002510:	00041080 	sll	v0,a0,0x2
9d002514:	00042100 	sll	a0,a0,0x4
9d002518:	00822023 	subu	a0,a0,v0
9d00251c:	3c029d00 	lui	v0,0x9d00
9d002520:	244228d8 	addiu	v0,v0,10456
9d002524:	00442021 	addu	a0,v0,a0
9d002528:	8c820004 	lw	v0,4(a0)
9d00252c:	8c830008 	lw	v1,8(a0)
9d002530:	ac430004 	sw	v1,4(v0)
9d002534:	03e00008 	jr	ra
9d002538:	00000000 	nop
9d00253c:	00042100 	sll	a0,a0,0x4
9d002540:	00822023 	subu	a0,a0,v0
9d002544:	3c029d00 	lui	v0,0x9d00
9d002548:	244228d8 	addiu	v0,v0,10456
9d00254c:	00442021 	addu	a0,v0,a0
9d002550:	8c820004 	lw	v0,4(a0)
9d002554:	8c830008 	lw	v1,8(a0)
9d002558:	ac430008 	sw	v1,8(v0)
9d00255c:	03e00008 	jr	ra
9d002560:	00000000 	nop

9d002564 <_RtccSetTimeAndDate>:
9d002564:	27bdffd8 	addiu	sp,sp,-40
9d002568:	afb30020 	sw	s3,32(sp)
9d00256c:	3c13bf80 	lui	s3,0xbf80
9d002570:	afb00014 	sw	s0,20(sp)
9d002574:	8e700200 	lw	s0,512(s3)
9d002578:	afb2001c 	sw	s2,28(sp)
9d00257c:	afb10018 	sw	s1,24(sp)
9d002580:	7e1000c0 	ext	s0,s0,0x3,0x1
9d002584:	afbf0024 	sw	ra,36(sp)
9d002588:	00808821 	move	s1,a0
9d00258c:	12000049 	beqz	s0,9d0026b4 <_RtccSetTimeAndDate+0x150>
9d002590:	00a09021 	move	s2,a1
9d002594:	8e620200 	lw	v0,512(s3)
9d002598:	30428000 	andi	v0,v0,0x8000
9d00259c:	10400021 	beqz	v0,9d002624 <_RtccSetTimeAndDate+0xc0>
9d0025a0:	00000000 	nop
9d0025a4:	0f400633 	jal	9d0018cc <INTDisableInterrupts>
9d0025a8:	00000000 	nop
9d0025ac:	3c03bf80 	lui	v1,0xbf80
9d0025b0:	8c630200 	lw	v1,512(v1)
9d0025b4:	30630004 	andi	v1,v1,0x4
9d0025b8:	1460002a 	bnez	v1,9d002664 <_RtccSetTimeAndDate+0x100>
9d0025bc:	3c03bf80 	lui	v1,0xbf80
9d0025c0:	8c640210 	lw	a0,528(v1)
9d0025c4:	30848000 	andi	a0,a0,0x8000
9d0025c8:	14800022 	bnez	a0,9d002654 <_RtccSetTimeAndDate+0xf0>
9d0025cc:	00000000 	nop
9d0025d0:	12200003 	beqz	s1,9d0025e0 <_RtccSetTimeAndDate+0x7c>
9d0025d4:	3c03bf80 	lui	v1,0xbf80
9d0025d8:	8e240000 	lw	a0,0(s1)
9d0025dc:	ac640220 	sw	a0,544(v1)
9d0025e0:	12400003 	beqz	s2,9d0025f0 <_RtccSetTimeAndDate+0x8c>
9d0025e4:	3c03bf80 	lui	v1,0xbf80
9d0025e8:	8e440000 	lw	a0,0(s2)
9d0025ec:	ac640230 	sw	a0,560(v1)
9d0025f0:	0f400882 	jal	9d002208 <INTRestoreInterrupts>
9d0025f4:	00402021 	move	a0,v0
9d0025f8:	16000003 	bnez	s0,9d002608 <_RtccSetTimeAndDate+0xa4>
9d0025fc:	24030008 	li	v1,8
9d002600:	3c02bf80 	lui	v0,0xbf80
9d002604:	ac430204 	sw	v1,516(v0)
9d002608:	8fbf0024 	lw	ra,36(sp)
9d00260c:	8fb30020 	lw	s3,32(sp)
9d002610:	8fb2001c 	lw	s2,28(sp)
9d002614:	8fb10018 	lw	s1,24(sp)
9d002618:	8fb00014 	lw	s0,20(sp)
9d00261c:	03e00008 	jr	ra
9d002620:	27bd0028 	addiu	sp,sp,40
9d002624:	0f4009c2 	jal	9d002708 <_RtccWaitClockOff>
9d002628:	00000000 	nop
9d00262c:	12200003 	beqz	s1,9d00263c <_RtccSetTimeAndDate+0xd8>
9d002630:	3c02bf80 	lui	v0,0xbf80
9d002634:	8e230000 	lw	v1,0(s1)
9d002638:	ac430220 	sw	v1,544(v0)
9d00263c:	1240ffee 	beqz	s2,9d0025f8 <_RtccSetTimeAndDate+0x94>
9d002640:	3c02bf80 	lui	v0,0xbf80
9d002644:	8e430000 	lw	v1,0(s2)
9d002648:	ac430230 	sw	v1,560(v0)
9d00264c:	0b40097e 	j	9d0025f8 <_RtccSetTimeAndDate+0x94>
9d002650:	00000000 	nop
9d002654:	8c630210 	lw	v1,528(v1)
9d002658:	30630f00 	andi	v1,v1,0xf00
9d00265c:	1460ffdc 	bnez	v1,9d0025d0 <_RtccSetTimeAndDate+0x6c>
9d002660:	00000000 	nop
9d002664:	0f400882 	jal	9d002208 <INTRestoreInterrupts>
9d002668:	00402021 	move	a0,v0
9d00266c:	34038000 	li	v1,0x8000
9d002670:	3c02bf80 	lui	v0,0xbf80
9d002674:	ac430204 	sw	v1,516(v0)
9d002678:	0f4009c2 	jal	9d002708 <_RtccWaitClockOff>
9d00267c:	00000000 	nop
9d002680:	12200003 	beqz	s1,9d002690 <_RtccSetTimeAndDate+0x12c>
9d002684:	3c02bf80 	lui	v0,0xbf80
9d002688:	8e230000 	lw	v1,0(s1)
9d00268c:	ac430220 	sw	v1,544(v0)
9d002690:	12400003 	beqz	s2,9d0026a0 <_RtccSetTimeAndDate+0x13c>
9d002694:	3c02bf80 	lui	v0,0xbf80
9d002698:	8e430000 	lw	v1,0(s2)
9d00269c:	ac430230 	sw	v1,560(v0)
9d0026a0:	34038000 	li	v1,0x8000
9d0026a4:	3c02bf80 	lui	v0,0xbf80
9d0026a8:	ac430208 	sw	v1,520(v0)
9d0026ac:	0b40097e 	j	9d0025f8 <_RtccSetTimeAndDate+0x94>
9d0026b0:	00000000 	nop
9d0026b4:	0f400633 	jal	9d0018cc <INTDisableInterrupts>
9d0026b8:	00000000 	nop
9d0026bc:	00402021 	move	a0,v0
9d0026c0:	3c02aa99 	lui	v0,0xaa99
9d0026c4:	3c03bf81 	lui	v1,0xbf81
9d0026c8:	24426655 	addiu	v0,v0,26197
9d0026cc:	ac60f230 	sw	zero,-3536(v1)
9d0026d0:	ac62f230 	sw	v0,-3536(v1)
9d0026d4:	3c025566 	lui	v0,0x5566
9d0026d8:	344299aa 	ori	v0,v0,0x99aa
9d0026dc:	ac62f230 	sw	v0,-3536(v1)
9d0026e0:	24050008 	li	a1,8
9d0026e4:	3c02bf80 	lui	v0,0xbf80
9d0026e8:	ac450208 	sw	a1,520(v0)
9d0026ec:	3c023333 	lui	v0,0x3333
9d0026f0:	24423333 	addiu	v0,v0,13107
9d0026f4:	ac62f230 	sw	v0,-3536(v1)
9d0026f8:	0f400882 	jal	9d002208 <INTRestoreInterrupts>
9d0026fc:	00000000 	nop
9d002700:	0b400965 	j	9d002594 <_RtccSetTimeAndDate+0x30>
9d002704:	00000000 	nop

9d002708 <_RtccWaitClockOff>:
9d002708:	27bdffd0 	addiu	sp,sp,-48
9d00270c:	afb30020 	sw	s3,32(sp)
9d002710:	3c13bf81 	lui	s3,0xbf81
9d002714:	8e62f000 	lw	v0,-4096(s3)
9d002718:	afbf002c 	sw	ra,44(sp)
9d00271c:	afb50028 	sw	s5,40(sp)
9d002720:	30420002 	andi	v0,v0,0x2
9d002724:	afb40024 	sw	s4,36(sp)
9d002728:	afb2001c 	sw	s2,28(sp)
9d00272c:	afb10018 	sw	s1,24(sp)
9d002730:	1040001c 	beqz	v0,9d0027a4 <_RtccWaitClockOff+0x9c>
9d002734:	afb00014 	sw	s0,20(sp)
9d002738:	3c02a000 	lui	v0,0xa000
9d00273c:	8c520204 	lw	s2,516(v0)
9d002740:	3c140040 	lui	s4,0x40
9d002744:	3c15bf80 	lui	s5,0xbf80
9d002748:	12400016 	beqz	s2,9d0027a4 <_RtccWaitClockOff+0x9c>
9d00274c:	3c11a000 	lui	s1,0xa000
9d002750:	8e62f000 	lw	v0,-4096(s3)
9d002754:	00541024 	and	v0,v0,s4
9d002758:	10400012 	beqz	v0,9d0027a4 <_RtccWaitClockOff+0x9c>
9d00275c:	00000000 	nop
9d002760:	8ea20200 	lw	v0,512(s5)
9d002764:	30420040 	andi	v0,v0,0x40
9d002768:	1040000e 	beqz	v0,9d0027a4 <_RtccWaitClockOff+0x9c>
9d00276c:	00000000 	nop
9d002770:	0f40087a 	jal	9d0021e8 <ReadCoreTimer>
9d002774:	00000000 	nop
9d002778:	00408021 	move	s0,v0
9d00277c:	0f40087a 	jal	9d0021e8 <ReadCoreTimer>
9d002780:	00000000 	nop
9d002784:	8e230200 	lw	v1,512(s1)
9d002788:	00501023 	subu	v0,v0,s0
9d00278c:	0043182b 	sltu	v1,v0,v1
9d002790:	1460fffa 	bnez	v1,9d00277c <_RtccWaitClockOff+0x74>
9d002794:	00000000 	nop
9d002798:	2652ffff 	addiu	s2,s2,-1
9d00279c:	1640ffec 	bnez	s2,9d002750 <_RtccWaitClockOff+0x48>
9d0027a0:	00000000 	nop
9d0027a4:	8e63f000 	lw	v1,-4096(s3)
9d0027a8:	30630002 	andi	v1,v1,0x2
9d0027ac:	1060000b 	beqz	v1,9d0027dc <_RtccWaitClockOff+0xd4>
9d0027b0:	24020001 	li	v0,1
9d0027b4:	3c03bf81 	lui	v1,0xbf81
9d0027b8:	8c63f000 	lw	v1,-4096(v1)
9d0027bc:	7c630580 	ext	v1,v1,0x16,0x1
9d0027c0:	10600007 	beqz	v1,9d0027e0 <_RtccWaitClockOff+0xd8>
9d0027c4:	8fbf002c 	lw	ra,44(sp)
9d0027c8:	3c02bf80 	lui	v0,0xbf80
9d0027cc:	8c430200 	lw	v1,512(v0)
9d0027d0:	24020002 	li	v0,2
9d0027d4:	30630040 	andi	v1,v1,0x40
9d0027d8:	0003100b 	movn	v0,zero,v1
9d0027dc:	8fbf002c 	lw	ra,44(sp)
9d0027e0:	8fb50028 	lw	s5,40(sp)
9d0027e4:	8fb40024 	lw	s4,36(sp)
9d0027e8:	8fb30020 	lw	s3,32(sp)
9d0027ec:	8fb2001c 	lw	s2,28(sp)
9d0027f0:	8fb10018 	lw	s1,24(sp)
9d0027f4:	8fb00014 	lw	s0,20(sp)
9d0027f8:	03e00008 	jr	ra
9d0027fc:	27bd0030 	addiu	sp,sp,48

9d002800 <__do_global_ctors_aux>:
9d002800:	3c029d00 	lui	v0,0x9d00
9d002804:	8c422898 	lw	v0,10392(v0)
9d002808:	27bdffe0 	addiu	sp,sp,-32
9d00280c:	2403ffff 	li	v1,-1
9d002810:	afbf001c 	sw	ra,28(sp)
9d002814:	afb10018 	sw	s1,24(sp)
9d002818:	10430009 	beq	v0,v1,9d002840 <__do_global_ctors_aux+0x40>
9d00281c:	afb00014 	sw	s0,20(sp)
9d002820:	3c119d00 	lui	s1,0x9d00
9d002824:	26312898 	addiu	s1,s1,10392
9d002828:	2410ffff 	li	s0,-1
9d00282c:	0040f809 	jalr	v0
9d002830:	2631fffc 	addiu	s1,s1,-4
9d002834:	8e220000 	lw	v0,0(s1)
9d002838:	1450fffc 	bne	v0,s0,9d00282c <__do_global_ctors_aux+0x2c>
9d00283c:	00000000 	nop
9d002840:	8fbf001c 	lw	ra,28(sp)
9d002844:	8fb10018 	lw	s1,24(sp)
9d002848:	8fb00014 	lw	s0,20(sp)
9d00284c:	03e00008 	jr	ra
9d002850:	27bd0020 	addiu	sp,sp,32

Disassembly of section .init:

9d002854 <_init>:
9d002854:	27bdffe0 	addiu	sp,sp,-32
9d002858:	afbf0014 	sw	ra,20(sp)
9d00285c:	0f4004b3 	jal	9d0012cc <frame_dummy>
9d002860:	00000000 	nop
9d002864:	0f400a00 	jal	9d002800 <__do_global_ctors_aux>
9d002868:	00000000 	nop
9d00286c:	8fbf0014 	lw	ra,20(sp)
9d002870:	03e00008 	jr	ra
9d002874:	27bd0020 	addiu	sp,sp,32

Disassembly of section .fini:

9d002878 <_fini>:
9d002878:	27bdffe0 	addiu	sp,sp,-32
9d00287c:	afbf0014 	sw	ra,20(sp)
9d002880:	0f400484 	jal	9d001210 <__do_global_dtors_aux>
9d002884:	00000000 	nop
9d002888:	8fbf0014 	lw	ra,20(sp)
9d00288c:	03e00008 	jr	ra
9d002890:	27bd0020 	addiu	sp,sp,32

Disassembly of section .rodata:

9d0028a8 <_ZTV14HardwareSerial>:
	...
9d0028b0:	9d001a58 9d001e78 9d001ed0 9d0019c8     X...x...........
9d0028c0:	9d001a10 9d0019f0 9d001a4c              ........L...

9d0028cc <analog_pin_to_channel_PGM>:
9d0028cc:	0a080402 05030e0c 0f0d0b09              ............

9d0028d8 <__IntSrcTbl>:
9d0028d8:	bf881030 bf881060 00000001 bf881030     0...`.......0...
9d0028e8:	bf881060 00000002 bf881030 bf881060     `.......0...`...
9d0028f8:	00000004 bf881030 bf881060 00000008     ....0...`.......
9d002908:	bf881030 bf881060 00000080 bf881030     0...`.......0...
9d002918:	bf881060 00000800 bf881030 bf881060     `.......0...`...
9d002928:	00008000 bf881030 bf881060 00080000     ....0...`.......
9d002938:	bf881030 bf881060 00000010 bf881030     0...`.......0...
9d002948:	bf881060 00000100 bf881030 bf881060     `.......0...`...
9d002958:	00001000 bf881030 bf881060 00010000     ....0...`.......
9d002968:	bf881030 bf881060 00100000 bf881030     0...`.......0...
9d002978:	bf881060 00000020 bf881030 bf881060     `... ...0...`...
9d002988:	00000200 bf881030 bf881060 00002000     ....0...`.... ..
9d002998:	bf881030 bf881060 00020000 bf881030     0...`.......0...
9d0029a8:	bf881060 00200000 bf881030 bf881060     `..... .0...`...
9d0029b8:	00000040 bf881030 bf881060 00000400     @...0...`.......
9d0029c8:	bf881030 bf881060 00004000 bf881030     0...`....@..0...
9d0029d8:	bf881060 00040000 bf881030 bf881060     `.......0...`...
9d0029e8:	00400000 bf881040 bf881070 00000001     ..@.@...p.......
9d0029f8:	bf881030 bf881060 00800000 bf881040     0...`.......@...
9d002a08:	bf881070 00000020 bf881030 bf881060     p... ...0...`...
9d002a18:	01000000 bf881040 bf881070 00000040     ....@...p...@...
9d002a28:	bf881030 bf881060 02000000 bf881040     0...`.......@...
9d002a38:	bf881070 00000080 bf881030 bf881060     p.......0...`...
9d002a48:	03800000 bf881040 bf881070 000000e0     ....@...p.......
9d002a58:	bf881030 bf881060 04000000 bf881040     0...`.......@...
9d002a68:	bf881070 00000100 bf881030 bf881060     p.......0...`...
9d002a78:	08000000 bf881040 bf881070 00000200     ....@...p.......
9d002a88:	bf881030 bf881060 10000000 bf881040     0...`.......@...
9d002a98:	bf881070 00000400 bf881030 bf881060     p.......0...`...
9d002aa8:	1c000000 bf881040 bf881070 00000700     ....@...p.......
9d002ab8:	bf881030 bf881060 20000000 bf881040     0...`...... @...
9d002ac8:	bf881070 00000800 bf881030 bf881060     p.......0...`...
9d002ad8:	40000000 bf881040 bf881070 00001000     ...@@...p.......
9d002ae8:	bf881030 bf881060 80000000 bf881040     0...`.......@...
9d002af8:	bf881070 00002000 bf881030 bf881060     p.... ..0...`...
9d002b08:	e0000000 bf881040 bf881070 00003800     ....@...p....8..
9d002b18:	bf881040 bf881070 00000002 bf881040     @...p.......@...
9d002b28:	bf881070 00000004 bf881040 bf881070     p.......@...p...
9d002b38:	00000008 bf881040 bf881070 00000010     ....@...p.......
9d002b48:	bf881040 bf881070 00004000 bf881040     @...p....@..@...
9d002b58:	bf881070 01000000 bf881040 bf881070     p.......@...p...
9d002b68:	00008000 00000000 00000000 00000000     ................
	...

9d002bd8 <__IntVectorTbl>:
9d002bd8:	bf881090 00000000 00000002 bf881090     ................
9d002be8:	00000008 0000000a bf881090 00000010     ................
9d002bf8:	00000012 bf881090 00000018 0000001a     ................
9d002c08:	bf8810a0 00000018 0000001a bf8810b0     ................
9d002c18:	00000018 0000001a bf8810c0 00000018     ................
9d002c28:	0000001a bf8810d0 00000018 0000001a     ................
9d002c38:	bf8810a0 00000000 00000002 bf8810b0     ................
9d002c48:	00000000 00000002 bf8810c0 00000000     ................
9d002c58:	00000002 bf8810d0 00000000 00000002     ................
9d002c68:	bf8810e0 00000000 00000002 bf8810a0     ................
9d002c78:	00000008 0000000a bf8810b0 00000008     ................
9d002c88:	0000000a bf8810c0 00000008 0000000a     ................
9d002c98:	bf8810d0 00000008 0000000a bf8810e0     ................
9d002ca8:	00000008 0000000a bf8810a0 00000010     ................
9d002cb8:	00000012 bf8810b0 00000010 00000012     ................
9d002cc8:	bf8810c0 00000010 00000012 bf8810d0     ................
9d002cd8:	00000010 00000012 bf8810e0 00000010     ................
9d002ce8:	00000012 bf8810e0 00000018 0000001a     ................
9d002cf8:	bf881100 00000018 0000001a bf8810f0     ................
9d002d08:	00000000 00000002 bf881110 00000000     ................
9d002d18:	00000002 bf8810f0 00000008 0000000a     ................
9d002d28:	bf881110 00000008 0000000a bf8810f0     ................
9d002d38:	00000010 00000012 bf8810f0 00000018     ................
9d002d48:	0000001a bf881100 00000000 00000002     ................
9d002d58:	bf881100 00000008 0000000a bf881100     ................
9d002d68:	00000010 00000012 bf881110 00000010     ................
9d002d78:	00000012 bf881110 00000018 0000001a     ................
	...
9d002de8:	bf881140 00000000 00000002 00000000     @...............
	...
