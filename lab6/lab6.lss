
./lab6.elf:     file format elf32-tradlittlemips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000010  9d001000  9d001000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .app_excpt    00000010  9d000180  9d000180  00000180  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .vector_0     00000008  9d000200  9d000200  00000200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .vector_4     00000008  9d000280  9d000280  00000280  2**0
                  CONTENTS, ALLOC, LOAD, CODE
  4 .vector_24    00000008  9d000500  9d000500  00000500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .vector_32    00000008  9d000600  9d000600  00000600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .startup      000001e0  9d001010  9d001010  00001010  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text         00001b20  9d0011f0  9d0011f0  000011f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .init         00000024  9d002d10  9d002d10  00002d10  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .fini         0000001c  9d002d34  9d002d34  00002d34  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .ctors        0000000c  9d002d50  9d002d50  00002d50  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .dtors        00000008  9d002d5c  9d002d5c  00002d5c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 12 .rodata       00000558  9d002d64  9d002d64  00002d64  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 13 .dbg_data     00000200  a0000000  a0000000  00011800  2**0
                  CONTENTS
 14 .data         00000010  a0000200  9d0032bc  00010200  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 15 .sdata        00000008  a0000210  9d0032cc  00010210  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 16 .sbss         0000016c  a0000218  9d0032d4  00010218  2**2
                  ALLOC
 17 .bss          00000020  a0000384  9d0032d4  00010384  2**2
                  ALLOC
 18 .heap         00000800  a00003a8  9d0032d4  000103a8  2**0
                  ALLOC
 19 .stack        00000800  a0000ba8  9d0032d4  00010ba8  2**0
                  ALLOC
 20 .comment      000000dc  00000000  00000000  00011a00  2**0
                  CONTENTS, READONLY
 21 .debug_aranges 00001148  00000000  00000000  00011adc  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_pubnames 00001b29  00000000  00000000  00012c24  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_info   0002c5dd  00000000  00000000  0001474d  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_abbrev 00007e5e  00000000  00000000  00040d2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_line   0000cbf7  00000000  00000000  00048b88  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_frame  000020cc  00000000  00000000  00055780  2**2
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_str    000056be  00000000  00000000  0005784c  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .debug_loc    0001c1b1  00000000  00000000  0005cf0a  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_pubtypes 00002cac  00000000  00000000  000790bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 30 .debug_ranges 00003860  00000000  00000000  0007bd67  2**0
                  CONTENTS, READONLY, DEBUGGING
 31 .gnu.attributes 00000010  00000000  00000000  0007f5c7  2**0
                  CONTENTS, READONLY
 32 .mdebug.abi32 00000000  a0001800  a0001800  00011800  2**0
                  CONTENTS, ALLOC, LOAD, DATA

Disassembly of section .reset:

9d001000 <_reset>:
9d001000:	3c1a9d00 	lui	k0,0x9d00
9d001004:	275a1010 	addiu	k0,k0,4112
9d001008:	03400008 	jr	k0
9d00100c:	00000000 	nop

Disassembly of section .app_excpt:

9d000180 <_gen_exception>:
9d000180:	3c1a9d00 	lui	k0,0x9d00
9d000184:	275a2598 	addiu	k0,k0,9624
9d000188:	03400008 	jr	k0
9d00018c:	00000000 	nop

Disassembly of section .vector_0:

9d000200 <__vector_dispatch_0>:
9d000200:	0b4006f9 	j	9d001be4 <CoreTimerHandler>
9d000204:	00000000 	nop

Disassembly of section .vector_4:

9d000280 <.vector_4>:
9d000280:	0b400606 	j	9d001818 <T1_ISR>
9d000284:	00000000 	nop

Disassembly of section .vector_24:

9d000500 <__vector_dispatch_24>:
9d000500:	0b400820 	j	9d002080 <IntSer0Handler>
9d000504:	00000000 	nop

Disassembly of section .vector_32:

9d000600 <__vector_dispatch_32>:
9d000600:	0b400860 	j	9d002180 <IntSer1Handler>
9d000604:	00000000 	nop

Disassembly of section .startup:

9d001010 <_startup>:
9d001010:	401a6000 	mfc0	k0,c0_status
9d001014:	7f5a04c0 	ext	k0,k0,0x13,0x1
9d001018:	13400005 	beqz	k0,9d001030 <_no_nmi>
9d00101c:	00000000 	nop
9d001020:	3c1a9d00 	lui	k0,0x9d00
9d001024:	275a2680 	addiu	k0,k0,9856
9d001028:	03400008 	jr	k0
9d00102c:	00000000 	nop

9d001030 <_no_nmi>:
9d001030:	3c1da000 	lui	sp,0xa000
9d001034:	27bd4000 	addiu	sp,sp,16384
9d001038:	3c1ca001 	lui	gp,0xa001
9d00103c:	279c8200 	addiu	gp,gp,-32256
9d001040:	40096002 	mfc0	t1,c0_srsctl
9d001044:	01205820 	add	t3,t1,zero
9d001048:	7d2a1e80 	ext	t2,t1,0x1a,0x4
9d00104c:	7d494984 	ins	t1,t2,0x6,0x4
9d001050:	40896002 	mtc0	t1,c0_srsctl
9d001054:	41dce000 	wrpgpr	gp,gp
9d001058:	408b6002 	mtc0	t3,c0_srsctl
9d00105c:	3c089d00 	lui	t0,0x9d00
9d001060:	25082670 	addiu	t0,t0,9840
9d001064:	0100f809 	jalr	t0
9d001068:	00000000 	nop
9d00106c:	3c08a000 	lui	t0,0xa000
9d001070:	25080218 	addiu	t0,t0,536
9d001074:	3c09a000 	lui	t1,0xa000
9d001078:	252903a4 	addiu	t1,t1,932
9d00107c:	10000006 	b	9d001098 <_bss_check>
9d001080:	00000000 	nop

9d001084 <_bss_init>:
9d001084:	ad000000 	sw	zero,0(t0)
9d001088:	ad000004 	sw	zero,4(t0)
9d00108c:	ad000008 	sw	zero,8(t0)
9d001090:	ad00000c 	sw	zero,12(t0)
9d001094:	25080010 	addiu	t0,t0,16

9d001098 <_bss_check>:
9d001098:	0109082b 	sltu	at,t0,t1
9d00109c:	1420fff9 	bnez	at,9d001084 <_bss_init>
9d0010a0:	00000000 	nop
9d0010a4:	3c089d00 	lui	t0,0x9d00
9d0010a8:	250832bc 	addiu	t0,t0,12988
9d0010ac:	3c09a000 	lui	t1,0xa000
9d0010b0:	25290200 	addiu	t1,t1,512
9d0010b4:	3c0aa000 	lui	t2,0xa000
9d0010b8:	254a0218 	addiu	t2,t2,536
9d0010bc:	10000005 	b	9d0010d4 <_init_check>
9d0010c0:	00000000 	nop

9d0010c4 <_init_data>:
9d0010c4:	8d0b0000 	lw	t3,0(t0)
9d0010c8:	ad2b0000 	sw	t3,0(t1)
9d0010cc:	25080004 	addiu	t0,t0,4
9d0010d0:	25290004 	addiu	t1,t1,4

9d0010d4 <_init_check>:
9d0010d4:	012a082b 	sltu	at,t1,t2
9d0010d8:	1420fffa 	bnez	at,9d0010c4 <_init_data>
9d0010dc:	00000000 	nop
9d0010e0:	3c090000 	lui	t1,0x0
9d0010e4:	25290000 	addiu	t1,t1,0
9d0010e8:	1120001d 	beqz	t1,9d001160 <_ramfunc_done>
9d0010ec:	00000000 	nop
9d0010f0:	3c089d00 	lui	t0,0x9d00
9d0010f4:	250832d4 	addiu	t0,t0,13012
9d0010f8:	3c09a000 	lui	t1,0xa000
9d0010fc:	25291800 	addiu	t1,t1,6144
9d001100:	3c0aa000 	lui	t2,0xa000
9d001104:	254a1800 	addiu	t2,t2,6144

9d001108 <_init_ramfunc>:
9d001108:	8d0b0000 	lw	t3,0(t0)
9d00110c:	ad2b0000 	sw	t3,0(t1)
9d001110:	25080004 	addiu	t0,t0,4
9d001114:	25290004 	addiu	t1,t1,4

9d001118 <_ramfunc_check>:
9d001118:	012a082b 	sltu	at,t1,t2
9d00111c:	1420fffa 	bnez	at,9d001108 <_init_ramfunc>
9d001120:	00000000 	nop
9d001124:	3c090000 	lui	t1,0x0
9d001128:	25291800 	addiu	t1,t1,6144
9d00112c:	3c0abf88 	lui	t2,0xbf88
9d001130:	254a2010 	addiu	t2,t2,8208
9d001134:	ad490000 	sw	t1,0(t2)
9d001138:	3c090000 	lui	t1,0x0
9d00113c:	25294000 	addiu	t1,t1,16384
9d001140:	3c0abf88 	lui	t2,0xbf88
9d001144:	254a2020 	addiu	t2,t2,8224
9d001148:	ad490000 	sw	t1,0(t2)
9d00114c:	3c090000 	lui	t1,0x0
9d001150:	25294000 	addiu	t1,t1,16384
9d001154:	3c0abf88 	lui	t2,0xbf88
9d001158:	254a2030 	addiu	t2,t2,8240
9d00115c:	ad490000 	sw	t1,0(t2)

9d001160 <_ramfunc_done>:
9d001160:	40804800 	mtc0	zero,c0_count
9d001164:	240affff 	li	t2,-1
9d001168:	408a5800 	mtc0	t2,c0_compare
9d00116c:	3c099d00 	lui	t1,0x9d00
9d001170:	25290000 	addiu	t1,t1,0
9d001174:	40897801 	mtc0	t1,c0_ebase
9d001178:	3c090000 	lui	t1,0x0
9d00117c:	25290001 	addiu	t1,t1,1
9d001180:	240a0000 	li	t2,0
9d001184:	7d2a4944 	ins	t2,t1,0x5,0x5
9d001188:	408a6001 	mtc0	t2,c0_intctl
9d00118c:	3c090080 	lui	t1,0x80
9d001190:	40896800 	mtc0	t1,c0_cause
9d001194:	40088000 	mfc0	t0,c0_config
9d001198:	7d090580 	ext	t1,t0,0x16,0x1
9d00119c:	00094c40 	sll	t1,t1,0x11
9d0011a0:	40086000 	mfc0	t0,c0_status
9d0011a4:	3c010058 	lui	at,0x58
9d0011a8:	01014024 	and	t0,t0,at
9d0011ac:	01284025 	or	t0,t1,t0
9d0011b0:	40886000 	mtc0	t0,c0_status
9d0011b4:	3c089d00 	lui	t0,0x9d00
9d0011b8:	25082678 	addiu	t0,t0,9848
9d0011bc:	0100f809 	jalr	t0
9d0011c0:	00000000 	nop
9d0011c4:	40086000 	mfc0	t0,c0_status
9d0011c8:	3c01ffbf 	lui	at,0xffbf
9d0011cc:	3421ffff 	ori	at,at,0xffff
9d0011d0:	01014024 	and	t0,t0,at
9d0011d4:	40886000 	mtc0	t0,c0_status
9d0011d8:	30840000 	andi	a0,a0,0x0
9d0011dc:	30a50000 	andi	a1,a1,0x0
9d0011e0:	3c089d00 	lui	t0,0x9d00
9d0011e4:	250811f0 	addiu	t0,t0,4592
9d0011e8:	01000008 	jr	t0
9d0011ec:	00000000 	nop

Disassembly of section .text:

9d0011f0 <_main_entry>:
9d0011f0:	0f400b44 	jal	9d002d10 <_text_end>
9d0011f4:	00000000 	nop
9d0011f8:	30840000 	andi	a0,a0,0x0
9d0011fc:	30a50000 	andi	a1,a1,0x0
9d001200:	0f4004ca 	jal	9d001328 <main>
9d001204:	00000000 	nop
9d001208:	1000fffd 	b	9d001200 <_main_entry+0x10>
9d00120c:	00000000 	nop

9d001210 <__do_global_dtors_aux>:
9d001210:	27bdffd8 	addiu	sp,sp,-40
9d001214:	afb2001c 	sw	s2,28(sp)
9d001218:	3c12a000 	lui	s2,0xa000
9d00121c:	92420384 	lbu	v0,900(s2)
9d001220:	afbf0024 	sw	ra,36(sp)
9d001224:	afb30020 	sw	s3,32(sp)
9d001228:	afb10018 	sw	s1,24(sp)
9d00122c:	14400020 	bnez	v0,9d0012b0 <__do_global_dtors_aux+0xa0>
9d001230:	afb00014 	sw	s0,20(sp)
9d001234:	3c119d00 	lui	s1,0x9d00
9d001238:	3c109d00 	lui	s0,0x9d00
9d00123c:	3c13a000 	lui	s3,0xa000
9d001240:	26312d5c 	addiu	s1,s1,11612
9d001244:	26102d60 	addiu	s0,s0,11616
9d001248:	8e620388 	lw	v0,904(s3)
9d00124c:	02118023 	subu	s0,s0,s1
9d001250:	00108083 	sra	s0,s0,0x2
9d001254:	2610ffff 	addiu	s0,s0,-1
9d001258:	0050182b 	sltu	v1,v0,s0
9d00125c:	5060000c 	beqzl	v1,9d001290 <__do_global_dtors_aux+0x80>
9d001260:	3c020000 	lui	v0,0x0
9d001264:	24420001 	addiu	v0,v0,1
9d001268:	00021880 	sll	v1,v0,0x2
9d00126c:	02231821 	addu	v1,s1,v1
9d001270:	8c630000 	lw	v1,0(v1)
9d001274:	0060f809 	jalr	v1
9d001278:	ae620388 	sw	v0,904(s3)
9d00127c:	8e620388 	lw	v0,904(s3)
9d001280:	0050182b 	sltu	v1,v0,s0
9d001284:	1460fff8 	bnez	v1,9d001268 <__do_global_dtors_aux+0x58>
9d001288:	24420001 	addiu	v0,v0,1
9d00128c:	3c020000 	lui	v0,0x0
9d001290:	24420000 	addiu	v0,v0,0
9d001294:	10400005 	beqz	v0,9d0012ac <__do_global_dtors_aux+0x9c>
9d001298:	24020001 	li	v0,1
9d00129c:	3c04a000 	lui	a0,0xa000
9d0012a0:	0c000000 	jal	90000000 <_bmxdudba_address+0x8fffc000>
9d0012a4:	24840200 	addiu	a0,a0,512
9d0012a8:	24020001 	li	v0,1
9d0012ac:	a2420384 	sb	v0,900(s2)
9d0012b0:	8fbf0024 	lw	ra,36(sp)
9d0012b4:	8fb30020 	lw	s3,32(sp)
9d0012b8:	8fb2001c 	lw	s2,28(sp)
9d0012bc:	8fb10018 	lw	s1,24(sp)
9d0012c0:	8fb00014 	lw	s0,20(sp)
9d0012c4:	03e00008 	jr	ra
9d0012c8:	27bd0028 	addiu	sp,sp,40

9d0012cc <frame_dummy>:
9d0012cc:	3c020000 	lui	v0,0x0
9d0012d0:	27bdffe8 	addiu	sp,sp,-24
9d0012d4:	24420000 	addiu	v0,v0,0
9d0012d8:	10400006 	beqz	v0,9d0012f4 <frame_dummy+0x28>
9d0012dc:	afbf0014 	sw	ra,20(sp)
9d0012e0:	3c04a000 	lui	a0,0xa000
9d0012e4:	3c05a000 	lui	a1,0xa000
9d0012e8:	24840200 	addiu	a0,a0,512
9d0012ec:	0c000000 	jal	90000000 <_bmxdudba_address+0x8fffc000>
9d0012f0:	24a5038c 	addiu	a1,a1,908
9d0012f4:	3c04a000 	lui	a0,0xa000
9d0012f8:	8c820200 	lw	v0,512(a0)
9d0012fc:	10400007 	beqz	v0,9d00131c <frame_dummy+0x50>
9d001300:	3c190000 	lui	t9,0x0
9d001304:	27390000 	addiu	t9,t9,0
9d001308:	13200004 	beqz	t9,9d00131c <frame_dummy+0x50>
9d00130c:	8fbf0014 	lw	ra,20(sp)
9d001310:	24840200 	addiu	a0,a0,512
9d001314:	03200008 	jr	t9
9d001318:	27bd0018 	addiu	sp,sp,24
9d00131c:	8fbf0014 	lw	ra,20(sp)
9d001320:	03e00008 	jr	ra
9d001324:	27bd0018 	addiu	sp,sp,24

9d001328 <main>:
9d001328:	27bdffe8 	addiu	sp,sp,-24
9d00132c:	afbf0014 	sw	ra,20(sp)
9d001330:	afbe0010 	sw	s8,16(sp)
9d001334:	03a0f021 	move	s8,sp
9d001338:	0f4006af 	jal	9d001abc <init>
9d00133c:	00000000 	nop
9d001340:	3c02a000 	lui	v0,0xa000
9d001344:	2444022c 	addiu	a0,v0,556
9d001348:	24052580 	li	a1,9600
9d00134c:	0f4007ce 	jal	9d001f38 <_ZN14HardwareSerial5beginEm>
9d001350:	00000000 	nop
9d001354:	0f4004e4 	jal	9d001390 <SetupPort>
9d001358:	00000000 	nop
9d00135c:	0f4004f6 	jal	9d0013d8 <SetupTimer>
9d001360:	00000000 	nop
9d001364:	0f400514 	jal	9d001450 <ProgramNote>
9d001368:	00000000 	nop
9d00136c:	0f40059b 	jal	9d00166c <PlayNote>
9d001370:	00000000 	nop
9d001374:	00001021 	move	v0,zero
9d001378:	03c0e821 	move	sp,s8
9d00137c:	8fbf0014 	lw	ra,20(sp)
9d001380:	8fbe0010 	lw	s8,16(sp)
9d001384:	27bd0018 	addiu	sp,sp,24
9d001388:	03e00008 	jr	ra
9d00138c:	00000000 	nop

9d001390 <SetupPort>:
9d001390:	240a0008 3c18bf88 271860c0 af0a0004     ...$...<.`.'....
9d0013a0:	24080fe0 3c18bf88 271860c0 af080008     ...$...<.`.'....
9d0013b0:	24080080 3c18bf88 27186140 af080008     ...$...<@a.'....
9d0013c0:	240800ff 3c18bf88 27186100 af080004     ...$...<.a.'....
9d0013d0:	03e00008 00000000                       ........

9d0013d8 <SetupTimer>:
9d0013d8:	34088000 3c18bf80 27180600 af080004     ...4...<...'....
9d0013e8:	24080002 af080004 24080030 af080008     ...$....0..$....
9d0013f8:	3408ffff 3c18bf80 27180610 af080004     ...4...<...'....
9d001408:	24080000 3c18bf80 27180620 af080008     ...$...< ..'....
9d001418:	2408001c 3c18bf88 271810a0 af080008     ...$...<...'....
9d001428:	24080010 3c18bf88 27181030 af080004     ...$...<0..'....
9d001438:	24080010 3c18bf88 27181060 af080008     ...$...<`..'....
9d001448:	03e00008 00000000                       ........

9d001450 <ProgramNote>:
9d001450:	afbf0000 23bdfffc 0f4005e5 00000000     .......#..@.....

9d001460 <testSound>:
9d001460:	24040000 	li	a0,0
9d001464:	0f400764 	jal	9d001d90 <analogRead>
9d001468:	00000000 	nop
9d00146c:	00402021 	move	a0,v0
9d001470:	3c04a000 	lui	a0,0xa000
9d001474:	2484022c 	addiu	a0,a0,556
9d001478:	00402821 	move	a1,v0
9d00147c:	2406000a 	li	a2,10
9d001480:	0f40095c 	jal	9d002570 <_ZN5Print7printlnEii>
9d001484:	00000000 	nop
9d001488:	24040000 	li	a0,0
9d00148c:	0f400764 	jal	9d001d90 <analogRead>
9d001490:	00000000 	nop
9d001494:	00402021 	move	a0,v0
9d001498:	0f4005f1 	jal	9d0017c4 <Freq2Period>
9d00149c:	00000000 	nop
9d0014a0:	3c18bf80 	lui	t8,0xbf80
9d0014a4:	27180620 	addiu	t8,t8,1568
9d0014a8:	3408ffff 	li	t0,0xffff
9d0014ac:	af080004 	sw	t0,4(t8)
9d0014b0:	af020008 	sw	v0,8(t8)
9d0014b4:	24040000 	li	a0,0
9d0014b8:	0f400625 	jal	9d001894 <readButton>
9d0014bc:	00000000 	nop
9d0014c0:	10400012 	beqz	v0,9d00150c <notB0>
9d0014c4:	00000000 	nop
9d0014c8:	0f4005e5 	jal	9d001794 <EnableTimer>
9d0014cc:	00000000 	nop
9d0014d0:	24040001 	li	a0,1
9d0014d4:	0f400614 	jal	9d001850 <readSwitch>
9d0014d8:	00000000 	nop
9d0014dc:	1040004f 	beqz	v0,9d00161c <notS1>
9d0014e0:	00000000 	nop
9d0014e4:	24040000 	li	a0,0
9d0014e8:	0f400764 	jal	9d001d90 <analogRead>
9d0014ec:	00000000 	nop
9d0014f0:	00402021 	move	a0,v0
9d0014f4:	0f4005f1 	jal	9d0017c4 <Freq2Period>
9d0014f8:	00000000 	nop
9d0014fc:	3c01a000 	lui	at,0xa000
9d001500:	ac220200 	sw	v0,512(at)
9d001504:	0b400518 	j	9d001460 <testSound>
9d001508:	00000000 	nop

9d00150c <notB0>:
9d00150c:	24040001 	li	a0,1
9d001510:	0f400625 	jal	9d001894 <readButton>
9d001514:	00000000 	nop
9d001518:	10400012 	beqz	v0,9d001564 <notB1>
9d00151c:	00000000 	nop
9d001520:	0f4005e5 	jal	9d001794 <EnableTimer>
9d001524:	00000000 	nop
9d001528:	24040001 	li	a0,1
9d00152c:	0f400614 	jal	9d001850 <readSwitch>
9d001530:	00000000 	nop
9d001534:	10400039 	beqz	v0,9d00161c <notS1>
9d001538:	00000000 	nop
9d00153c:	24040000 	li	a0,0
9d001540:	0f400764 	jal	9d001d90 <analogRead>
9d001544:	00000000 	nop
9d001548:	00402021 	move	a0,v0
9d00154c:	0f4005f1 	jal	9d0017c4 <Freq2Period>
9d001550:	00000000 	nop
9d001554:	3c01a000 	lui	at,0xa000
9d001558:	ac220204 	sw	v0,516(at)
9d00155c:	0b400518 	j	9d001460 <testSound>
9d001560:	00000000 	nop

9d001564 <notB1>:
9d001564:	24040002 	li	a0,2
9d001568:	0f400625 	jal	9d001894 <readButton>
9d00156c:	00000000 	nop
9d001570:	10400012 	beqz	v0,9d0015bc <notB2>
9d001574:	00000000 	nop
9d001578:	0f4005e5 	jal	9d001794 <EnableTimer>
9d00157c:	00000000 	nop
9d001580:	24040001 	li	a0,1
9d001584:	0f400614 	jal	9d001850 <readSwitch>
9d001588:	00000000 	nop
9d00158c:	10400023 	beqz	v0,9d00161c <notS1>
9d001590:	00000000 	nop
9d001594:	24040000 	li	a0,0
9d001598:	0f400764 	jal	9d001d90 <analogRead>
9d00159c:	00000000 	nop
9d0015a0:	00402021 	move	a0,v0
9d0015a4:	0f4005f1 	jal	9d0017c4 <Freq2Period>
9d0015a8:	00000000 	nop
9d0015ac:	3c01a000 	lui	at,0xa000
9d0015b0:	ac220208 	sw	v0,520(at)
9d0015b4:	0b400518 	j	9d001460 <testSound>
9d0015b8:	00000000 	nop

9d0015bc <notB2>:
9d0015bc:	24040003 	li	a0,3
9d0015c0:	0f400625 	jal	9d001894 <readButton>
9d0015c4:	00000000 	nop
9d0015c8:	10400012 	beqz	v0,9d001614 <notB3>
9d0015cc:	00000000 	nop
9d0015d0:	0f4005e5 	jal	9d001794 <EnableTimer>
9d0015d4:	00000000 	nop
9d0015d8:	24040001 	li	a0,1
9d0015dc:	0f400614 	jal	9d001850 <readSwitch>
9d0015e0:	00000000 	nop
9d0015e4:	1040000d 	beqz	v0,9d00161c <notS1>
9d0015e8:	00000000 	nop
9d0015ec:	24040000 	li	a0,0
9d0015f0:	0f400764 	jal	9d001d90 <analogRead>
9d0015f4:	00000000 	nop
9d0015f8:	00402021 	move	a0,v0
9d0015fc:	0f4005f1 	jal	9d0017c4 <Freq2Period>
9d001600:	00000000 	nop
9d001604:	3c01a000 	lui	at,0xa000
9d001608:	ac22020c 	sw	v0,524(at)
9d00160c:	0b400518 	j	9d001460 <testSound>
9d001610:	00000000 	nop

9d001614 <notB3>:
9d001614:	0f4005eb 	jal	9d0017ac <DisableTimer>
9d001618:	00000000 	nop

9d00161c <notS1>:
9d00161c:	3c08a000 	lui	t0,0xa000
9d001620:	8d080200 	lw	t0,512(t0)
9d001624:	3c09a000 	lui	t1,0xa000
9d001628:	8d290204 	lw	t1,516(t1)
9d00162c:	3c0aa000 	lui	t2,0xa000
9d001630:	8d4a0208 	lw	t2,520(t2)
9d001634:	3c0ba000 	lui	t3,0xa000
9d001638:	8d6b020c 	lw	t3,524(t3)
9d00163c:	1100ff88 	beqz	t0,9d001460 <testSound>
9d001640:	00000000 	nop
9d001644:	1120ff86 	beqz	t1,9d001460 <testSound>
9d001648:	00000000 	nop
9d00164c:	1140ff84 	beqz	t2,9d001460 <testSound>
9d001650:	00000000 	nop
9d001654:	1160ff82 	beqz	t3,9d001460 <testSound>
9d001658:	00000000 	nop
9d00165c:	23bd0004 	addi	sp,sp,4
9d001660:	8fbf0000 	lw	ra,0(sp)
9d001664:	03e00008 	jr	ra
9d001668:	00000000 	nop

9d00166c <PlayNote>:
9d00166c:	afbf0000 23bdfffc                       .......#

9d001674 <playMusic>:
9d001674:	24040000 	li	a0,0
9d001678:	0f400625 	jal	9d001894 <readButton>
9d00167c:	00000000 	nop
9d001680:	1040000c 	beqz	v0,9d0016b4 <noPlayB0>
9d001684:	00000000 	nop
9d001688:	3c09a000 	lui	t1,0xa000
9d00168c:	8d290200 	lw	t1,512(t1)
9d001690:	3c18bf80 	lui	t8,0xbf80
9d001694:	27180620 	addiu	t8,t8,1568
9d001698:	3408ffff 	li	t0,0xffff
9d00169c:	af080004 	sw	t0,4(t8)
9d0016a0:	af090008 	sw	t1,8(t8)
9d0016a4:	0f4005e5 	jal	9d001794 <EnableTimer>
9d0016a8:	00000000 	nop
9d0016ac:	0b40059d 	j	9d001674 <playMusic>
9d0016b0:	00000000 	nop

9d0016b4 <noPlayB0>:
9d0016b4:	24040001 	li	a0,1
9d0016b8:	0f400625 	jal	9d001894 <readButton>
9d0016bc:	00000000 	nop
9d0016c0:	1040000c 	beqz	v0,9d0016f4 <noPlayB1>
9d0016c4:	00000000 	nop
9d0016c8:	3c09a000 	lui	t1,0xa000
9d0016cc:	8d290204 	lw	t1,516(t1)
9d0016d0:	3c18bf80 	lui	t8,0xbf80
9d0016d4:	27180620 	addiu	t8,t8,1568
9d0016d8:	3408ffff 	li	t0,0xffff
9d0016dc:	af080004 	sw	t0,4(t8)
9d0016e0:	af090008 	sw	t1,8(t8)
9d0016e4:	0f4005e5 	jal	9d001794 <EnableTimer>
9d0016e8:	00000000 	nop
9d0016ec:	0b40059d 	j	9d001674 <playMusic>
9d0016f0:	00000000 	nop

9d0016f4 <noPlayB1>:
9d0016f4:	24040002 	li	a0,2
9d0016f8:	0f400625 	jal	9d001894 <readButton>
9d0016fc:	00000000 	nop
9d001700:	1040000c 	beqz	v0,9d001734 <noPlayB2>
9d001704:	00000000 	nop
9d001708:	3c09a000 	lui	t1,0xa000
9d00170c:	8d290208 	lw	t1,520(t1)
9d001710:	3c18bf80 	lui	t8,0xbf80
9d001714:	27180620 	addiu	t8,t8,1568
9d001718:	3408ffff 	li	t0,0xffff
9d00171c:	af080004 	sw	t0,4(t8)
9d001720:	af090008 	sw	t1,8(t8)
9d001724:	0f4005e5 	jal	9d001794 <EnableTimer>
9d001728:	00000000 	nop
9d00172c:	0b40059d 	j	9d001674 <playMusic>
9d001730:	00000000 	nop

9d001734 <noPlayB2>:
9d001734:	24040003 	li	a0,3
9d001738:	0f400625 	jal	9d001894 <readButton>
9d00173c:	00000000 	nop
9d001740:	1040000c 	beqz	v0,9d001774 <noPlayB3>
9d001744:	00000000 	nop
9d001748:	3c09a000 	lui	t1,0xa000
9d00174c:	8d29020c 	lw	t1,524(t1)
9d001750:	3c18bf80 	lui	t8,0xbf80
9d001754:	27180620 	addiu	t8,t8,1568
9d001758:	3408ffff 	li	t0,0xffff
9d00175c:	af080004 	sw	t0,4(t8)
9d001760:	af090008 	sw	t1,8(t8)
9d001764:	0f4005e5 	jal	9d001794 <EnableTimer>
9d001768:	00000000 	nop
9d00176c:	0b40059d 	j	9d001674 <playMusic>
9d001770:	00000000 	nop

9d001774 <noPlayB3>:
9d001774:	0f4005eb 	jal	9d0017ac <DisableTimer>
9d001778:	00000000 	nop
9d00177c:	0b40059d 	j	9d001674 <playMusic>
9d001780:	00000000 	nop
9d001784:	23bd0004 	addi	sp,sp,4
9d001788:	8fbf0000 	lw	ra,0(sp)
9d00178c:	03e00008 	jr	ra
9d001790:	00000000 	nop

9d001794 <EnableTimer>:
9d001794:	34088000 	li	t0,0x8000
9d001798:	3c18bf80 	lui	t8,0xbf80
9d00179c:	27180600 	addiu	t8,t8,1536
9d0017a0:	af080008 	sw	t0,8(t8)
9d0017a4:	03e00008 	jr	ra
9d0017a8:	00000000 	nop

9d0017ac <DisableTimer>:
9d0017ac:	34088000 	li	t0,0x8000
9d0017b0:	3c18bf80 	lui	t8,0xbf80
9d0017b4:	27180600 	addiu	t8,t8,1536
9d0017b8:	af080004 	sw	t0,4(t8)
9d0017bc:	03e00008 	jr	ra
9d0017c0:	00000000 	nop

9d0017c4 <Freq2Period>:
9d0017c4:	24020000 	li	v0,0
9d0017c8:	10800011 	beqz	a0,9d001810 <ReturnPeriod>
9d0017cc:	00000000 	nop
9d0017d0:	3c0204c4 	lui	v0,0x4c4
9d0017d4:	3442b400 	ori	v0,v0,0xb400
9d0017d8:	24090100 	li	t1,256
9d0017dc:	240a0002 	li	t2,2
9d0017e0:	70894002 	mul	t0,a0,t1
9d0017e4:	710a4002 	mul	t0,t0,t2
9d0017e8:	15000002 	bnez	t0,9d0017f4 <Freq2Period+0x30>
9d0017ec:	0048001a 	div	zero,v0,t0
9d0017f0:	0007000d 	break	0x7
9d0017f4:	2401ffff 	li	at,-1
9d0017f8:	15010004 	bne	t0,at,9d00180c <Freq2Period+0x48>
9d0017fc:	3c018000 	lui	at,0x8000
9d001800:	14410002 	bne	v0,at,9d00180c <Freq2Period+0x48>
9d001804:	00000000 	nop
9d001808:	0006000d 	break	0x6
9d00180c:	00001012 	mflo	v0

9d001810 <ReturnPeriod>:
9d001810:	03e00008 	jr	ra
9d001814:	00000000 	nop

9d001818 <T1_ISR>:
9d001818:	240a0008 	li	t2,8
9d00181c:	3c18bf88 	lui	t8,0xbf88
9d001820:	271860d0 	addiu	t8,t8,24784
9d001824:	af0a000c 	sw	t2,12(t8)
9d001828:	24080010 	li	t0,16
9d00182c:	3c18bf88 	lui	t8,0xbf88
9d001830:	27181030 	addiu	t8,t8,4144
9d001834:	af080004 	sw	t0,4(t8)
9d001838:	3408ffff 	li	t0,0xffff
9d00183c:	3c18bf80 	lui	t8,0xbf80
9d001840:	27180610 	addiu	t8,t8,1552
9d001844:	af080004 	sw	t0,4(t8)
9d001848:	42000018 	eret
9d00184c:	00000000 	nop

9d001850 <readSwitch>:
9d001850:	afbf0000 	sw	ra,0(sp)
9d001854:	23bdfffc 	addi	sp,sp,-4
9d001858:	3c08bf88 	lui	t0,0xbf88
9d00185c:	8d0860d0 	lw	t0,24784(t0)
9d001860:	24090100 	li	t1,256
9d001864:	240a0000 	li	t2,0

9d001868 <switchLoop>:
9d001868:	214a0001 	addi	t2,t2,1
9d00186c:	108a0004 	beq	a0,t2,9d001880 <endSwitchLoop>
9d001870:	00000000 	nop
9d001874:	00094840 	sll	t1,t1,0x1
9d001878:	0b40061a 	j	9d001868 <switchLoop>
9d00187c:	00000000 	nop

9d001880 <endSwitchLoop>:
9d001880:	01091024 	and	v0,t0,t1
9d001884:	23bd0004 	addi	sp,sp,4
9d001888:	8fbf0000 	lw	ra,0(sp)
9d00188c:	03e00008 	jr	ra
9d001890:	00000000 	nop

9d001894 <readButton>:
9d001894:	afbf0000 	sw	ra,0(sp)
9d001898:	23bdfffc 	addi	sp,sp,-4
9d00189c:	1c800006 	bgtz	a0,9d0018b8 <btn123>
9d0018a0:	00000000 	nop
9d0018a4:	24090002 	li	t1,2
9d0018a8:	3c08bf88 	lui	t0,0xbf88
9d0018ac:	8d086150 	lw	t0,24912(t0)
9d0018b0:	0b400638 	j	9d0018e0 <returnButtonState>
9d0018b4:	00000000 	nop

9d0018b8 <btn123>:
9d0018b8:	3c08bf88 	lui	t0,0xbf88
9d0018bc:	8d0860d0 	lw	t0,24784(t0)
9d0018c0:	24090020 	li	t1,32
9d0018c4:	240a0000 	li	t2,0

9d0018c8 <buttonLoop>:
9d0018c8:	214a0001 	addi	t2,t2,1
9d0018cc:	108a0004 	beq	a0,t2,9d0018e0 <returnButtonState>
9d0018d0:	00000000 	nop
9d0018d4:	00094840 	sll	t1,t1,0x1
9d0018d8:	0b400632 	j	9d0018c8 <buttonLoop>
9d0018dc:	00000000 	nop

9d0018e0 <returnButtonState>:
9d0018e0:	01091024 	and	v0,t0,t1
9d0018e4:	23bd0004 	addi	sp,sp,4
9d0018e8:	8fbf0000 	lw	ra,0(sp)
9d0018ec:	03e00008 	jr	ra
9d0018f0:	00000000 	nop

9d0018f4 <enableIO>:
9d0018f4:	afbf0000 	sw	ra,0(sp)
9d0018f8:	23bdfffc 	addi	sp,sp,-4
9d0018fc:	24080fe0 	li	t0,4064
9d001900:	3c18bf88 	lui	t8,0xbf88
9d001904:	271860c0 	addiu	t8,t8,24768
9d001908:	af080008 	sw	t0,8(t8)
9d00190c:	24080002 	li	t0,2
9d001910:	3c18bf88 	lui	t8,0xbf88
9d001914:	27186140 	addiu	t8,t8,24896
9d001918:	af080008 	sw	t0,8(t8)
9d00191c:	240800ff 	li	t0,255
9d001920:	3c18bf88 	lui	t8,0xbf88
9d001924:	27186100 	addiu	t8,t8,24832
9d001928:	af080004 	sw	t0,4(t8)
9d00192c:	23bd0004 	addi	sp,sp,4
9d001930:	8fbf0000 	lw	ra,0(sp)
9d001934:	03e00008 	jr	ra
9d001938:	00000000 	nop

9d00193c <LEDon>:
9d00193c:	afbf0000 	sw	ra,0(sp)
9d001940:	23bdfffc 	addi	sp,sp,-4
9d001944:	3c18bf88 	lui	t8,0xbf88
9d001948:	27186110 	addiu	t8,t8,24848
9d00194c:	af040008 	sw	a0,8(t8)
9d001950:	23bd0004 	addi	sp,sp,4
9d001954:	8fbf0000 	lw	ra,0(sp)
9d001958:	03e00008 	jr	ra
9d00195c:	00000000 	nop

9d001960 <LEDoff>:
9d001960:	afbf0000 	sw	ra,0(sp)
9d001964:	23bdfffc 	addi	sp,sp,-4
9d001968:	3c18bf88 	lui	t8,0xbf88
9d00196c:	27186110 	addiu	t8,t8,24848
9d001970:	af040004 	sw	a0,4(t8)
9d001974:	23bd0004 	addi	sp,sp,4
9d001978:	8fbf0000 	lw	ra,0(sp)
9d00197c:	03e00008 	jr	ra
9d001980:	00000000 	nop

9d001984 <LEDallOn>:
9d001984:	afbf0000 	sw	ra,0(sp)
9d001988:	23bdfffc 	addi	sp,sp,-4
9d00198c:	24080000 	li	t0,0
9d001990:	24090008 	li	t1,8
9d001994:	240a0001 	li	t2,1
9d001998:	3c18bf88 	lui	t8,0xbf88
9d00199c:	27186110 	addiu	t8,t8,24848

9d0019a0 <onLoop>:
9d0019a0:	21080001 	addi	t0,t0,1
9d0019a4:	af0a0008 	sw	t2,8(t8)
9d0019a8:	000a5040 	sll	t2,t2,0x1
9d0019ac:	11090003 	beq	t0,t1,9d0019bc <doneOn>
9d0019b0:	00000000 	nop
9d0019b4:	0b400668 	j	9d0019a0 <onLoop>
9d0019b8:	00000000 	nop

9d0019bc <doneOn>:
9d0019bc:	23bd0004 	addi	sp,sp,4
9d0019c0:	8fbf0000 	lw	ra,0(sp)
9d0019c4:	03e00008 	jr	ra
9d0019c8:	00000000 	nop

9d0019cc <LEDallOff>:
9d0019cc:	afbf0000 	sw	ra,0(sp)
9d0019d0:	23bdfffc 	addi	sp,sp,-4
9d0019d4:	24080000 	li	t0,0
9d0019d8:	24090008 	li	t1,8
9d0019dc:	240a0001 	li	t2,1
9d0019e0:	3c18bf88 	lui	t8,0xbf88
9d0019e4:	27186110 	addiu	t8,t8,24848

9d0019e8 <offLoop>:
9d0019e8:	21080001 	addi	t0,t0,1
9d0019ec:	af0a0004 	sw	t2,4(t8)
9d0019f0:	000a5040 	sll	t2,t2,0x1
9d0019f4:	11090003 	beq	t0,t1,9d001a04 <doneOff>
9d0019f8:	00000000 	nop
9d0019fc:	0b40067a 	j	9d0019e8 <offLoop>
9d001a00:	00000000 	nop

9d001a04 <doneOff>:
9d001a04:	23bd0004 	addi	sp,sp,4
9d001a08:	8fbf0000 	lw	ra,0(sp)
9d001a0c:	03e00008 	jr	ra
9d001a10:	00000000 	nop

9d001a14 <micros>:
// overflows. The first value of CoreTimer after an overflow is recorded,
// and all micros() calls after that (until the next overflow) are 
// referenced from that value. This insures accuracy and that micros()
// lines up perfectly with millis().
//************************************************************************
unsigned long micros()
9d001a14:	27bdffe8 	addiu	sp,sp,-24
9d001a18:	afbf0014 	sw	ra,20(sp)
9d001a1c:	afb00010 	sw	s0,16(sp)
    10. Understand, your callback is being called while executing inside the CoreTimerHandler ISR. Your code should be as fast as possible. If too much
        time is taken, the ISR may never exit and no sketch will ever run!
*/
//************************************************************************
#define read_count(dest) __asm__ __volatile__("mfc0 %0,$9" : "=r" (dest))
#define read_comp(dest) __asm__ __volatile__("mfc0 %0,$11" : "=r" (dest))
9d001a20:	41626000 	di	v0
unsigned int cur_timer_val	=	0;
unsigned int micros_delta	=	0;

	unsigned int result;
	
	INTDisableInterrupts();
9d001a24:	0f4009a9 	jal	9d0026a4 <ReadCoreTimer>
	result = gTimer0_millis * 1000;
9d001a28:	8f908018 	lw	s0,-32744(gp)
	cur_timer_val = ReadCoreTimer();
9d001a2c:	8f83801c 	lw	v1,-32740(gp)
9d001a30:	00431023 	subu	v0,v0,v1
	cur_timer_val -= gCore_timer_last_val;
9d001a34:	24420014 	addiu	v0,v0,20
    5.	Unfortunately, because of things like the EEProm writes, you can be called late and you must “catch-up” however best you can and return 
        the next requested “compare” time on your next call.
    6.	There are limits to how far in the future you can set your next "compare" time. Right now this is limited to 90 seconds. If you need a longer delay you
        should be using something other than a CoreTimer Services to do this. You probably should really limit your next "compare" time to less than few seconds.
    7.	Your next requested “compare” time MUST be equal to or after (in time) the “current” time as passed in to you. You may add up to 90 seconds to the 
        current time, even if this causes uint32 wrap; but do not subtract from the current time and return that. There is a region known to CoreTimerHandler 
9d001a38:	41636020 	ei	v1
	
	INTDisableInterrupts();
	result = gTimer0_millis * 1000;
	cur_timer_val = ReadCoreTimer();
	cur_timer_val -= gCore_timer_last_val;
	cur_timer_val += CORETIMER_TICKS_PER_MICROSECOND/2;  // rounding
9d001a3c:	3c04cccc 	lui	a0,0xcccc
9d001a40:	3484cccd 	ori	a0,a0,0xcccd
9d001a44:	00440019 	multu	v0,a0
unsigned int cur_timer_val	=	0;
unsigned int micros_delta	=	0;

	unsigned int result;
	
	INTDisableInterrupts();
9d001a48:	00101880 	sll	v1,s0,0x2
9d001a4c:	001021c0 	sll	a0,s0,0x7
9d001a50:	00831823 	subu	v1,a0,v1
	cur_timer_val -= gCore_timer_last_val;
	cur_timer_val += CORETIMER_TICKS_PER_MICROSECOND/2;  // rounding
	cur_timer_val /= CORETIMER_TICKS_PER_MICROSECOND;  // convert to microseconds
	INTEnableInterrupts();
	return (result + cur_timer_val);

9d001a54:	8fbf0014 	lw	ra,20(sp)
unsigned int cur_timer_val	=	0;
unsigned int micros_delta	=	0;

	unsigned int result;
	
	INTDisableInterrupts();
9d001a58:	00708021 	addu	s0,v1,s0
9d001a5c:	001080c0 	sll	s0,s0,0x3
	result = gTimer0_millis * 1000;
	cur_timer_val = ReadCoreTimer();
	cur_timer_val -= gCore_timer_last_val;
	cur_timer_val += CORETIMER_TICKS_PER_MICROSECOND/2;  // rounding
9d001a60:	00001010 	mfhi	v0
9d001a64:	00021142 	srl	v0,v0,0x5
	cur_timer_val /= CORETIMER_TICKS_PER_MICROSECOND;  // convert to microseconds
	INTEnableInterrupts();
	return (result + cur_timer_val);

9d001a68:	00501021 	addu	v0,v0,s0
9d001a6c:	8fb00010 	lw	s0,16(sp)
9d001a70:	03e00008 	jr	ra
9d001a74:	27bd0018 	addiu	sp,sp,24

9d001a78 <delayMicroseconds>:
//************************************************************************
//*	Delay for the given number of microseconds. Will fail on micros()
//*	rollover every 71 minutes
void delayMicroseconds(unsigned int us)
{
unsigned long	startMicros	=	micros();
9d001a78:	27bdffe0 	addiu	sp,sp,-32
9d001a7c:	afb10018 	sw	s1,24(sp)
9d001a80:	afb00014 	sw	s0,20(sp)
9d001a84:	afbf001c 	sw	ra,28(sp)

9d001a88:	0f400685 	jal	9d001a14 <micros>
9d001a8c:	00808821 	move	s1,a0
9d001a90:	00408021 	move	s0,v0
	while ((micros() - startMicros) < us)
	{
9d001a94:	0f400685 	jal	9d001a14 <micros>
9d001a98:	00000000 	nop
9d001a9c:	00501023 	subu	v0,v0,s0
9d001aa0:	0051102b 	sltu	v0,v0,s1
9d001aa4:	1440fffb 	bnez	v0,9d001a94 <delayMicroseconds+0x1c>
9d001aa8:	8fbf001c 	lw	ra,28(sp)
		//*	do nothing
	}
}

9d001aac:	8fb10018 	lw	s1,24(sp)
9d001ab0:	8fb00014 	lw	s0,20(sp)
9d001ab4:	03e00008 	jr	ra
9d001ab8:	27bd0020 	addiu	sp,sp,32

9d001abc <init>:

//************************************************************************
void init()
{

9d001abc:	27bdffe0 	addiu	sp,sp,-32
9d001ac0:	afbf001c 	sw	ra,28(sp)
9d001ac4:	afb10018 	sw	s1,24(sp)
9d001ac8:	afb00014 	sw	s0,20(sp)
    10. Understand, your callback is being called while executing inside the CoreTimerHandler ISR. Your code should be as fast as possible. If too much
        time is taken, the ISR may never exit and no sketch will ever run!
*/
//************************************************************************
#define read_count(dest) __asm__ __volatile__("mfc0 %0,$9" : "=r" (dest))
#define read_comp(dest) __asm__ __volatile__("mfc0 %0,$11" : "=r" (dest))
9d001acc:	41716000 	di	s1
    unsigned int cache_status;
#endif

    int_status=INTDisableInterrupts();

    mBMXDisableDRMWaitState();
9d001ad0:	24030040 	li	v1,64
9d001ad4:	3c02bf88 	lui	v0,0xbf88
9d001ad8:	ac432004 	sw	v1,8196(v0)
9d001adc:	41646000 	di	a0
        wait_states++;
        sys_clock -= FLASH_SPEED_HZ;
    }

    int_status=INTDisableInterrupts();
    mCheConfigure(wait_states);
9d001ae0:	3c10bf88 	lui	s0,0xbf88
9d001ae4:	24020002 	li	v0,2
9d001ae8:	0f4009b1 	jal	9d0026c4 <INTRestoreInterrupts>
    INTRestoreInterrupts(int_status);
9d001aec:	ae024000 	sw	v0,16384(s0)


#ifdef _PCACHE
    if(flags & SYS_CFG_PCACHE)
    {
        cache_status = mCheGetCon();
9d001af0:	8e024000 	lw	v0,16384(s0)
        cache_status |= CHE_CONF_PF_ALL;
9d001af4:	34420030 	ori	v0,v0,0x30
        mCheConfigure(cache_status);
9d001af8:	0f4009ab 	jal	9d0026ac <CheKseg0CacheOn>
        CheKseg0CacheOn();
9d001afc:	ae024000 	sw	v0,16384(s0)
    }
#endif

    pb_clk = sys_clock;
    pb_clk >>= OSCCONbits.PBDIV;
9d001b00:	3c02bf81 	lui	v0,0xbf81
9d001b04:	8c50f000 	lw	s0,-4096(v0)

    INTRestoreInterrupts(int_status);
9d001b08:	0f4009b1 	jal	9d0026c4 <INTRestoreInterrupts>
9d001b0c:	02202021 	move	a0,s1
        CheKseg0CacheOn();
    }
#endif

    pb_clk = sys_clock;
    pb_clk >>= OSCCONbits.PBDIV;
9d001b10:	3c0204c4 	lui	v0,0x4c4
9d001b14:	3442b400 	ori	v0,v0,0xb400
9d001b18:	7e100cc0 	ext	s0,s0,0x13,0x2
9d001b1c:	02028006 	srlv	s0,v0,s0
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif


	OpenCoreTimer(CORE_TICK_RATE);

9d001b20:	34049c40 	li	a0,0x9c40
9d001b24:	0f4009a6 	jal	9d002698 <OpenCoreTimer>
9d001b28:	af90817c 	sw	s0,-32388(gp)
	// set up the core timer interrupt with a prioirty of 2 and zero sub-priority
	mConfigIntCoreTimer(CT_INT_ON | _CT_IPL_IPC | (_CT_SPL_IPC << 4));

9d001b2c:	24020001 	li	v0,1
9d001b30:	3c05bf88 	lui	a1,0xbf88
9d001b34:	aca21034 	sw	v0,4148(a1)
9d001b38:	3c04bf88 	lui	a0,0xbf88
9d001b3c:	2405001c 	li	a1,28
9d001b40:	ac851094 	sw	a1,4244(a0)
9d001b44:	3c03bf88 	lui	v1,0xbf88
9d001b48:	24050008 	li	a1,8
9d001b4c:	ac651098 	sw	a1,4248(v1)
9d001b50:	24050003 	li	a1,3
9d001b54:	ac851094 	sw	a1,4244(a0)
9d001b58:	ac601098 	sw	zero,4248(v1)
9d001b5c:	3c03bf88 	lui	v1,0xbf88
9d001b60:	ac621064 	sw	v0,4196(v1)
9d001b64:	3c03bf88 	lui	v1,0xbf88
9d001b68:	0f4009b8 	jal	9d0026e0 <INTEnableSystemMultiVectoredInt>
	// enable multi-vector interrupts
	INTEnableSystemMultiVectoredInt();

9d001b6c:	ac621068 	sw	v0,4200(v1)

#ifdef _ENABLE_PIC_RTC_
	RtccInit();									// init the RTCC
//	while(RtccGetClkStat() != RTCC_CLK_ON);		// wait for the SOSC to be actually running and RTCC to have its clock source
9d001b70:	0f4009c5 	jal	9d002714 <RtccInit>
9d001b74:	00000000 	nop
void delay(unsigned long ms)
{
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d001b78:	8f838018 	lw	v1,-32744(gp)
	{
9d001b7c:	8f828018 	lw	v0,-32744(gp)
9d001b80:	00431023 	subu	v0,v0,v1
9d001b84:	2c420032 	sltiu	v0,v0,50
9d001b88:	1440fffc 	bnez	v0,9d001b7c <init+0xc0>
9d001b8c:	3c051101 	lui	a1,0x1101
												// could wait here at most 32ms

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 

	delay(50);
9d001b90:	3c101007 	lui	s0,0x1007
9d001b94:	26043000 	addiu	a0,s0,12288
9d001b98:	24a50901 	addiu	a1,a1,2305
9d001b9c:	0f400a13 	jal	9d00284c <RtccOpen>
9d001ba0:	00003021 	move	a2,zero
	// time is MSb: hour, min, sec, rsvd. date is MSb: year, mon, mday, wday.
9d001ba4:	3c051010 	lui	a1,0x1010
9d001ba8:	36043000 	ori	a0,s0,0x3000
9d001bac:	0f400a09 	jal	9d002824 <RtccSetTimeDate>
9d001bb0:	24a51701 	addiu	a1,a1,5889
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif


	//*	as per Al.Rodriguez@microchip.com, Jan 7, 2011
9d001bb4:	3c02bf81 	lui	v0,0xbf81
9d001bb8:	8c43f200 	lw	v1,-3584(v0)
	//* Initialize the periodic task manager
	_initTaskManager();

	//*	Issue #84
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
9d001bbc:	8fbf001c 	lw	ra,28(sp)
9d001bc0:	8fb10018 	lw	s1,24(sp)
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif


	//*	as per Al.Rodriguez@microchip.com, Jan 7, 2011
9d001bc4:	7c0318c4 	ins	v1,zero,0x3,0x1
9d001bc8:	ac43f200 	sw	v1,-3584(v0)
#endif

	//* Initialize the periodic task manager
	_initTaskManager();

	//*	Issue #84
9d001bcc:	34038000 	li	v1,0x8000
9d001bd0:	3c02bf80 	lui	v0,0xbf80
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
9d001bd4:	8fb00014 	lw	s0,20(sp)
#endif

	//* Initialize the periodic task manager
	_initTaskManager();

	//*	Issue #84
9d001bd8:	ac436004 	sw	v1,24580(v0)
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
9d001bdc:	03e00008 	jr	ra
9d001be0:	27bd0020 	addiu	sp,sp,32

9d001be4 <CoreTimerHandler>:
#endif
}



//************************************************************************
9d001be4:	415de800 	rdpgpr	sp,sp
9d001be8:	401a7000 	mfc0	k0,c0_epc
9d001bec:	401b6000 	mfc0	k1,c0_status
9d001bf0:	27bdff90 	addiu	sp,sp,-112
9d001bf4:	afbb0068 	sw	k1,104(sp)
9d001bf8:	7c1b7844 	ins	k1,zero,0x1,0xf
9d001bfc:	377b0800 	ori	k1,k1,0x800
9d001c00:	afba006c 	sw	k0,108(sp)
9d001c04:	409b6000 	mtc0	k1,c0_status
9d001c08:	afbf005c 	sw	ra,92(sp)
9d001c0c:	afb90058 	sw	t9,88(sp)
9d001c10:	afb80054 	sw	t8,84(sp)
9d001c14:	afb00050 	sw	s0,80(sp)
9d001c18:	afaf004c 	sw	t7,76(sp)
9d001c1c:	afae0048 	sw	t6,72(sp)
9d001c20:	afad0044 	sw	t5,68(sp)
9d001c24:	afac0040 	sw	t4,64(sp)
9d001c28:	afab003c 	sw	t3,60(sp)
9d001c2c:	afaa0038 	sw	t2,56(sp)
9d001c30:	afa90034 	sw	t1,52(sp)
9d001c34:	afa80030 	sw	t0,48(sp)
9d001c38:	afa7002c 	sw	a3,44(sp)
9d001c3c:	afa60028 	sw	a2,40(sp)
9d001c40:	afa50024 	sw	a1,36(sp)
9d001c44:	afa40020 	sw	a0,32(sp)
9d001c48:	afa3001c 	sw	v1,28(sp)
9d001c4c:	afa20018 	sw	v0,24(sp)
9d001c50:	afa10014 	sw	at,20(sp)
9d001c54:	00001012 	mflo	v0
9d001c58:	afa20064 	sw	v0,100(sp)
{
    unsigned int status = 0;

    asm volatile("ei    %0" : "=r"(status));

    return status;
9d001c5c:	8f828020 	lw	v0,-32736(gp)
#endif
}



//************************************************************************
9d001c60:	00001810 	mfhi	v1
//*	Interrupts are enabled by setting the IE bit in the status register
//************************************************************************
unsigned int __attribute__((nomips16))  INTEnableInterrupts(void)
{
    unsigned int status = 0;
9d001c64:	8f908018 	lw	s0,-32744(gp)

    asm volatile("ei    %0" : "=r"(status));

    return status;
9d001c68:	1040003d 	beqz	v0,9d001d60 <CoreTimerHandler+0x17c>
9d001c6c:	afa30060 	sw	v1,96(sp)
}

9d001c70:	0040f809 	jalr	v0
9d001c74:	00000000 	nop

//************************************************************************
//*	Interrupts are disabled by clearing the IE bit in the status register
9d001c78:	14400023 	bnez	v0,9d001d08 <CoreTimerHandler+0x124>
9d001c7c:	24030001 	li	v1,1
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.

    The rules:

    1.	You do NOT set “compare”!
    2.  Do not do anything that could cause CoreTimerHandler to be called recursively. For example, do not enable interrupts as the CT flag is still set
9d001c80:	3c02bf88 	lui	v0,0xbf88
9d001c84:	ac431034 	sw	v1,4148(v0)
        and will immeditely cause the system to call CoreTimerHandler.
9d001c88:	8fa50064 	lw	a1,100(sp)
9d001c8c:	8fbf005c 	lw	ra,92(sp)
9d001c90:	8fb90058 	lw	t9,88(sp)
9d001c94:	00a00013 	mtlo	a1
9d001c98:	8fa50060 	lw	a1,96(sp)
9d001c9c:	8fb80054 	lw	t8,84(sp)
9d001ca0:	8fb00050 	lw	s0,80(sp)
9d001ca4:	00a00011 	mthi	a1
9d001ca8:	8faf004c 	lw	t7,76(sp)
9d001cac:	8fae0048 	lw	t6,72(sp)
9d001cb0:	8fad0044 	lw	t5,68(sp)
9d001cb4:	8fac0040 	lw	t4,64(sp)
9d001cb8:	8fab003c 	lw	t3,60(sp)
9d001cbc:	8faa0038 	lw	t2,56(sp)
9d001cc0:	8fa90034 	lw	t1,52(sp)
9d001cc4:	8fa80030 	lw	t0,48(sp)
9d001cc8:	8fa7002c 	lw	a3,44(sp)
9d001ccc:	8fa60028 	lw	a2,40(sp)
9d001cd0:	8fa50024 	lw	a1,36(sp)
9d001cd4:	8fa40020 	lw	a0,32(sp)
9d001cd8:	8fa3001c 	lw	v1,28(sp)
9d001cdc:	8fa20018 	lw	v0,24(sp)
9d001ce0:	8fa10014 	lw	at,20(sp)
9d001ce4:	41606000 	di
9d001ce8:	000000c0 	ehb
9d001cec:	8fba006c 	lw	k0,108(sp)
9d001cf0:	8fbb0068 	lw	k1,104(sp)
9d001cf4:	409a7000 	mtc0	k0,c0_epc
9d001cf8:	27bd0070 	addiu	sp,sp,112
9d001cfc:	41dde800 	wrpgpr	sp,sp
9d001d00:	409b6000 	mtc0	k1,c0_status
9d001d04:	42000018 	eret
    return status;
}


//************************************************************************
//*	Interrupts are disabled by clearing the IE bit in the status register
9d001d08:	8f898020 	lw	t1,-32736(gp)
9d001d0c:	8f828024 	lw	v0,-32732(gp)
}



//************************************************************************
//*	CoreTimerHandler Services (KeithV)
9d001d10:	3c080013 	lui	t0,0x13
//************************************************************************
unsigned int __attribute__((nomips16)) INTDisableInterrupts(void)
{
    unsigned int status = 0;

    asm volatile("di    %0" : "=r"(status));
9d001d14:	34049c40 	li	a0,0x9c40
}



//************************************************************************
//*	CoreTimerHandler Services (KeithV)
9d001d18:	35088801 	ori	t0,t0,0x8801
//************************************************************************
//*	Interrupts are disabled by clearing the IE bit in the status register
//************************************************************************
unsigned int __attribute__((nomips16)) INTDisableInterrupts(void)
{
    unsigned int status = 0;
9d001d1c:	26100001 	addiu	s0,s0,1

9d001d20:	40034800 	mfc0	v1,c0_count
    asm volatile("di    %0" : "=r"(status));
9d001d24:	00441021 	addu	v0,v0,a0
    return status;
}



//************************************************************************
9d001d28:	0044282b 	sltu	a1,v0,a0
/*
    uint32_t CoreTimerService(uint32_t count)

    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
9d001d2c:	0043302b 	sltu	a2,v0,v1
    return status;
}



//************************************************************************
9d001d30:	10a00003 	beqz	a1,9d001d40 <CoreTimerHandler+0x15c>
9d001d34:	0068382b 	sltu	a3,v1,t0
//*	CoreTimerHandler Services (KeithV)
9d001d38:	10e00003 	beqz	a3,9d001d48 <CoreTimerHandler+0x164>
9d001d3c:	00000000 	nop
/*
    uint32_t CoreTimerService(uint32_t count)

    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
9d001d40:	54c0fff7 	bnezl	a2,9d001d20 <CoreTimerHandler+0x13c>
9d001d44:	26100001 	addiu	s0,s0,1
    register your callback serivce it should be called within 1 ms of attaching (registering). In some cases if interrupts are diaabled it may be as 
    long as 50 ms before your first call is made. Passed in to your Service is the current value of the CoreTimer count register, this is a rolling count 
9d001d48:	11200007 	beqz	t1,9d001d68 <CoreTimerHandler+0x184>
9d001d4c:	af828024 	sw	v0,-32732(gp)
    that rolls once every 2^32 / 40000000 ~ 107seconds. The return value from your service should be the next value of count that you want to be notified; 
    logically like setting the compare register; however, CoreTimerHandler is managing several services and will notify you when your value has been hit. 
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.
9d001d50:	af83801c 	sw	v1,-32740(gp)

9d001d54:	af908018 	sw	s0,-32744(gp)
    The rules:

    1.	You do NOT set “compare”!
    2.  Do not do anything that could cause CoreTimerHandler to be called recursively. For example, do not enable interrupts as the CT flag is still set
9d001d58:	0b400720 	j	9d001c80 <CoreTimerHandler+0x9c>
9d001d5c:	24030001 	li	v1,1
{
    unsigned int status = 0;

    asm volatile("ei    %0" : "=r"(status));

    return status;
9d001d60:	0b400743 	j	9d001d0c <CoreTimerHandler+0x128>
9d001d64:	00004821 	move	t1,zero
    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
    register your callback serivce it should be called within 1 ms of attaching (registering). In some cases if interrupts are diaabled it may be as 
    long as 50 ms before your first call is made. Passed in to your Service is the current value of the CoreTimer count register, this is a rolling count 
    that rolls once every 2^32 / 40000000 ~ 107seconds. The return value from your service should be the next value of count that you want to be notified; 
9d001d68:	40825800 	mtc0	v0,c0_compare
    logically like setting the compare register; however, CoreTimerHandler is managing several services and will notify you when your value has been hit. 
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.
9d001d6c:	af83801c 	sw	v1,-32740(gp)
    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
    register your callback serivce it should be called within 1 ms of attaching (registering). In some cases if interrupts are diaabled it may be as 
    long as 50 ms before your first call is made. Passed in to your Service is the current value of the CoreTimer count register, this is a rolling count 
    that rolls once every 2^32 / 40000000 ~ 107seconds. The return value from your service should be the next value of count that you want to be notified; 
9d001d70:	af828024 	sw	v0,-32732(gp)
    logically like setting the compare register; however, CoreTimerHandler is managing several services and will notify you when your value has been hit. 
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.

9d001d74:	af908018 	sw	s0,-32744(gp)
    The rules:

    1.	You do NOT set “compare”!
    2.  Do not do anything that could cause CoreTimerHandler to be called recursively. For example, do not enable interrupts as the CT flag is still set
9d001d78:	0b400720 	j	9d001c80 <CoreTimerHandler+0x9c>
9d001d7c:	24030001 	li	v1,1

9d001d80 <INTEnableInterrupts>:
    5.	Unfortunately, because of things like the EEProm writes, you can be called late and you must “catch-up” however best you can and return 
        the next requested “compare” time on your next call.
    6.	There are limits to how far in the future you can set your next "compare" time. Right now this is limited to 90 seconds. If you need a longer delay you
        should be using something other than a CoreTimer Services to do this. You probably should really limit your next "compare" time to less than few seconds.
    7.	Your next requested “compare” time MUST be equal to or after (in time) the “current” time as passed in to you. You may add up to 90 seconds to the 
        current time, even if this causes uint32 wrap; but do not subtract from the current time and return that. There is a region known to CoreTimerHandler 
9d001d80:	03e00008 	jr	ra
        that is before the current time, but that uint32 "value" is after the current time + 90 seconds.
     8.	CoreTimerHandler will keep looping until count is less than whatever the next compare is “after” CT was cleared to insure that CT is not missed. 
        It is possible that you could be called a second time before exiting the CoreTimerHandler ISR if you request a new compare time that is very close to 
9d001d84:	41626020 	ei	v0

9d001d88 <INTDisableInterrupts>:
    10. Understand, your callback is being called while executing inside the CoreTimerHandler ISR. Your code should be as fast as possible. If too much
        time is taken, the ISR may never exit and no sketch will ever run!
*/
//************************************************************************
#define read_count(dest) __asm__ __volatile__("mfc0 %0,$9" : "=r" (dest))
#define read_comp(dest) __asm__ __volatile__("mfc0 %0,$11" : "=r" (dest))
9d001d88:	03e00008 	jr	ra
#define write_comp(src) __asm__ __volatile__("mtc0 %0,$11" : : "r" (src))

#define mCTSetIntFlag() (IFS0SET = _IFS0_CTIF_MASK)
9d001d8c:	41626000 	di	v0

9d001d90 <analogRead>:
//*	only one result will be read with that value being mirrored in the second result.
//*	I commented out the code using the Microchip PIC32 Peripheral Libraries and substituted 
//*	direct writes to the registers as shown below. This fixed all problems and works great:
//*********************************************************************
int analogRead(uint8_t pin)
{
9d001d90:	308400ff 	andi	a0,a0,0xff
9d001d94:	27bdffe0 	addiu	sp,sp,-32

	/* Pin number is allowed to be either the digital pin number or the
	** analog pin number. Map the input so that it is guaranteed to be
	** an analog pin number.
	*/
	pin = (pin < NUM_DIGITAL_PINS) ? digitalPinToAnalog(pin) : NOT_ANALOG_PIN;
9d001d98:	2c83002f 	sltiu	v1,a0,47
//*	only one result will be read with that value being mirrored in the second result.
//*	I commented out the code using the Microchip PIC32 Peripheral Libraries and substituted 
//*	direct writes to the registers as shown below. This fixed all problems and works great:
//*********************************************************************
int analogRead(uint8_t pin)
{
9d001d9c:	afbf001c 	sw	ra,28(sp)
9d001da0:	afb10018 	sw	s1,24(sp)
9d001da4:	afb00014 	sw	s0,20(sp)

	/* Pin number is allowed to be either the digital pin number or the
	** analog pin number. Map the input so that it is guaranteed to be
	** an analog pin number.
	*/
	pin = (pin < NUM_DIGITAL_PINS) ? digitalPinToAnalog(pin) : NOT_ANALOG_PIN;
9d001da8:	10600028 	beqz	v1,9d001e4c <analogRead+0xbc>
9d001dac:	00001021 	move	v0,zero
9d001db0:	2c83000c 	sltiu	v1,a0,12
9d001db4:	5060002a 	beqzl	v1,9d001e60 <analogRead+0xd0>
9d001db8:	2484fff2 	addiu	a0,a0,-14

	/* Map the analog pin number to the correct analog mux channel in the
	** A/D converter. In some cases this is a direct mapping. In that case,
	** the conversion macro just returns it parameter.
	*/
	channelNumber = analogInPinToChannel(pin);
9d001dbc:	3c029d00 	lui	v0,0x9d00
9d001dc0:	24422d88 	addiu	v0,v0,11656
9d001dc4:	00822021 	addu	a0,a0,v0

	/* Ensure that the pin associated with the analog channel is in analog
	** input mode, and select the channel in the input mux.
	*/
	AD1PCFG = ~(1 << channelNumber);
9d001dc8:	90850000 	lbu	a1,0(a0)
9d001dcc:	24060001 	li	a2,1
9d001dd0:	3c03bf81 	lui	v1,0xbf81
9d001dd4:	00a63004 	sllv	a2,a2,a1
9d001dd8:	00063027 	nor	a2,zero,a2
9d001ddc:	ac669060 	sw	a2,-28576(v1)
	AD1CHS = (channelNumber & 0xFFFF) << 16;
9d001de0:	00052c00 	sll	a1,a1,0x10
9d001de4:	3c03bf81 	lui	v1,0xbf81
9d001de8:	ac659040 	sw	a1,-28608(v1)
	AD1CON1	=	0; //Ends sampling, and starts converting
9d001dec:	3c10bf81 	lui	s0,0xbf81

	//Set up for manual sampling
	AD1CSSL	=	0;
9d001df0:	3c03bf81 	lui	v1,0xbf81
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
	AD1CON2	=	analog_reference;
9d001df4:	8f858028 	lw	a1,-32728(gp)
	/* Ensure that the pin associated with the analog channel is in analog
	** input mode, and select the channel in the input mux.
	*/
	AD1PCFG = ~(1 << channelNumber);
	AD1CHS = (channelNumber & 0xFFFF) << 16;
	AD1CON1	=	0; //Ends sampling, and starts converting
9d001df8:	ae009000 	sw	zero,-28672(s0)

	//Set up for manual sampling
	AD1CSSL	=	0;
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
9d001dfc:	24110002 	li	s1,2
	AD1PCFG = ~(1 << channelNumber);
	AD1CHS = (channelNumber & 0xFFFF) << 16;
	AD1CON1	=	0; //Ends sampling, and starts converting

	//Set up for manual sampling
	AD1CSSL	=	0;
9d001e00:	ac609050 	sw	zero,-28592(v1)
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
9d001e04:	3c03bf81 	lui	v1,0xbf81
9d001e08:	ac719020 	sw	s1,-28640(v1)
	AD1CON2	=	analog_reference;
9d001e0c:	3c03bf81 	lui	v1,0xbf81

	//Turn on ADC
	AD1CON1SET	=	0x8000;
9d001e10:	3c02bf81 	lui	v0,0xbf81
	AD1CON1	=	0; //Ends sampling, and starts converting

	//Set up for manual sampling
	AD1CSSL	=	0;
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
	AD1CON2	=	analog_reference;
9d001e14:	ac659010 	sw	a1,-28656(v1)
	
	//Start sampling
	AD1CON1SET	=	0x0002;
	
	//Delay for a bit
	delayMicroseconds(2);
9d001e18:	24040002 	li	a0,2
	AD1CSSL	=	0;
	AD1CON3	=	0x0002;	//Tad = internal 6 Tpb
	AD1CON2	=	analog_reference;

	//Turn on ADC
	AD1CON1SET	=	0x8000;
9d001e1c:	34038000 	li	v1,0x8000
9d001e20:	ac439008 	sw	v1,-28664(v0)
	
	//Start sampling
	AD1CON1SET	=	0x0002;
9d001e24:	ac519008 	sw	s1,-28664(v0)
	
	//Delay for a bit
	delayMicroseconds(2);
9d001e28:	0f40069e 	jal	9d001a78 <delayMicroseconds>
9d001e2c:	00000000 	nop

	//Start conversion
	AD1CON1CLR	=	0x0002;
9d001e30:	3c02bf81 	lui	v0,0xbf81
9d001e34:	ac519004 	sw	s1,-28668(v0)
	
	//Wait for conversion to finish
	while (!(AD1CON1 & 0x0001));
9d001e38:	8e029000 	lw	v0,-28672(s0)
9d001e3c:	30420001 	andi	v0,v0,0x1
9d001e40:	1040fffd 	beqz	v0,9d001e38 <analogRead+0xa8>
9d001e44:	3c02bf81 	lui	v0,0xbf81
	

	//Read the ADC Value
	analogValue	=	ADC1BUF0;
9d001e48:	8c429070 	lw	v0,-28560(v0)
	
	return (analogValue);
}
9d001e4c:	8fbf001c 	lw	ra,28(sp)
9d001e50:	8fb10018 	lw	s1,24(sp)
9d001e54:	8fb00014 	lw	s0,20(sp)
9d001e58:	03e00008 	jr	ra
9d001e5c:	27bd0020 	addiu	sp,sp,32

	/* Pin number is allowed to be either the digital pin number or the
	** analog pin number. Map the input so that it is guaranteed to be
	** an analog pin number.
	*/
	pin = (pin < NUM_DIGITAL_PINS) ? digitalPinToAnalog(pin) : NOT_ANALOG_PIN;
9d001e60:	308400ff 	andi	a0,a0,0xff
9d001e64:	2c83000c 	sltiu	v1,a0,12
9d001e68:	5460ffd5 	bnezl	v1,9d001dc0 <analogRead+0x30>
9d001e6c:	3c029d00 	lui	v0,0x9d00

	//Read the ADC Value
	analogValue	=	ADC1BUF0;
	
	return (analogValue);
}
9d001e70:	8fbf001c 	lw	ra,28(sp)
9d001e74:	8fb10018 	lw	s1,24(sp)
9d001e78:	8fb00014 	lw	s0,20(sp)
9d001e7c:	03e00008 	jr	ra
9d001e80:	27bd0020 	addiu	sp,sp,32

9d001e84 <_ZN14HardwareSerial9availableEv>:
**		receive buffer.
*/

int HardwareSerial::available(void)
{
	return (RX_BUFFER_SIZE + rx_buffer.head - rx_buffer.tail) % RX_BUFFER_SIZE;
9d001e84:	8c8200a0 	lw	v0,160(a0)
9d001e88:	8c8300a4 	lw	v1,164(a0)
9d001e8c:	24420080 	addiu	v0,v0,128
9d001e90:	00431023 	subu	v0,v0,v1
9d001e94:	00021fc3 	sra	v1,v0,0x1f
9d001e98:	00031e42 	srl	v1,v1,0x19
9d001e9c:	00431021 	addu	v0,v0,v1
9d001ea0:	3042007f 	andi	v0,v0,0x7f
}
9d001ea4:	03e00008 	jr	ra
9d001ea8:	00431023 	subu	v0,v0,v1

9d001eac <_ZN14HardwareSerial4peekEv>:
**		removing it from the buffer, or -1 if no characters are in the buffer.
*/

int HardwareSerial::peek()
{
	if (rx_buffer.head == rx_buffer.tail)
9d001eac:	8c8300a4 	lw	v1,164(a0)
9d001eb0:	8c8500a0 	lw	a1,160(a0)
9d001eb4:	10a30003 	beq	a1,v1,9d001ec4 <_ZN14HardwareSerial4peekEv+0x18>
9d001eb8:	2402ffff 	li	v0,-1
	{
		return -1;
	}
	else
	{
		return rx_buffer.buffer[rx_buffer.tail];
9d001ebc:	00832021 	addu	a0,a0,v1
9d001ec0:	90820020 	lbu	v0,32(a0)
	}
}
9d001ec4:	03e00008 	jr	ra
9d001ec8:	00000000 	nop

9d001ecc <_ZN14HardwareSerial4readEv>:
int HardwareSerial::read(void)
{
	unsigned char theChar;

	// if the head isn't ahead of the tail, we don't have any characters
	if (rx_buffer.head == rx_buffer.tail)
9d001ecc:	8c8300a4 	lw	v1,164(a0)
9d001ed0:	8c8500a0 	lw	a1,160(a0)
9d001ed4:	10a3000a 	beq	a1,v1,9d001f00 <_ZN14HardwareSerial4readEv+0x34>
9d001ed8:	2402ffff 	li	v0,-1
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d001edc:	24660001 	addiu	a2,v1,1
9d001ee0:	00062fc3 	sra	a1,a2,0x1f
9d001ee4:	00052e42 	srl	a1,a1,0x19
9d001ee8:	00c53021 	addu	a2,a2,a1
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d001eec:	00831821 	addu	v1,a0,v1
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d001ef0:	30c6007f 	andi	a2,a2,0x7f
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d001ef4:	90620020 	lbu	v0,32(v1)
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d001ef8:	00c52823 	subu	a1,a2,a1
9d001efc:	ac8500a4 	sw	a1,164(a0)
		return (theChar);
	}
}
9d001f00:	03e00008 	jr	ra
9d001f04:	00000000 	nop

9d001f08 <_ZN14HardwareSerial5flushEv>:
	// don't reverse this or there may be problems if the RX interrupt
	// occurs after reading the value of rx_buffer_head but before writing
	// the value to rx_buffer_tail; the previous value of rx_buffer_head
	// may be written to rx_buffer_tail, making it appear as if the buffer
	// were full, not empty.
	rx_buffer.head = rx_buffer.tail;
9d001f08:	8c8200a4 	lw	v0,164(a0)
}
9d001f0c:	03e00008 	jr	ra
9d001f10:	ac8200a0 	sw	v0,160(a0)

9d001f14 <_ZN14HardwareSerial5writeEh>:
**		Wait until the transmitter is idle, and then transmit the
**		specified character.
*/

void HardwareSerial::write(uint8_t theChar)
{
9d001f14:	8c820004 	lw	v0,4(a0)
9d001f18:	30a500ff 	andi	a1,a1,0xff

	while ((uart->uxSta.reg & (1 << _UARTSTA_TMRT)) == 0)	//check the TRMT bit
9d001f1c:	8c430010 	lw	v1,16(v0)
9d001f20:	30630100 	andi	v1,v1,0x100
9d001f24:	1060fffd 	beqz	v1,9d001f1c <_ZN14HardwareSerial5writeEh+0x8>
9d001f28:	00000000 	nop
		{
		//* wait for the transmitter to be clear
		}


	uart->uxTx.reg = theChar;
9d001f2c:	ac450020 	sw	a1,32(v0)
}
9d001f30:	03e00008 	jr	ra
9d001f34:	00000000 	nop

9d001f38 <_ZN14HardwareSerial5beginEm>:
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	flush();
9d001f38:	8c820000 	lw	v0,0(a0)
**		Initialize the UART for use, setting the baud rate to the
**		requested value, data size of 8-bits, and no parity.
*/

void HardwareSerial::begin(unsigned long baudRate)
{
9d001f3c:	27bdffe0 	addiu	sp,sp,-32
9d001f40:	afbf001c 	sw	ra,28(sp)
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	flush();
9d001f44:	8c420018 	lw	v0,24(v0)
**		Initialize the UART for use, setting the baud rate to the
**		requested value, data size of 8-bits, and no parity.
*/

void HardwareSerial::begin(unsigned long baudRate)
{
9d001f48:	afb00018 	sw	s0,24(sp)
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	flush();
9d001f4c:	afa50010 	sw	a1,16(sp)
9d001f50:	0040f809 	jalr	v0
9d001f54:	00808021 	move	s0,a0
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001f58:	8f82817c 	lw	v0,-32388(gp)
9d001f5c:	8fa50010 	lw	a1,16(sp)
	flush();

	/* Compute the address of the interrupt priority control
	** registers used by this UART
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);	//interrupt priority control reg set
9d001f60:	92080009 	lbu	t0,9(s0)
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001f64:	00021102 	srl	v0,v0,0x4
9d001f68:	0045001b 	divu	zero,v0,a1
9d001f6c:	00a001f4 	teq	a1,zero,0x7
	flush();

	/* Compute the address of the interrupt priority control
	** registers used by this UART
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);	//interrupt priority control reg set
9d001f70:	3c07bf88 	lui	a3,0xbf88
9d001f74:	00081882 	srl	v1,t0,0x2
9d001f78:	00031900 	sll	v1,v1,0x4

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this IRQ.
	*/
	irq_shift = 8 * (vec % 4);
9d001f7c:	31080003 	andi	t0,t0,0x3
	flush();

	/* Compute the address of the interrupt priority control
	** registers used by this UART
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);	//interrupt priority control reg set
9d001f80:	24e71090 	addiu	a3,a3,4240
9d001f84:	00e33821 	addu	a3,a3,v1

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this IRQ.
	*/
	irq_shift = 8 * (vec % 4);
9d001f88:	000840c0 	sll	t0,t0,0x3

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
9d001f8c:	2403001f 	li	v1,31
9d001f90:	01031804 	sllv	v1,v1,t0
9d001f94:	ace30004 	sw	v1,4(a3)
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001f98:	920a000a 	lbu	t2,10(s0)
9d001f9c:	920c000b 	lbu	t4,11(s0)

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001fa0:	8e040018 	lw	a0,24(s0)
9d001fa4:	8e06001c 	lw	a2,28(s0)
9d001fa8:	8e0b0014 	lw	t3,20(s0)

	iec->clr = bit_rx + bit_tx + bit_err;	//disable all interrupts
9d001fac:	8e030010 	lw	v1,16(s0)
	ipc->set = ((ipl << 2) + spl) << irq_shift;

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001fb0:	8e09000c 	lw	t1,12(s0)
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001fb4:	000a5080 	sll	t2,t2,0x2
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001fb8:	8e020004 	lw	v0,4(s0)
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001fbc:	014c5021 	addu	t2,t2,t4

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001fc0:	00863021 	addu	a2,a0,a2
9d001fc4:	00cb3021 	addu	a2,a2,t3
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001fc8:	010a4004 	sllv	t0,t2,t0
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
	uart->uxSta.reg = 0;
	uart->uxMode.reg = (1 << _UARTMODE_ON);			//enable UART module
	uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);	//enable transmitter and receiver

}
9d001fcc:	8fbf001c 	lw	ra,28(sp)
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001fd0:	ace80008 	sw	t0,8(a3)

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001fd4:	ad260004 	sw	a2,4(t1)

	iec->clr = bit_rx + bit_tx + bit_err;	//disable all interrupts
9d001fd8:	ac660004 	sw	a2,4(v1)
	iec->set = bit_rx;						//enable rx interrupts
9d001fdc:	ac640008 	sw	a0,8(v1)
	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
	uart->uxSta.reg = 0;
	uart->uxMode.reg = (1 << _UARTMODE_ON);			//enable UART module
9d001fe0:	34038000 	li	v1,0x8000
	uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);	//enable transmitter and receiver

}
9d001fe4:	8fb00018 	lw	s0,24(sp)
9d001fe8:	27bd0020 	addiu	sp,sp,32
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001fec:	00002812 	mflo	a1
9d001ff0:	24a5ffff 	addiu	a1,a1,-1
9d001ff4:	ac450040 	sw	a1,64(v0)
	uart->uxSta.reg = 0;
9d001ff8:	ac400010 	sw	zero,16(v0)
	uart->uxMode.reg = (1 << _UARTMODE_ON);			//enable UART module
9d001ffc:	ac430000 	sw	v1,0(v0)
	uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);	//enable transmitter and receiver
9d002000:	24031400 	li	v1,5120
9d002004:	ac430010 	sw	v1,16(v0)

}
9d002008:	03e00008 	jr	ra
9d00200c:	00000000 	nop

9d002010 <_ZN14HardwareSerial11doSerialIntEv>:
	uint8_t	ch;

	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
9d002010:	8c82000c 	lw	v0,12(a0)
9d002014:	8c830018 	lw	v1,24(a0)
9d002018:	8c450000 	lw	a1,0(v0)
9d00201c:	00652824 	and	a1,v1,a1
9d002020:	10a00010 	beqz	a1,9d002064 <_ZN14HardwareSerial11doSerialIntEv+0x54>
9d002024:	00000000 	nop
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d002028:	8c8700a0 	lw	a3,160(a0)
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d00202c:	8c890004 	lw	t1,4(a0)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d002030:	8c8800a4 	lw	t0,164(a0)
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d002034:	24e60001 	addiu	a2,a3,1
9d002038:	00062fc3 	sra	a1,a2,0x1f
9d00203c:	00052e42 	srl	a1,a1,0x19
9d002040:	00c53021 	addu	a2,a2,a1
9d002044:	30c6007f 	andi	a2,a2,0x7f
9d002048:	00c52823 	subu	a1,a2,a1
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d00204c:	8d260030 	lw	a2,48(t1)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d002050:	11050003 	beq	t0,a1,9d002060 <_ZN14HardwareSerial11doSerialIntEv+0x50>
9d002054:	00873821 	addu	a3,a0,a3
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d002058:	a0e60020 	sb	a2,32(a3)
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
		{
			rx_buffer.buffer[rx_buffer.head] = ch;
			rx_buffer.head = bufIndex;
9d00205c:	ac8500a0 	sw	a1,160(a0)
		}

		/* Clear the interrupt flag.
		*/
		ifs->clr = bit_rx;
9d002060:	ac430004 	sw	v1,4(v0)
	}

	/* If it's a transmit interrupt, ignore it, as we don't current
	** have interrupt driven i/o on the transmit side.
	*/
	if ((ifs->reg & bit_tx) != 0)
9d002064:	8c450000 	lw	a1,0(v0)
9d002068:	8c83001c 	lw	v1,28(a0)
9d00206c:	00652024 	and	a0,v1,a1
9d002070:	54800001 	bnezl	a0,9d002078 <_ZN14HardwareSerial11doSerialIntEv+0x68>
9d002074:	ac430004 	sw	v1,4(v0)
9d002078:	03e00008 	jr	ra
9d00207c:	00000000 	nop

9d002080 <IntSer0Handler>:
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __ISR(_SER0_VECTOR, _SER0_IPL_ISR) IntSer0Handler(void)
{
9d002080:	415de800 	rdpgpr	sp,sp
9d002084:	401a7000 	mfc0	k0,c0_epc
9d002088:	401b6000 	mfc0	k1,c0_status
9d00208c:	27bdff98 	addiu	sp,sp,-104
9d002090:	afbb0060 	sw	k1,96(sp)
9d002094:	7c1b7844 	ins	k1,zero,0x1,0xf
9d002098:	377b0800 	ori	k1,k1,0x800
9d00209c:	afba0064 	sw	k0,100(sp)
9d0020a0:	409b6000 	mtc0	k1,c0_status
9d0020a4:	afbf0054 	sw	ra,84(sp)
9d0020a8:	afb90050 	sw	t9,80(sp)
9d0020ac:	afb8004c 	sw	t8,76(sp)
9d0020b0:	afaf0048 	sw	t7,72(sp)
9d0020b4:	afae0044 	sw	t6,68(sp)
9d0020b8:	afad0040 	sw	t5,64(sp)
9d0020bc:	afac003c 	sw	t4,60(sp)
9d0020c0:	afab0038 	sw	t3,56(sp)
9d0020c4:	afaa0034 	sw	t2,52(sp)
9d0020c8:	afa90030 	sw	t1,48(sp)
9d0020cc:	afa8002c 	sw	t0,44(sp)
9d0020d0:	afa70028 	sw	a3,40(sp)
9d0020d4:	afa60024 	sw	a2,36(sp)
9d0020d8:	afa50020 	sw	a1,32(sp)
9d0020dc:	afa4001c 	sw	a0,28(sp)
9d0020e0:	afa30018 	sw	v1,24(sp)
9d0020e4:	afa20014 	sw	v0,20(sp)
9d0020e8:	afa10010 	sw	at,16(sp)
9d0020ec:	00001012 	mflo	v0
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
#else
	Serial.doSerialInt();
9d0020f0:	2784802c 	addiu	a0,gp,-32724
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __ISR(_SER0_VECTOR, _SER0_IPL_ISR) IntSer0Handler(void)
{
9d0020f4:	afa2005c 	sw	v0,92(sp)
9d0020f8:	00001810 	mfhi	v1
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
#else
	Serial.doSerialInt();
9d0020fc:	0f400804 	jal	9d002010 <_ZN14HardwareSerial11doSerialIntEv>
9d002100:	afa30058 	sw	v1,88(sp)
#endif
}
9d002104:	8fa5005c 	lw	a1,92(sp)
9d002108:	8fbf0054 	lw	ra,84(sp)
9d00210c:	8fb90050 	lw	t9,80(sp)
9d002110:	00a00013 	mtlo	a1
9d002114:	8fa50058 	lw	a1,88(sp)
9d002118:	8fb8004c 	lw	t8,76(sp)
9d00211c:	8faf0048 	lw	t7,72(sp)
9d002120:	00a00011 	mthi	a1
9d002124:	8fae0044 	lw	t6,68(sp)
9d002128:	8fad0040 	lw	t5,64(sp)
9d00212c:	8fac003c 	lw	t4,60(sp)
9d002130:	8fab0038 	lw	t3,56(sp)
9d002134:	8faa0034 	lw	t2,52(sp)
9d002138:	8fa90030 	lw	t1,48(sp)
9d00213c:	8fa8002c 	lw	t0,44(sp)
9d002140:	8fa70028 	lw	a3,40(sp)
9d002144:	8fa60024 	lw	a2,36(sp)
9d002148:	8fa50020 	lw	a1,32(sp)
9d00214c:	8fa4001c 	lw	a0,28(sp)
9d002150:	8fa30018 	lw	v1,24(sp)
9d002154:	8fa20014 	lw	v0,20(sp)
9d002158:	8fa10010 	lw	at,16(sp)
9d00215c:	41606000 	di
9d002160:	000000c0 	ehb
9d002164:	8fba0064 	lw	k0,100(sp)
9d002168:	8fbb0060 	lw	k1,96(sp)
9d00216c:	409a7000 	mtc0	k0,c0_epc
9d002170:	27bd0068 	addiu	sp,sp,104
9d002174:	41dde800 	wrpgpr	sp,sp
9d002178:	409b6000 	mtc0	k1,c0_status
9d00217c:	42000018 	eret

9d002180 <IntSer1Handler>:
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __ISR(_SER1_VECTOR, _SER1_IPL_ISR) IntSer1Handler(void)
{
9d002180:	415de800 	rdpgpr	sp,sp
9d002184:	401a7000 	mfc0	k0,c0_epc
9d002188:	401b6000 	mfc0	k1,c0_status
9d00218c:	27bdff98 	addiu	sp,sp,-104
9d002190:	afbb0060 	sw	k1,96(sp)
9d002194:	7c1b7844 	ins	k1,zero,0x1,0xf
9d002198:	377b0800 	ori	k1,k1,0x800
9d00219c:	afba0064 	sw	k0,100(sp)
9d0021a0:	409b6000 	mtc0	k1,c0_status
9d0021a4:	afbf0054 	sw	ra,84(sp)
9d0021a8:	afb90050 	sw	t9,80(sp)
9d0021ac:	afb8004c 	sw	t8,76(sp)
9d0021b0:	afaf0048 	sw	t7,72(sp)
9d0021b4:	afae0044 	sw	t6,68(sp)
9d0021b8:	afad0040 	sw	t5,64(sp)
9d0021bc:	afac003c 	sw	t4,60(sp)
9d0021c0:	afab0038 	sw	t3,56(sp)
9d0021c4:	afaa0034 	sw	t2,52(sp)
9d0021c8:	afa90030 	sw	t1,48(sp)
9d0021cc:	afa8002c 	sw	t0,44(sp)
9d0021d0:	afa70028 	sw	a3,40(sp)
9d0021d4:	afa60024 	sw	a2,36(sp)
9d0021d8:	afa50020 	sw	a1,32(sp)
9d0021dc:	afa4001c 	sw	a0,28(sp)
9d0021e0:	afa30018 	sw	v1,24(sp)
9d0021e4:	afa20014 	sw	v0,20(sp)
9d0021e8:	afa10010 	sw	at,16(sp)
9d0021ec:	00001012 	mflo	v0
	Serial1.doSerialInt();
9d0021f0:	278480d4 	addiu	a0,gp,-32556
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __ISR(_SER1_VECTOR, _SER1_IPL_ISR) IntSer1Handler(void)
{
9d0021f4:	afa2005c 	sw	v0,92(sp)
9d0021f8:	00001810 	mfhi	v1
	Serial1.doSerialInt();
9d0021fc:	0f400804 	jal	9d002010 <_ZN14HardwareSerial11doSerialIntEv>
9d002200:	afa30058 	sw	v1,88(sp)
}
9d002204:	8fa5005c 	lw	a1,92(sp)
9d002208:	8fbf0054 	lw	ra,84(sp)
9d00220c:	8fb90050 	lw	t9,80(sp)
9d002210:	00a00013 	mtlo	a1
9d002214:	8fa50058 	lw	a1,88(sp)
9d002218:	8fb8004c 	lw	t8,76(sp)
9d00221c:	8faf0048 	lw	t7,72(sp)
9d002220:	00a00011 	mthi	a1
9d002224:	8fae0044 	lw	t6,68(sp)
9d002228:	8fad0040 	lw	t5,64(sp)
9d00222c:	8fac003c 	lw	t4,60(sp)
9d002230:	8fab0038 	lw	t3,56(sp)
9d002234:	8faa0034 	lw	t2,52(sp)
9d002238:	8fa90030 	lw	t1,48(sp)
9d00223c:	8fa8002c 	lw	t0,44(sp)
9d002240:	8fa70028 	lw	a3,40(sp)
9d002244:	8fa60024 	lw	a2,36(sp)
9d002248:	8fa50020 	lw	a1,32(sp)
9d00224c:	8fa4001c 	lw	a0,28(sp)
9d002250:	8fa30018 	lw	v1,24(sp)
9d002254:	8fa20014 	lw	v0,20(sp)
9d002258:	8fa10010 	lw	at,16(sp)
9d00225c:	41606000 	di
9d002260:	000000c0 	ehb
9d002264:	8fba0064 	lw	k0,100(sp)
9d002268:	8fbb0060 	lw	k1,96(sp)
9d00226c:	409a7000 	mtc0	k0,c0_epc
9d002270:	27bd0068 	addiu	sp,sp,104
9d002274:	41dde800 	wrpgpr	sp,sp
9d002278:	409b6000 	mtc0	k1,c0_status
9d00227c:	42000018 	eret

9d002280 <_GLOBAL__I__ZN14HardwareSerialC2EP8p32_uartiiii>:
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d002280:	3c04bf88 	lui	a0,0xbf88
9d002284:	24841060 	addiu	a0,a0,4192
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
9d002288:	24020002 	li	v0,2
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
9d00228c:	3c06bf80 	lui	a2,0xbf80
**	Description:
**		Object constructor. Initialize member variables, and
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
9d002290:	3c039d00 	lui	v1,0x9d00
9d002294:	24632d6c 	addiu	v1,v1,11628
{
	uart = uartP;
9d002298:	24c96000 	addiu	t1,a2,24576
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d00229c:	24870010 	addiu	a3,a0,16
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d0022a0:	3c05bf88 	lui	a1,0xbf88
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
9d0022a4:	a3828036 	sb	v0,-32714(gp)
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d0022a8:	af84803c 	sw	a0,-32708(gp)
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
9d0022ac:	a38280de 	sb	v0,-32546(gp)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d0022b0:	3c040400 	lui	a0,0x400
9d0022b4:	24020100 	li	v0,256
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d0022b8:	24a51030 	addiu	a1,a1,4144
**	Description:
**		Object constructor. Initialize member variables, and
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
9d0022bc:	af83802c 	sw	v1,-32724(gp)
{
	uart = uartP;
9d0022c0:	af898030 	sw	t1,-32720(gp)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d0022c4:	af848040 	sw	a0,-32704(gp)
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d0022c8:	2409001a 	li	t1,26
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0022cc:	3c040800 	lui	a0,0x800
**	Description:
**		Object constructor. Initialize member variables, and
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
9d0022d0:	af8380d4 	sw	v1,-32556(gp)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d0022d4:	af8280e8 	sw	v0,-32536(gp)
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d0022d8:	24030028 	li	v1,40
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0022dc:	24020200 	li	v0,512
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
9d0022e0:	24c66200 	addiu	a2,a2,25088
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d0022e4:	24a80010 	addiu	t0,a1,16
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d0022e8:	a3898034 	sb	t1,-32716(gp)
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0022ec:	af848044 	sw	a0,-32700(gp)

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
9d0022f0:	24090018 	li	t1,24
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d0022f4:	3c041000 	lui	a0,0x1000
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d0022f8:	a38380dc 	sb	v1,-32548(gp)
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d0022fc:	af8280ec 	sw	v0,-32532(gp)

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
9d002300:	24030020 	li	v1,32
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d002304:	24020400 	li	v0,1024

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
9d002308:	a3898035 	sb	t1,-32715(gp)
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
	spl  = (uint8_t)splP;
9d00230c:	a3808037 	sb	zero,-32713(gp)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d002310:	af858038 	sw	a1,-32712(gp)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d002314:	af848048 	sw	a0,-32696(gp)
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
9d002318:	af8680d8 	sw	a2,-32552(gp)
	irq  = irqP;
	vec  = vecP;
9d00231c:	a38380dd 	sb	v1,-32547(gp)
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
	spl  = (uint8_t)splP;
9d002320:	a38080df 	sb	zero,-32545(gp)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d002324:	af8880e0 	sw	t0,-32544(gp)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d002328:	af8780e4 	sw	a3,-32540(gp)
#endif

#endif	//defined(_USB) && defined(_USE_USB_FOR_SERIAL_)

#if defined(_SER1_BASE)
HardwareSerial Serial1((p32_uart *)_SER1_BASE, _SER1_IRQ, _SER1_VECTOR, _SER1_IPL, _SER1_SPL);
9d00232c:	03e00008 	jr	ra
9d002330:	af8280f0 	sw	v0,-32528(gp)

9d002334 <_ZN5Print5writeEPKc>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
9d002334:	27bdffe0 	addiu	sp,sp,-32
9d002338:	afb10018 	sw	s1,24(sp)
9d00233c:	afb00014 	sw	s0,20(sp)
9d002340:	afbf001c 	sw	ra,28(sp)
9d002344:	00a08021 	move	s0,a1
	while (*str)
9d002348:	80a50000 	lb	a1,0(a1)
9d00234c:	10a0000a 	beqz	a1,9d002378 <_ZN5Print5writeEPKc+0x44>
9d002350:	00808821 	move	s1,a0
	{
		write(*str++);
9d002354:	8e220000 	lw	v0,0(s1)
9d002358:	30a500ff 	andi	a1,a1,0xff
9d00235c:	26100001 	addiu	s0,s0,1
9d002360:	8c420000 	lw	v0,0(v0)
9d002364:	0040f809 	jalr	v0
9d002368:	02202021 	move	a0,s1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
	while (*str)
9d00236c:	82050000 	lb	a1,0(s0)
9d002370:	54a0fff9 	bnezl	a1,9d002358 <_ZN5Print5writeEPKc+0x24>
9d002374:	8e220000 	lw	v0,0(s1)
	{
		write(*str++);
	}
}
9d002378:	8fbf001c 	lw	ra,28(sp)
9d00237c:	8fb10018 	lw	s1,24(sp)
9d002380:	8fb00014 	lw	s0,20(sp)
9d002384:	03e00008 	jr	ra
9d002388:	27bd0020 	addiu	sp,sp,32

9d00238c <_ZN5Print5writeEPKhm>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
9d00238c:	27bdffe0 	addiu	sp,sp,-32
9d002390:	afb20018 	sw	s2,24(sp)
9d002394:	afb10014 	sw	s1,20(sp)
9d002398:	afb00010 	sw	s0,16(sp)
9d00239c:	afbf001c 	sw	ra,28(sp)
9d0023a0:	00c08021 	move	s0,a2
9d0023a4:	00809021 	move	s2,a0
	while (size--)
9d0023a8:	10c0000a 	beqz	a2,9d0023d4 <_ZN5Print5writeEPKhm+0x48>
9d0023ac:	00a08821 	move	s1,a1
	{
		write(*buffer++);
9d0023b0:	8e420000 	lw	v0,0(s2)
9d0023b4:	92250000 	lbu	a1,0(s1)
9d0023b8:	2610ffff 	addiu	s0,s0,-1
9d0023bc:	8c420000 	lw	v0,0(v0)
9d0023c0:	02402021 	move	a0,s2
9d0023c4:	0040f809 	jalr	v0
9d0023c8:	26310001 	addiu	s1,s1,1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
	while (size--)
9d0023cc:	5600fff9 	bnezl	s0,9d0023b4 <_ZN5Print5writeEPKhm+0x28>
9d0023d0:	8e420000 	lw	v0,0(s2)
	{
		write(*buffer++);
	}
}
9d0023d4:	8fbf001c 	lw	ra,28(sp)
9d0023d8:	8fb20018 	lw	s2,24(sp)
9d0023dc:	8fb10014 	lw	s1,20(sp)
9d0023e0:	8fb00010 	lw	s0,16(sp)
9d0023e4:	03e00008 	jr	ra
9d0023e8:	27bd0020 	addiu	sp,sp,32

9d0023ec <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
{
9d0023ec:	27bdffc0 	addiu	sp,sp,-64
9d0023f0:	afb10038 	sw	s1,56(sp)
9d0023f4:	afb00034 	sw	s0,52(sp)
9d0023f8:	afbf003c 	sw	ra,60(sp)
9d0023fc:	00808021 	move	s0,a0
9d002400:	30c600ff 	andi	a2,a2,0xff
unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars.
unsigned long i = 0;

	if (n == 0)
9d002404:	10a00020 	beqz	a1,9d002488 <_ZN5Print11printNumberEmh+0x9c>
9d002408:	00008821 	move	s1,zero
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d00240c:	00a6001b 	divu	zero,a1,a2
9d002410:	00c001f4 	teq	a2,zero,0x7
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d002414:	27a40010 	addiu	a0,sp,16
9d002418:	00911021 	addu	v0,a0,s1
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d00241c:	26310001 	addiu	s1,s1,1
9d002420:	00001810 	mfhi	v1
9d002424:	00002812 	mflo	a1
	{
		print('0');
		return;
	}

	while (n > 0)
9d002428:	14a0fff8 	bnez	a1,9d00240c <_ZN5Print11printNumberEmh+0x20>
9d00242c:	a0430000 	sb	v1,0(v0)
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d002430:	12200011 	beqz	s1,9d002478 <_ZN5Print11printNumberEmh+0x8c>
9d002434:	8fbf003c 	lw	ra,60(sp)
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d002438:	27a30010 	addiu	v1,sp,16
9d00243c:	00711021 	addu	v0,v1,s1
		n /= base;
	}

	for (; i > 0; i--)
	{
		print((char) (buf[i - 1] < 10 ?
9d002440:	9042ffff 	lbu	v0,-1(v0)
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
9d002444:	24450030 	addiu	a1,v0,48
9d002448:	2c43000a 	sltiu	v1,v0,10
9d00244c:	7c052c20 	seb	a1,a1
9d002450:	14600002 	bnez	v1,9d00245c <_ZN5Print11printNumberEmh+0x70>
9d002454:	24420037 	addiu	v0,v0,55
9d002458:	7c022c20 	seb	a1,v0
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d00245c:	2631ffff 	addiu	s1,s1,-1
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002460:	02002021 	move	a0,s0
9d002464:	0f400929 	jal	9d0024a4 <_ZN5Print5printEli>
9d002468:	00003021 	move	a2,zero
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d00246c:	1620fff3 	bnez	s1,9d00243c <_ZN5Print11printNumberEmh+0x50>
9d002470:	27a30010 	addiu	v1,sp,16
	{
		print((char) (buf[i - 1] < 10 ?
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
	}
}
9d002474:	8fbf003c 	lw	ra,60(sp)
9d002478:	8fb10038 	lw	s1,56(sp)
9d00247c:	8fb00034 	lw	s0,52(sp)
9d002480:	03e00008 	jr	ra
9d002484:	27bd0040 	addiu	sp,sp,64
9d002488:	8fbf003c 	lw	ra,60(sp)
9d00248c:	8fb10038 	lw	s1,56(sp)
9d002490:	8fb00034 	lw	s0,52(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002494:	24050030 	li	a1,48
9d002498:	00003021 	move	a2,zero
9d00249c:	0b400929 	j	9d0024a4 <_ZN5Print5printEli>
9d0024a0:	27bd0040 	addiu	sp,sp,64

9d0024a4 <_ZN5Print5printEli>:
	print((unsigned long) n, base);
}

//************************************************************************
void Print::print(long n, int base)
{
9d0024a4:	27bdffe0 	addiu	sp,sp,-32
9d0024a8:	afb10018 	sw	s1,24(sp)
9d0024ac:	afb00014 	sw	s0,20(sp)
9d0024b0:	afbf001c 	sw	ra,28(sp)
9d0024b4:	00808821 	move	s1,a0
	if (base == 0)
9d0024b8:	10c00013 	beqz	a2,9d002508 <_ZN5Print5printEli+0x64>
9d0024bc:	00a08021 	move	s0,a1
	{
		write(n);
	}
	else if (base == 10)
9d0024c0:	2402000a 	li	v0,10
9d0024c4:	10c20006 	beq	a2,v0,9d0024e0 <_ZN5Print5printEli+0x3c>
9d0024c8:	8fbf001c 	lw	ra,28(sp)
	}
	else
	{
		printNumber(n, base);
	}
}
9d0024cc:	8fb10018 	lw	s1,24(sp)
9d0024d0:	8fb00014 	lw	s0,20(sp)
		}
		printNumber(n, 10);
	}
	else
	{
		printNumber(n, base);
9d0024d4:	30c600ff 	andi	a2,a2,0xff
9d0024d8:	0b4008fb 	j	9d0023ec <_ZN5Print11printNumberEmh>
9d0024dc:	27bd0020 	addiu	sp,sp,32
	{
		write(n);
	}
	else if (base == 10)
	{
		if (n < 0)
9d0024e0:	04a00011 	bltz	a1,9d002528 <_ZN5Print5printEli+0x84>
9d0024e4:	2405002d 	li	a1,45
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d0024e8:	02202021 	move	a0,s1
9d0024ec:	02002821 	move	a1,s0
	}
	else
	{
		printNumber(n, base);
	}
}
9d0024f0:	8fbf001c 	lw	ra,28(sp)
9d0024f4:	8fb10018 	lw	s1,24(sp)
9d0024f8:	8fb00014 	lw	s0,20(sp)
		if (n < 0)
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d0024fc:	2406000a 	li	a2,10
	}
	else
	{
		printNumber(n, base);
9d002500:	0b4008fb 	j	9d0023ec <_ZN5Print11printNumberEmh>
9d002504:	27bd0020 	addiu	sp,sp,32
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d002508:	8c820000 	lw	v0,0(a0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d00250c:	8fbf001c 	lw	ra,28(sp)
9d002510:	8fb10018 	lw	s1,24(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d002514:	8c590000 	lw	t9,0(v0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d002518:	8fb00014 	lw	s0,20(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d00251c:	30a500ff 	andi	a1,a1,0xff
9d002520:	03200008 	jr	t9
9d002524:	27bd0020 	addiu	sp,sp,32
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002528:	0f400929 	jal	9d0024a4 <_ZN5Print5printEli>
9d00252c:	00003021 	move	a2,zero
	else if (base == 10)
	{
		if (n < 0)
		{
			print('-');
			n = -n;
9d002530:	0b40093a 	j	9d0024e8 <_ZN5Print5printEli+0x44>
9d002534:	00108023 	negu	s0,s0

9d002538 <_ZN5Print7printlnEv>:
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d002538:	27bdffe8 	addiu	sp,sp,-24
9d00253c:	afb00010 	sw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002540:	2405000d 	li	a1,13
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d002544:	00808021 	move	s0,a0
9d002548:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d00254c:	0f400929 	jal	9d0024a4 <_ZN5Print5printEli>
9d002550:	00003021 	move	a2,zero
9d002554:	02002021 	move	a0,s0
//************************************************************************
void Print::println(void)
{
	print('\r');
	print('\n');
}
9d002558:	8fbf0014 	lw	ra,20(sp)
9d00255c:	8fb00010 	lw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002560:	2405000a 	li	a1,10
9d002564:	00003021 	move	a2,zero
9d002568:	0b400929 	j	9d0024a4 <_ZN5Print5printEli>
9d00256c:	27bd0018 	addiu	sp,sp,24

9d002570 <_ZN5Print7printlnEii>:
	println();
}

//************************************************************************
void Print::println(int n, int base)
{
9d002570:	27bdffe8 	addiu	sp,sp,-24
9d002574:	afb00010 	sw	s0,16(sp)
9d002578:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(int n, int base)
{
	print((long) n, base);
9d00257c:	0f400929 	jal	9d0024a4 <_ZN5Print5printEli>
9d002580:	00808021 	move	s0,a0

//************************************************************************
void Print::println(int n, int base)
{
	print(n, base);
	println();
9d002584:	02002021 	move	a0,s0
}
9d002588:	8fbf0014 	lw	ra,20(sp)
9d00258c:	8fb00010 	lw	s0,16(sp)

//************************************************************************
void Print::println(int n, int base)
{
	print(n, base);
	println();
9d002590:	0b40094e 	j	9d002538 <_ZN5Print7printlnEv>
9d002594:	27bd0018 	addiu	sp,sp,24

9d002598 <_general_exception_context>:
9d002598:	27bdffa8 	addiu	sp,sp,-88
9d00259c:	afa10004 	sw	at,4(sp)
9d0025a0:	afa20008 	sw	v0,8(sp)
9d0025a4:	afa3000c 	sw	v1,12(sp)
9d0025a8:	afa40010 	sw	a0,16(sp)
9d0025ac:	afa50014 	sw	a1,20(sp)
9d0025b0:	afa60018 	sw	a2,24(sp)
9d0025b4:	afa7001c 	sw	a3,28(sp)
9d0025b8:	afa80020 	sw	t0,32(sp)
9d0025bc:	afa90024 	sw	t1,36(sp)
9d0025c0:	afaa0028 	sw	t2,40(sp)
9d0025c4:	afab002c 	sw	t3,44(sp)
9d0025c8:	afac0030 	sw	t4,48(sp)
9d0025cc:	afad0034 	sw	t5,52(sp)
9d0025d0:	afae0038 	sw	t6,56(sp)
9d0025d4:	afaf003c 	sw	t7,60(sp)
9d0025d8:	afb80040 	sw	t8,64(sp)
9d0025dc:	afb90044 	sw	t9,68(sp)
9d0025e0:	afbf0048 	sw	ra,72(sp)
9d0025e4:	00004012 	mflo	t0
9d0025e8:	afa8004c 	sw	t0,76(sp)
9d0025ec:	00004010 	mfhi	t0
9d0025f0:	afa80050 	sw	t0,80(sp)
9d0025f4:	40046800 	mfc0	a0,c0_cause
9d0025f8:	40056000 	mfc0	a1,c0_status
9d0025fc:	0f40099a 	jal	9d002668 <_general_exception_handler>
9d002600:	00000000 	nop
9d002604:	8fa80050 	lw	t0,80(sp)
9d002608:	01000011 	mthi	t0
9d00260c:	8fa8004c 	lw	t0,76(sp)
9d002610:	01000013 	mtlo	t0
9d002614:	8fa10004 	lw	at,4(sp)
9d002618:	8fa20008 	lw	v0,8(sp)
9d00261c:	8fa3000c 	lw	v1,12(sp)
9d002620:	8fa40010 	lw	a0,16(sp)
9d002624:	8fa50014 	lw	a1,20(sp)
9d002628:	8fa60018 	lw	a2,24(sp)
9d00262c:	8fa7001c 	lw	a3,28(sp)
9d002630:	8fa80020 	lw	t0,32(sp)
9d002634:	8fa90024 	lw	t1,36(sp)
9d002638:	8faa0028 	lw	t2,40(sp)
9d00263c:	8fab002c 	lw	t3,44(sp)
9d002640:	8fac0030 	lw	t4,48(sp)
9d002644:	8fad0034 	lw	t5,52(sp)
9d002648:	8fae0038 	lw	t6,56(sp)
9d00264c:	8faf003c 	lw	t7,60(sp)
9d002650:	8fb80040 	lw	t8,64(sp)
9d002654:	8fb90044 	lw	t9,68(sp)
9d002658:	8fbf0048 	lw	ra,72(sp)
9d00265c:	27bd0058 	addiu	sp,sp,88
9d002660:	000000c0 	ehb
9d002664:	42000018 	eret

9d002668 <_general_exception_handler>:
9d002668:	0b40099a 	j	9d002668 <_general_exception_handler>
9d00266c:	00000000 	nop

9d002670 <_on_reset>:
9d002670:	03e00008 	jr	ra
9d002674:	00000000 	nop

9d002678 <_on_bootstrap>:
9d002678:	03e00008 	jr	ra
9d00267c:	00000000 	nop

9d002680 <_nmi_handler>:
9d002680:	401a6000 	mfc0	k0,c0_status
9d002684:	3c1bffbf 	lui	k1,0xffbf
9d002688:	377bffff 	ori	k1,k1,0xffff
9d00268c:	035bd024 	and	k0,k0,k1
9d002690:	409a6000 	mtc0	k0,c0_status
9d002694:	42000018 	eret

9d002698 <OpenCoreTimer>:
9d002698:	40804800 	mtc0	zero,c0_count
9d00269c:	03e00008 	jr	ra
9d0026a0:	40845800 	mtc0	a0,c0_compare

9d0026a4 <ReadCoreTimer>:
9d0026a4:	03e00008 	jr	ra
9d0026a8:	40024800 	mfc0	v0,c0_count

9d0026ac <CheKseg0CacheOn>:
9d0026ac:	2402fff8 	li	v0,-8
9d0026b0:	40038000 	mfc0	v1,c0_config
9d0026b4:	00621024 	and	v0,v1,v0
9d0026b8:	34420003 	ori	v0,v0,0x3
9d0026bc:	03e00008 	jr	ra
9d0026c0:	40828000 	mtc0	v0,c0_config

9d0026c4 <INTRestoreInterrupts>:
9d0026c4:	30840001 	andi	a0,a0,0x1
9d0026c8:	14800003 	bnez	a0,9d0026d8 <INTRestoreInterrupts+0x14>
9d0026cc:	00000000 	nop
9d0026d0:	03e00008 	jr	ra
9d0026d4:	41606000 	di
9d0026d8:	03e00008 	jr	ra
9d0026dc:	41606020 	ei

9d0026e0 <INTEnableSystemMultiVectoredInt>:
9d0026e0:	27bdffe8 	addiu	sp,sp,-24
9d0026e4:	afbf0014 	sw	ra,20(sp)
9d0026e8:	40036800 	mfc0	v1,c0_cause
9d0026ec:	3c020080 	lui	v0,0x80
9d0026f0:	00621025 	or	v0,v1,v0
9d0026f4:	40826800 	mtc0	v0,c0_cause
9d0026f8:	24031000 	li	v1,4096
9d0026fc:	3c02bf88 	lui	v0,0xbf88
9d002700:	0f400760 	jal	9d001d80 <INTEnableInterrupts>
9d002704:	ac431008 	sw	v1,4104(v0)
9d002708:	8fbf0014 	lw	ra,20(sp)
9d00270c:	03e00008 	jr	ra
9d002710:	27bd0018 	addiu	sp,sp,24

9d002714 <RtccInit>:
9d002714:	27bdffd8 	addiu	sp,sp,-40
9d002718:	00002821 	move	a1,zero
9d00271c:	24040036 	li	a0,54
9d002720:	afbf0024 	sw	ra,36(sp)
9d002724:	afb40020 	sw	s4,32(sp)
9d002728:	afb3001c 	sw	s3,28(sp)
9d00272c:	afb20018 	sw	s2,24(sp)
9d002730:	afb10014 	sw	s1,20(sp)
9d002734:	0f400a72 	jal	9d0029c8 <INTEnable>
9d002738:	afb00010 	sw	s0,16(sp)
9d00273c:	0f400762 	jal	9d001d88 <INTDisableInterrupts>
9d002740:	00000000 	nop
9d002744:	00402021 	move	a0,v0
9d002748:	3c02aa99 	lui	v0,0xaa99
9d00274c:	3c03bf81 	lui	v1,0xbf81
9d002750:	24426655 	addiu	v0,v0,26197
9d002754:	ac60f230 	sw	zero,-3536(v1)
9d002758:	ac62f230 	sw	v0,-3536(v1)
9d00275c:	3c025566 	lui	v0,0x5566
9d002760:	344299aa 	ori	v0,v0,0x99aa
9d002764:	ac62f230 	sw	v0,-3536(v1)
9d002768:	24140002 	li	s4,2
9d00276c:	3c02bf81 	lui	v0,0xbf81
9d002770:	ac54f008 	sw	s4,-4088(v0)
9d002774:	3c023333 	lui	v0,0x3333
9d002778:	3c11bf80 	lui	s1,0xbf80
9d00277c:	34108000 	li	s0,0x8000
9d002780:	24423333 	addiu	v0,v0,13107
9d002784:	3c13bf80 	lui	s3,0xbf80
9d002788:	24120008 	li	s2,8
9d00278c:	ae720208 	sw	s2,520(s3)
9d002790:	ac62f230 	sw	v0,-3536(v1)
9d002794:	0f4009b1 	jal	9d0026c4 <INTRestoreInterrupts>
9d002798:	00000000 	nop
9d00279c:	ae300204 	sw	s0,516(s1)
9d0027a0:	0f400af1 	jal	9d002bc4 <_RtccWaitClockOff>
9d0027a4:	00000000 	nop
9d0027a8:	3c02bf80 	lui	v0,0xbf80
9d0027ac:	24040036 	li	a0,54
9d0027b0:	ac500214 	sw	s0,532(v0)
9d0027b4:	0f400a67 	jal	9d00299c <INTClearFlag>
9d0027b8:	00000000 	nop
9d0027bc:	24020001 	li	v0,1
9d0027c0:	ae700208 	sw	s0,520(s3)
9d0027c4:	3c03bf81 	lui	v1,0xbf81
9d0027c8:	ae320204 	sw	s2,516(s1)
9d0027cc:	ae220204 	sw	v0,516(s1)
9d0027d0:	8c64f000 	lw	a0,-4096(v1)
9d0027d4:	30840002 	andi	a0,a0,0x2
9d0027d8:	1080000b 	beqz	a0,9d002808 <RtccInit+0xf4>
9d0027dc:	8fbf0024 	lw	ra,36(sp)
9d0027e0:	8c63f000 	lw	v1,-4096(v1)
9d0027e4:	7c630580 	ext	v1,v1,0x16,0x1
9d0027e8:	50600008 	beqzl	v1,9d00280c <RtccInit+0xf8>
9d0027ec:	8fb40020 	lw	s4,32(sp)
9d0027f0:	3c02bf80 	lui	v0,0xbf80
9d0027f4:	8c420200 	lw	v0,512(v0)
9d0027f8:	30420040 	andi	v0,v0,0x40
9d0027fc:	0002a00b 	movn	s4,zero,v0
9d002800:	02801021 	move	v0,s4
9d002804:	8fbf0024 	lw	ra,36(sp)
9d002808:	8fb40020 	lw	s4,32(sp)
9d00280c:	8fb3001c 	lw	s3,28(sp)
9d002810:	8fb20018 	lw	s2,24(sp)
9d002814:	8fb10014 	lw	s1,20(sp)
9d002818:	8fb00010 	lw	s0,16(sp)
9d00281c:	03e00008 	jr	ra
9d002820:	27bd0028 	addiu	sp,sp,40

9d002824 <RtccSetTimeDate>:
9d002824:	27bdffe8 	addiu	sp,sp,-24
9d002828:	afa40018 	sw	a0,24(sp)
9d00282c:	afa5001c 	sw	a1,28(sp)
9d002830:	27a40018 	addiu	a0,sp,24
9d002834:	afbf0014 	sw	ra,20(sp)
9d002838:	0f400a88 	jal	9d002a20 <_RtccSetTimeAndDate>
9d00283c:	27a5001c 	addiu	a1,sp,28
9d002840:	8fbf0014 	lw	ra,20(sp)
9d002844:	03e00008 	jr	ra
9d002848:	27bd0018 	addiu	sp,sp,24

9d00284c <RtccOpen>:
9d00284c:	27bdffc8 	addiu	sp,sp,-56
9d002850:	afb2001c 	sw	s2,28(sp)
9d002854:	afb10018 	sw	s1,24(sp)
9d002858:	00809021 	move	s2,a0
9d00285c:	00a08821 	move	s1,a1
9d002860:	24040036 	li	a0,54
9d002864:	00002821 	move	a1,zero
9d002868:	afbf0034 	sw	ra,52(sp)
9d00286c:	afb70030 	sw	s7,48(sp)
9d002870:	afb6002c 	sw	s6,44(sp)
9d002874:	afb50028 	sw	s5,40(sp)
9d002878:	afb40024 	sw	s4,36(sp)
9d00287c:	afb30020 	sw	s3,32(sp)
9d002880:	afb00014 	sw	s0,20(sp)
9d002884:	0f400a72 	jal	9d0029c8 <INTEnable>
9d002888:	00069c00 	sll	s3,a2,0x10
9d00288c:	0f400762 	jal	9d001d88 <INTDisableInterrupts>
9d002890:	00000000 	nop
9d002894:	00402021 	move	a0,v0
9d002898:	3c02aa99 	lui	v0,0xaa99
9d00289c:	3c03bf81 	lui	v1,0xbf81
9d0028a0:	24426655 	addiu	v0,v0,26197
9d0028a4:	ac60f230 	sw	zero,-3536(v1)
9d0028a8:	ac62f230 	sw	v0,-3536(v1)
9d0028ac:	3c025566 	lui	v0,0x5566
9d0028b0:	344299aa 	ori	v0,v0,0x99aa
9d0028b4:	ac62f230 	sw	v0,-3536(v1)
9d0028b8:	24170002 	li	s7,2
9d0028bc:	3c02bf81 	lui	v0,0xbf81
9d0028c0:	ac57f008 	sw	s7,-4088(v0)
9d0028c4:	3c023333 	lui	v0,0x3333
9d0028c8:	3c14bf80 	lui	s4,0xbf80
9d0028cc:	3c15bf80 	lui	s5,0xbf80
9d0028d0:	34108000 	li	s0,0x8000
9d0028d4:	24423333 	addiu	v0,v0,13107
9d0028d8:	24160008 	li	s6,8
9d0028dc:	aeb60208 	sw	s6,520(s5)
9d0028e0:	ac62f230 	sw	v0,-3536(v1)
9d0028e4:	0f4009b1 	jal	9d0026c4 <INTRestoreInterrupts>
9d0028e8:	00000000 	nop
9d0028ec:	ae900204 	sw	s0,516(s4)
9d0028f0:	0f400af1 	jal	9d002bc4 <_RtccWaitClockOff>
9d0028f4:	00000000 	nop
9d0028f8:	3c02bf80 	lui	v0,0xbf80
9d0028fc:	24040036 	li	a0,54
9d002900:	ac500214 	sw	s0,532(v0)
9d002904:	0f400a67 	jal	9d00299c <INTClearFlag>
9d002908:	00000000 	nop
9d00290c:	3c02bf80 	lui	v0,0xbf80
9d002910:	ac520220 	sw	s2,544(v0)
9d002914:	3c02bf80 	lui	v0,0xbf80
9d002918:	ac510230 	sw	s1,560(v0)
9d00291c:	3c0203ff 	lui	v0,0x3ff
9d002920:	ae820204 	sw	v0,516(s4)
9d002924:	24020001 	li	v0,1
9d002928:	aeb30208 	sw	s3,520(s5)
9d00292c:	3c03bf81 	lui	v1,0xbf81
9d002930:	aeb00208 	sw	s0,520(s5)
9d002934:	ae960204 	sw	s6,516(s4)
9d002938:	ae820204 	sw	v0,516(s4)
9d00293c:	8c64f000 	lw	a0,-4096(v1)
9d002940:	30840002 	andi	a0,a0,0x2
9d002944:	1080000b 	beqz	a0,9d002974 <RtccOpen+0x128>
9d002948:	8fbf0034 	lw	ra,52(sp)
9d00294c:	8c63f000 	lw	v1,-4096(v1)
9d002950:	7c630580 	ext	v1,v1,0x16,0x1
9d002954:	50600008 	beqzl	v1,9d002978 <RtccOpen+0x12c>
9d002958:	8fb70030 	lw	s7,48(sp)
9d00295c:	3c02bf80 	lui	v0,0xbf80
9d002960:	8c420200 	lw	v0,512(v0)
9d002964:	30420040 	andi	v0,v0,0x40
9d002968:	0002b80b 	movn	s7,zero,v0
9d00296c:	02e01021 	move	v0,s7
9d002970:	8fbf0034 	lw	ra,52(sp)
9d002974:	8fb70030 	lw	s7,48(sp)
9d002978:	8fb6002c 	lw	s6,44(sp)
9d00297c:	8fb50028 	lw	s5,40(sp)
9d002980:	8fb40024 	lw	s4,36(sp)
9d002984:	8fb30020 	lw	s3,32(sp)
9d002988:	8fb2001c 	lw	s2,28(sp)
9d00298c:	8fb10018 	lw	s1,24(sp)
9d002990:	8fb00014 	lw	s0,20(sp)
9d002994:	03e00008 	jr	ra
9d002998:	27bd0038 	addiu	sp,sp,56

9d00299c <INTClearFlag>:
9d00299c:	00041080 	sll	v0,a0,0x2
9d0029a0:	00042100 	sll	a0,a0,0x4
9d0029a4:	00822023 	subu	a0,a0,v0
9d0029a8:	3c029d00 	lui	v0,0x9d00
9d0029ac:	24422d94 	addiu	v0,v0,11668
9d0029b0:	00822021 	addu	a0,a0,v0
9d0029b4:	8c820000 	lw	v0,0(a0)
9d0029b8:	8c830008 	lw	v1,8(a0)
9d0029bc:	ac430004 	sw	v1,4(v0)
9d0029c0:	03e00008 	jr	ra
9d0029c4:	00000000 	nop

9d0029c8 <INTEnable>:
9d0029c8:	14a0000b 	bnez	a1,9d0029f8 <INTEnable+0x30>
9d0029cc:	00041080 	sll	v0,a0,0x2
9d0029d0:	00042100 	sll	a0,a0,0x4
9d0029d4:	00822023 	subu	a0,a0,v0
9d0029d8:	3c029d00 	lui	v0,0x9d00
9d0029dc:	24422d94 	addiu	v0,v0,11668
9d0029e0:	00442021 	addu	a0,v0,a0
9d0029e4:	8c820004 	lw	v0,4(a0)
9d0029e8:	8c830008 	lw	v1,8(a0)
9d0029ec:	ac430004 	sw	v1,4(v0)
9d0029f0:	03e00008 	jr	ra
9d0029f4:	00000000 	nop
9d0029f8:	00042100 	sll	a0,a0,0x4
9d0029fc:	00822023 	subu	a0,a0,v0
9d002a00:	3c029d00 	lui	v0,0x9d00
9d002a04:	24422d94 	addiu	v0,v0,11668
9d002a08:	00442021 	addu	a0,v0,a0
9d002a0c:	8c820004 	lw	v0,4(a0)
9d002a10:	8c830008 	lw	v1,8(a0)
9d002a14:	ac430008 	sw	v1,8(v0)
9d002a18:	03e00008 	jr	ra
9d002a1c:	00000000 	nop

9d002a20 <_RtccSetTimeAndDate>:
9d002a20:	27bdffd8 	addiu	sp,sp,-40
9d002a24:	afb30020 	sw	s3,32(sp)
9d002a28:	3c13bf80 	lui	s3,0xbf80
9d002a2c:	afb00014 	sw	s0,20(sp)
9d002a30:	8e700200 	lw	s0,512(s3)
9d002a34:	afb2001c 	sw	s2,28(sp)
9d002a38:	afb10018 	sw	s1,24(sp)
9d002a3c:	7e1000c0 	ext	s0,s0,0x3,0x1
9d002a40:	afbf0024 	sw	ra,36(sp)
9d002a44:	00808821 	move	s1,a0
9d002a48:	12000049 	beqz	s0,9d002b70 <_RtccSetTimeAndDate+0x150>
9d002a4c:	00a09021 	move	s2,a1
9d002a50:	8e620200 	lw	v0,512(s3)
9d002a54:	30428000 	andi	v0,v0,0x8000
9d002a58:	10400021 	beqz	v0,9d002ae0 <_RtccSetTimeAndDate+0xc0>
9d002a5c:	00000000 	nop
9d002a60:	0f400762 	jal	9d001d88 <INTDisableInterrupts>
9d002a64:	00000000 	nop
9d002a68:	3c03bf80 	lui	v1,0xbf80
9d002a6c:	8c630200 	lw	v1,512(v1)
9d002a70:	30630004 	andi	v1,v1,0x4
9d002a74:	1460002a 	bnez	v1,9d002b20 <_RtccSetTimeAndDate+0x100>
9d002a78:	3c03bf80 	lui	v1,0xbf80
9d002a7c:	8c640210 	lw	a0,528(v1)
9d002a80:	30848000 	andi	a0,a0,0x8000
9d002a84:	14800022 	bnez	a0,9d002b10 <_RtccSetTimeAndDate+0xf0>
9d002a88:	00000000 	nop
9d002a8c:	12200003 	beqz	s1,9d002a9c <_RtccSetTimeAndDate+0x7c>
9d002a90:	3c03bf80 	lui	v1,0xbf80
9d002a94:	8e240000 	lw	a0,0(s1)
9d002a98:	ac640220 	sw	a0,544(v1)
9d002a9c:	12400003 	beqz	s2,9d002aac <_RtccSetTimeAndDate+0x8c>
9d002aa0:	3c03bf80 	lui	v1,0xbf80
9d002aa4:	8e440000 	lw	a0,0(s2)
9d002aa8:	ac640230 	sw	a0,560(v1)
9d002aac:	0f4009b1 	jal	9d0026c4 <INTRestoreInterrupts>
9d002ab0:	00402021 	move	a0,v0
9d002ab4:	16000003 	bnez	s0,9d002ac4 <_RtccSetTimeAndDate+0xa4>
9d002ab8:	24030008 	li	v1,8
9d002abc:	3c02bf80 	lui	v0,0xbf80
9d002ac0:	ac430204 	sw	v1,516(v0)
9d002ac4:	8fbf0024 	lw	ra,36(sp)
9d002ac8:	8fb30020 	lw	s3,32(sp)
9d002acc:	8fb2001c 	lw	s2,28(sp)
9d002ad0:	8fb10018 	lw	s1,24(sp)
9d002ad4:	8fb00014 	lw	s0,20(sp)
9d002ad8:	03e00008 	jr	ra
9d002adc:	27bd0028 	addiu	sp,sp,40
9d002ae0:	0f400af1 	jal	9d002bc4 <_RtccWaitClockOff>
9d002ae4:	00000000 	nop
9d002ae8:	12200003 	beqz	s1,9d002af8 <_RtccSetTimeAndDate+0xd8>
9d002aec:	3c02bf80 	lui	v0,0xbf80
9d002af0:	8e230000 	lw	v1,0(s1)
9d002af4:	ac430220 	sw	v1,544(v0)
9d002af8:	1240ffee 	beqz	s2,9d002ab4 <_RtccSetTimeAndDate+0x94>
9d002afc:	3c02bf80 	lui	v0,0xbf80
9d002b00:	8e430000 	lw	v1,0(s2)
9d002b04:	ac430230 	sw	v1,560(v0)
9d002b08:	0b400aad 	j	9d002ab4 <_RtccSetTimeAndDate+0x94>
9d002b0c:	00000000 	nop
9d002b10:	8c630210 	lw	v1,528(v1)
9d002b14:	30630f00 	andi	v1,v1,0xf00
9d002b18:	1460ffdc 	bnez	v1,9d002a8c <_RtccSetTimeAndDate+0x6c>
9d002b1c:	00000000 	nop
9d002b20:	0f4009b1 	jal	9d0026c4 <INTRestoreInterrupts>
9d002b24:	00402021 	move	a0,v0
9d002b28:	34038000 	li	v1,0x8000
9d002b2c:	3c02bf80 	lui	v0,0xbf80
9d002b30:	ac430204 	sw	v1,516(v0)
9d002b34:	0f400af1 	jal	9d002bc4 <_RtccWaitClockOff>
9d002b38:	00000000 	nop
9d002b3c:	12200003 	beqz	s1,9d002b4c <_RtccSetTimeAndDate+0x12c>
9d002b40:	3c02bf80 	lui	v0,0xbf80
9d002b44:	8e230000 	lw	v1,0(s1)
9d002b48:	ac430220 	sw	v1,544(v0)
9d002b4c:	12400003 	beqz	s2,9d002b5c <_RtccSetTimeAndDate+0x13c>
9d002b50:	3c02bf80 	lui	v0,0xbf80
9d002b54:	8e430000 	lw	v1,0(s2)
9d002b58:	ac430230 	sw	v1,560(v0)
9d002b5c:	34038000 	li	v1,0x8000
9d002b60:	3c02bf80 	lui	v0,0xbf80
9d002b64:	ac430208 	sw	v1,520(v0)
9d002b68:	0b400aad 	j	9d002ab4 <_RtccSetTimeAndDate+0x94>
9d002b6c:	00000000 	nop
9d002b70:	0f400762 	jal	9d001d88 <INTDisableInterrupts>
9d002b74:	00000000 	nop
9d002b78:	00402021 	move	a0,v0
9d002b7c:	3c02aa99 	lui	v0,0xaa99
9d002b80:	3c03bf81 	lui	v1,0xbf81
9d002b84:	24426655 	addiu	v0,v0,26197
9d002b88:	ac60f230 	sw	zero,-3536(v1)
9d002b8c:	ac62f230 	sw	v0,-3536(v1)
9d002b90:	3c025566 	lui	v0,0x5566
9d002b94:	344299aa 	ori	v0,v0,0x99aa
9d002b98:	ac62f230 	sw	v0,-3536(v1)
9d002b9c:	24050008 	li	a1,8
9d002ba0:	3c02bf80 	lui	v0,0xbf80
9d002ba4:	ac450208 	sw	a1,520(v0)
9d002ba8:	3c023333 	lui	v0,0x3333
9d002bac:	24423333 	addiu	v0,v0,13107
9d002bb0:	ac62f230 	sw	v0,-3536(v1)
9d002bb4:	0f4009b1 	jal	9d0026c4 <INTRestoreInterrupts>
9d002bb8:	00000000 	nop
9d002bbc:	0b400a94 	j	9d002a50 <_RtccSetTimeAndDate+0x30>
9d002bc0:	00000000 	nop

9d002bc4 <_RtccWaitClockOff>:
9d002bc4:	27bdffd0 	addiu	sp,sp,-48
9d002bc8:	afb30020 	sw	s3,32(sp)
9d002bcc:	3c13bf81 	lui	s3,0xbf81
9d002bd0:	8e62f000 	lw	v0,-4096(s3)
9d002bd4:	afbf002c 	sw	ra,44(sp)
9d002bd8:	afb50028 	sw	s5,40(sp)
9d002bdc:	30420002 	andi	v0,v0,0x2
9d002be0:	afb40024 	sw	s4,36(sp)
9d002be4:	afb2001c 	sw	s2,28(sp)
9d002be8:	afb10018 	sw	s1,24(sp)
9d002bec:	1040001c 	beqz	v0,9d002c60 <_RtccWaitClockOff+0x9c>
9d002bf0:	afb00014 	sw	s0,20(sp)
9d002bf4:	3c02a000 	lui	v0,0xa000
9d002bf8:	8c520214 	lw	s2,532(v0)
9d002bfc:	3c140040 	lui	s4,0x40
9d002c00:	3c15bf80 	lui	s5,0xbf80
9d002c04:	12400016 	beqz	s2,9d002c60 <_RtccWaitClockOff+0x9c>
9d002c08:	3c11a000 	lui	s1,0xa000
9d002c0c:	8e62f000 	lw	v0,-4096(s3)
9d002c10:	00541024 	and	v0,v0,s4
9d002c14:	10400012 	beqz	v0,9d002c60 <_RtccWaitClockOff+0x9c>
9d002c18:	00000000 	nop
9d002c1c:	8ea20200 	lw	v0,512(s5)
9d002c20:	30420040 	andi	v0,v0,0x40
9d002c24:	1040000e 	beqz	v0,9d002c60 <_RtccWaitClockOff+0x9c>
9d002c28:	00000000 	nop
9d002c2c:	0f4009a9 	jal	9d0026a4 <ReadCoreTimer>
9d002c30:	00000000 	nop
9d002c34:	00408021 	move	s0,v0
9d002c38:	0f4009a9 	jal	9d0026a4 <ReadCoreTimer>
9d002c3c:	00000000 	nop
9d002c40:	8e230210 	lw	v1,528(s1)
9d002c44:	00501023 	subu	v0,v0,s0
9d002c48:	0043182b 	sltu	v1,v0,v1
9d002c4c:	1460fffa 	bnez	v1,9d002c38 <_RtccWaitClockOff+0x74>
9d002c50:	00000000 	nop
9d002c54:	2652ffff 	addiu	s2,s2,-1
9d002c58:	1640ffec 	bnez	s2,9d002c0c <_RtccWaitClockOff+0x48>
9d002c5c:	00000000 	nop
9d002c60:	8e63f000 	lw	v1,-4096(s3)
9d002c64:	30630002 	andi	v1,v1,0x2
9d002c68:	1060000b 	beqz	v1,9d002c98 <_RtccWaitClockOff+0xd4>
9d002c6c:	24020001 	li	v0,1
9d002c70:	3c03bf81 	lui	v1,0xbf81
9d002c74:	8c63f000 	lw	v1,-4096(v1)
9d002c78:	7c630580 	ext	v1,v1,0x16,0x1
9d002c7c:	10600007 	beqz	v1,9d002c9c <_RtccWaitClockOff+0xd8>
9d002c80:	8fbf002c 	lw	ra,44(sp)
9d002c84:	3c02bf80 	lui	v0,0xbf80
9d002c88:	8c430200 	lw	v1,512(v0)
9d002c8c:	24020002 	li	v0,2
9d002c90:	30630040 	andi	v1,v1,0x40
9d002c94:	0003100b 	movn	v0,zero,v1
9d002c98:	8fbf002c 	lw	ra,44(sp)
9d002c9c:	8fb50028 	lw	s5,40(sp)
9d002ca0:	8fb40024 	lw	s4,36(sp)
9d002ca4:	8fb30020 	lw	s3,32(sp)
9d002ca8:	8fb2001c 	lw	s2,28(sp)
9d002cac:	8fb10018 	lw	s1,24(sp)
9d002cb0:	8fb00014 	lw	s0,20(sp)
9d002cb4:	03e00008 	jr	ra
9d002cb8:	27bd0030 	addiu	sp,sp,48

9d002cbc <__do_global_ctors_aux>:
9d002cbc:	3c029d00 	lui	v0,0x9d00
9d002cc0:	8c422d54 	lw	v0,11604(v0)
9d002cc4:	27bdffe0 	addiu	sp,sp,-32
9d002cc8:	2403ffff 	li	v1,-1
9d002ccc:	afbf001c 	sw	ra,28(sp)
9d002cd0:	afb10018 	sw	s1,24(sp)
9d002cd4:	10430009 	beq	v0,v1,9d002cfc <__do_global_ctors_aux+0x40>
9d002cd8:	afb00014 	sw	s0,20(sp)
9d002cdc:	3c119d00 	lui	s1,0x9d00
9d002ce0:	26312d54 	addiu	s1,s1,11604
9d002ce4:	2410ffff 	li	s0,-1
9d002ce8:	0040f809 	jalr	v0
9d002cec:	2631fffc 	addiu	s1,s1,-4
9d002cf0:	8e220000 	lw	v0,0(s1)
9d002cf4:	1450fffc 	bne	v0,s0,9d002ce8 <__do_global_ctors_aux+0x2c>
9d002cf8:	00000000 	nop
9d002cfc:	8fbf001c 	lw	ra,28(sp)
9d002d00:	8fb10018 	lw	s1,24(sp)
9d002d04:	8fb00014 	lw	s0,20(sp)
9d002d08:	03e00008 	jr	ra
9d002d0c:	27bd0020 	addiu	sp,sp,32

Disassembly of section .init:

9d002d10 <_init>:
9d002d10:	27bdffe0 	addiu	sp,sp,-32
9d002d14:	afbf0014 	sw	ra,20(sp)
9d002d18:	0f4004b3 	jal	9d0012cc <frame_dummy>
9d002d1c:	00000000 	nop
9d002d20:	0f400b2f 	jal	9d002cbc <__do_global_ctors_aux>
9d002d24:	00000000 	nop
9d002d28:	8fbf0014 	lw	ra,20(sp)
9d002d2c:	03e00008 	jr	ra
9d002d30:	27bd0020 	addiu	sp,sp,32

Disassembly of section .fini:

9d002d34 <_fini>:
9d002d34:	27bdffe0 	addiu	sp,sp,-32
9d002d38:	afbf0014 	sw	ra,20(sp)
9d002d3c:	0f400484 	jal	9d001210 <__do_global_dtors_aux>
9d002d40:	00000000 	nop
9d002d44:	8fbf0014 	lw	ra,20(sp)
9d002d48:	03e00008 	jr	ra
9d002d4c:	27bd0020 	addiu	sp,sp,32

Disassembly of section .rodata:

9d002d64 <_ZTV14HardwareSerial>:
	...
9d002d6c:	9d001f14 9d002334 9d00238c 9d001e84     ....4#...#......
9d002d7c:	9d001ecc 9d001eac 9d001f08              ............

9d002d88 <analog_pin_to_channel_PGM>:
9d002d88:	0a080402 05030e0c 0f0d0b09              ............

9d002d94 <__IntSrcTbl>:
9d002d94:	bf881030 bf881060 00000001 bf881030     0...`.......0...
9d002da4:	bf881060 00000002 bf881030 bf881060     `.......0...`...
9d002db4:	00000004 bf881030 bf881060 00000008     ....0...`.......
9d002dc4:	bf881030 bf881060 00000080 bf881030     0...`.......0...
9d002dd4:	bf881060 00000800 bf881030 bf881060     `.......0...`...
9d002de4:	00008000 bf881030 bf881060 00080000     ....0...`.......
9d002df4:	bf881030 bf881060 00000010 bf881030     0...`.......0...
9d002e04:	bf881060 00000100 bf881030 bf881060     `.......0...`...
9d002e14:	00001000 bf881030 bf881060 00010000     ....0...`.......
9d002e24:	bf881030 bf881060 00100000 bf881030     0...`.......0...
9d002e34:	bf881060 00000020 bf881030 bf881060     `... ...0...`...
9d002e44:	00000200 bf881030 bf881060 00002000     ....0...`.... ..
9d002e54:	bf881030 bf881060 00020000 bf881030     0...`.......0...
9d002e64:	bf881060 00200000 bf881030 bf881060     `..... .0...`...
9d002e74:	00000040 bf881030 bf881060 00000400     @...0...`.......
9d002e84:	bf881030 bf881060 00004000 bf881030     0...`....@..0...
9d002e94:	bf881060 00040000 bf881030 bf881060     `.......0...`...
9d002ea4:	00400000 bf881040 bf881070 00000001     ..@.@...p.......
9d002eb4:	bf881030 bf881060 00800000 bf881040     0...`.......@...
9d002ec4:	bf881070 00000020 bf881030 bf881060     p... ...0...`...
9d002ed4:	01000000 bf881040 bf881070 00000040     ....@...p...@...
9d002ee4:	bf881030 bf881060 02000000 bf881040     0...`.......@...
9d002ef4:	bf881070 00000080 bf881030 bf881060     p.......0...`...
9d002f04:	03800000 bf881040 bf881070 000000e0     ....@...p.......
9d002f14:	bf881030 bf881060 04000000 bf881040     0...`.......@...
9d002f24:	bf881070 00000100 bf881030 bf881060     p.......0...`...
9d002f34:	08000000 bf881040 bf881070 00000200     ....@...p.......
9d002f44:	bf881030 bf881060 10000000 bf881040     0...`.......@...
9d002f54:	bf881070 00000400 bf881030 bf881060     p.......0...`...
9d002f64:	1c000000 bf881040 bf881070 00000700     ....@...p.......
9d002f74:	bf881030 bf881060 20000000 bf881040     0...`...... @...
9d002f84:	bf881070 00000800 bf881030 bf881060     p.......0...`...
9d002f94:	40000000 bf881040 bf881070 00001000     ...@@...p.......
9d002fa4:	bf881030 bf881060 80000000 bf881040     0...`.......@...
9d002fb4:	bf881070 00002000 bf881030 bf881060     p.... ..0...`...
9d002fc4:	e0000000 bf881040 bf881070 00003800     ....@...p....8..
9d002fd4:	bf881040 bf881070 00000002 bf881040     @...p.......@...
9d002fe4:	bf881070 00000004 bf881040 bf881070     p.......@...p...
9d002ff4:	00000008 bf881040 bf881070 00000010     ....@...p.......
9d003004:	bf881040 bf881070 00004000 bf881040     @...p....@..@...
9d003014:	bf881070 01000000 bf881040 bf881070     p.......@...p...
9d003024:	00008000 00000000 00000000 00000000     ................
	...

9d003094 <__IntVectorTbl>:
9d003094:	bf881090 00000000 00000002 bf881090     ................
9d0030a4:	00000008 0000000a bf881090 00000010     ................
9d0030b4:	00000012 bf881090 00000018 0000001a     ................
9d0030c4:	bf8810a0 00000018 0000001a bf8810b0     ................
9d0030d4:	00000018 0000001a bf8810c0 00000018     ................
9d0030e4:	0000001a bf8810d0 00000018 0000001a     ................
9d0030f4:	bf8810a0 00000000 00000002 bf8810b0     ................
9d003104:	00000000 00000002 bf8810c0 00000000     ................
9d003114:	00000002 bf8810d0 00000000 00000002     ................
9d003124:	bf8810e0 00000000 00000002 bf8810a0     ................
9d003134:	00000008 0000000a bf8810b0 00000008     ................
9d003144:	0000000a bf8810c0 00000008 0000000a     ................
9d003154:	bf8810d0 00000008 0000000a bf8810e0     ................
9d003164:	00000008 0000000a bf8810a0 00000010     ................
9d003174:	00000012 bf8810b0 00000010 00000012     ................
9d003184:	bf8810c0 00000010 00000012 bf8810d0     ................
9d003194:	00000010 00000012 bf8810e0 00000010     ................
9d0031a4:	00000012 bf8810e0 00000018 0000001a     ................
9d0031b4:	bf881100 00000018 0000001a bf8810f0     ................
9d0031c4:	00000000 00000002 bf881110 00000000     ................
9d0031d4:	00000002 bf8810f0 00000008 0000000a     ................
9d0031e4:	bf881110 00000008 0000000a bf8810f0     ................
9d0031f4:	00000010 00000012 bf8810f0 00000018     ................
9d003204:	0000001a bf881100 00000000 00000002     ................
9d003214:	bf881100 00000008 0000000a bf881100     ................
9d003224:	00000010 00000012 bf881110 00000010     ................
9d003234:	00000012 bf881110 00000018 0000001a     ................
	...
9d0032a4:	bf881140 00000000 00000002 00000000     @...............
	...
