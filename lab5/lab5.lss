
./lab5.elf:     file format elf32-tradlittlemips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00000010  9d001000  9d001000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .app_excpt    00000010  9d000180  9d000180  00000180  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .vector_0     00000008  9d000200  9d000200  00000200  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .vector_24    00000008  9d000500  9d000500  00000500  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .vector_32    00000008  9d000600  9d000600  00000600  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .startup      000001e0  9d001010  9d001010  00001010  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text         00001670  9d0011f0  9d0011f0  000011f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .init         00000024  9d002860  9d002860  00002860  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .fini         0000001c  9d002884  9d002884  00002884  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .ctors        0000000c  9d0028a0  9d0028a0  000028a0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .dtors        00000008  9d0028ac  9d0028ac  000028ac  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .rodata       0000054c  9d0028b4  9d0028b4  000028b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .dbg_data     00000200  a0000000  a0000000  00011800  2**0
                  CONTENTS
 13 .data         00000070  a0000200  9d002e00  00010200  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 14 .sdata        00000008  a0000270  9d002e70  00010270  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 15 .sbss         00000168  a0000278  9d002e78  00010278  2**2
                  ALLOC
 16 .bss          00000020  a00003e0  9d002e78  000103e0  2**2
                  ALLOC
 17 .heap         00000800  a0000400  9d002e78  00010400  2**0
                  ALLOC
 18 .stack        00000800  a0000c00  9d002e78  00010c00  2**0
                  ALLOC
 19 .comment      000000dc  00000000  00000000  00011a00  2**0
                  CONTENTS, READONLY
 20 .debug_aranges 000010d8  00000000  00000000  00011adc  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_pubnames 000019c5  00000000  00000000  00012bb4  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_info   0002b17b  00000000  00000000  00014579  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_abbrev 000079f3  00000000  00000000  0003f6f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_line   0000c2d5  00000000  00000000  000470e7  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_frame  00001ffc  00000000  00000000  000533bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_str    000053b4  00000000  00000000  000553b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_loc    0001bd9d  00000000  00000000  0005a76c  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .debug_pubtypes 00002b36  00000000  00000000  00076509  2**0
                  CONTENTS, READONLY, DEBUGGING
 29 .debug_ranges 00003810  00000000  00000000  0007903f  2**0
                  CONTENTS, READONLY, DEBUGGING
 30 .gnu.attributes 00000010  00000000  00000000  0007c84f  2**0
                  CONTENTS, READONLY
 31 .mdebug.abi32 00000000  a0001800  a0001800  00011800  2**0
                  CONTENTS, ALLOC, LOAD, DATA

Disassembly of section .reset:

9d001000 <_reset>:
9d001000:	3c1a9d00 	lui	k0,0x9d00
9d001004:	275a1010 	addiu	k0,k0,4112
9d001008:	03400008 	jr	k0
9d00100c:	00000000 	nop

Disassembly of section .app_excpt:

9d000180 <_gen_exception>:
9d000180:	3c1a9d00 	lui	k0,0x9d00
9d000184:	275a20e8 	addiu	k0,k0,8424
9d000188:	03400008 	jr	k0
9d00018c:	00000000 	nop

Disassembly of section .vector_0:

9d000200 <__vector_dispatch_0>:
9d000200:	0b400608 	j	9d001820 <CoreTimerHandler>
9d000204:	00000000 	nop

Disassembly of section .vector_24:

9d000500 <__vector_dispatch_24>:
9d000500:	0b4006f2 	j	9d001bc8 <IntSer0Handler>
9d000504:	00000000 	nop

Disassembly of section .vector_32:

9d000600 <__vector_dispatch_32>:
9d000600:	0b400732 	j	9d001cc8 <IntSer1Handler>
9d000604:	00000000 	nop

Disassembly of section .startup:

9d001010 <_startup>:
9d001010:	401a6000 	mfc0	k0,c0_status
9d001014:	7f5a04c0 	ext	k0,k0,0x13,0x1
9d001018:	13400005 	beqz	k0,9d001030 <_no_nmi>
9d00101c:	00000000 	nop
9d001020:	3c1a9d00 	lui	k0,0x9d00
9d001024:	275a21d0 	addiu	k0,k0,8656
9d001028:	03400008 	jr	k0
9d00102c:	00000000 	nop

9d001030 <_no_nmi>:
9d001030:	3c1da000 	lui	sp,0xa000
9d001034:	27bd4000 	addiu	sp,sp,16384
9d001038:	3c1ca001 	lui	gp,0xa001
9d00103c:	279c8260 	addiu	gp,gp,-32160
9d001040:	40096002 	mfc0	t1,c0_srsctl
9d001044:	01205820 	add	t3,t1,zero
9d001048:	7d2a1e80 	ext	t2,t1,0x1a,0x4
9d00104c:	7d494984 	ins	t1,t2,0x6,0x4
9d001050:	40896002 	mtc0	t1,c0_srsctl
9d001054:	41dce000 	wrpgpr	gp,gp
9d001058:	408b6002 	mtc0	t3,c0_srsctl
9d00105c:	3c089d00 	lui	t0,0x9d00
9d001060:	250821c0 	addiu	t0,t0,8640
9d001064:	0100f809 	jalr	t0
9d001068:	00000000 	nop
9d00106c:	3c08a000 	lui	t0,0xa000
9d001070:	25080278 	addiu	t0,t0,632
9d001074:	3c09a000 	lui	t1,0xa000
9d001078:	25290400 	addiu	t1,t1,1024
9d00107c:	10000006 	b	9d001098 <_bss_check>
9d001080:	00000000 	nop

9d001084 <_bss_init>:
9d001084:	ad000000 	sw	zero,0(t0)
9d001088:	ad000004 	sw	zero,4(t0)
9d00108c:	ad000008 	sw	zero,8(t0)
9d001090:	ad00000c 	sw	zero,12(t0)
9d001094:	25080010 	addiu	t0,t0,16

9d001098 <_bss_check>:
9d001098:	0109082b 	sltu	at,t0,t1
9d00109c:	1420fff9 	bnez	at,9d001084 <_bss_init>
9d0010a0:	00000000 	nop
9d0010a4:	3c089d00 	lui	t0,0x9d00
9d0010a8:	25082e00 	addiu	t0,t0,11776
9d0010ac:	3c09a000 	lui	t1,0xa000
9d0010b0:	25290200 	addiu	t1,t1,512
9d0010b4:	3c0aa000 	lui	t2,0xa000
9d0010b8:	254a0278 	addiu	t2,t2,632
9d0010bc:	10000005 	b	9d0010d4 <_init_check>
9d0010c0:	00000000 	nop

9d0010c4 <_init_data>:
9d0010c4:	8d0b0000 	lw	t3,0(t0)
9d0010c8:	ad2b0000 	sw	t3,0(t1)
9d0010cc:	25080004 	addiu	t0,t0,4
9d0010d0:	25290004 	addiu	t1,t1,4

9d0010d4 <_init_check>:
9d0010d4:	012a082b 	sltu	at,t1,t2
9d0010d8:	1420fffa 	bnez	at,9d0010c4 <_init_data>
9d0010dc:	00000000 	nop
9d0010e0:	3c090000 	lui	t1,0x0
9d0010e4:	25290000 	addiu	t1,t1,0
9d0010e8:	1120001d 	beqz	t1,9d001160 <_ramfunc_done>
9d0010ec:	00000000 	nop
9d0010f0:	3c089d00 	lui	t0,0x9d00
9d0010f4:	25082e78 	addiu	t0,t0,11896
9d0010f8:	3c09a000 	lui	t1,0xa000
9d0010fc:	25291800 	addiu	t1,t1,6144
9d001100:	3c0aa000 	lui	t2,0xa000
9d001104:	254a1800 	addiu	t2,t2,6144

9d001108 <_init_ramfunc>:
9d001108:	8d0b0000 	lw	t3,0(t0)
9d00110c:	ad2b0000 	sw	t3,0(t1)
9d001110:	25080004 	addiu	t0,t0,4
9d001114:	25290004 	addiu	t1,t1,4

9d001118 <_ramfunc_check>:
9d001118:	012a082b 	sltu	at,t1,t2
9d00111c:	1420fffa 	bnez	at,9d001108 <_init_ramfunc>
9d001120:	00000000 	nop
9d001124:	3c090000 	lui	t1,0x0
9d001128:	25291800 	addiu	t1,t1,6144
9d00112c:	3c0abf88 	lui	t2,0xbf88
9d001130:	254a2010 	addiu	t2,t2,8208
9d001134:	ad490000 	sw	t1,0(t2)
9d001138:	3c090000 	lui	t1,0x0
9d00113c:	25294000 	addiu	t1,t1,16384
9d001140:	3c0abf88 	lui	t2,0xbf88
9d001144:	254a2020 	addiu	t2,t2,8224
9d001148:	ad490000 	sw	t1,0(t2)
9d00114c:	3c090000 	lui	t1,0x0
9d001150:	25294000 	addiu	t1,t1,16384
9d001154:	3c0abf88 	lui	t2,0xbf88
9d001158:	254a2030 	addiu	t2,t2,8240
9d00115c:	ad490000 	sw	t1,0(t2)

9d001160 <_ramfunc_done>:
9d001160:	40804800 	mtc0	zero,c0_count
9d001164:	240affff 	li	t2,-1
9d001168:	408a5800 	mtc0	t2,c0_compare
9d00116c:	3c099d00 	lui	t1,0x9d00
9d001170:	25290000 	addiu	t1,t1,0
9d001174:	40897801 	mtc0	t1,c0_ebase
9d001178:	3c090000 	lui	t1,0x0
9d00117c:	25290001 	addiu	t1,t1,1
9d001180:	240a0000 	li	t2,0
9d001184:	7d2a4944 	ins	t2,t1,0x5,0x5
9d001188:	408a6001 	mtc0	t2,c0_intctl
9d00118c:	3c090080 	lui	t1,0x80
9d001190:	40896800 	mtc0	t1,c0_cause
9d001194:	40088000 	mfc0	t0,c0_config
9d001198:	7d090580 	ext	t1,t0,0x16,0x1
9d00119c:	00094c40 	sll	t1,t1,0x11
9d0011a0:	40086000 	mfc0	t0,c0_status
9d0011a4:	3c010058 	lui	at,0x58
9d0011a8:	01014024 	and	t0,t0,at
9d0011ac:	01284025 	or	t0,t1,t0
9d0011b0:	40886000 	mtc0	t0,c0_status
9d0011b4:	3c089d00 	lui	t0,0x9d00
9d0011b8:	250821c8 	addiu	t0,t0,8648
9d0011bc:	0100f809 	jalr	t0
9d0011c0:	00000000 	nop
9d0011c4:	40086000 	mfc0	t0,c0_status
9d0011c8:	3c01ffbf 	lui	at,0xffbf
9d0011cc:	3421ffff 	ori	at,at,0xffff
9d0011d0:	01014024 	and	t0,t0,at
9d0011d4:	40886000 	mtc0	t0,c0_status
9d0011d8:	30840000 	andi	a0,a0,0x0
9d0011dc:	30a50000 	andi	a1,a1,0x0
9d0011e0:	3c089d00 	lui	t0,0x9d00
9d0011e4:	250811f0 	addiu	t0,t0,4592
9d0011e8:	01000008 	jr	t0
9d0011ec:	00000000 	nop

Disassembly of section .text:

9d0011f0 <_main_entry>:
9d0011f0:	0f400a18 	jal	9d002860 <_text_end>
9d0011f4:	00000000 	nop
9d0011f8:	30840000 	andi	a0,a0,0x0
9d0011fc:	30a50000 	andi	a1,a1,0x0
9d001200:	0f4004ca 	jal	9d001328 <main>
9d001204:	00000000 	nop
9d001208:	1000fffd 	b	9d001200 <_main_entry+0x10>
9d00120c:	00000000 	nop

9d001210 <__do_global_dtors_aux>:
9d001210:	27bdffd8 	addiu	sp,sp,-40
9d001214:	afb2001c 	sw	s2,28(sp)
9d001218:	3c12a000 	lui	s2,0xa000
9d00121c:	924203e0 	lbu	v0,992(s2)
9d001220:	afbf0024 	sw	ra,36(sp)
9d001224:	afb30020 	sw	s3,32(sp)
9d001228:	afb10018 	sw	s1,24(sp)
9d00122c:	14400020 	bnez	v0,9d0012b0 <__do_global_dtors_aux+0xa0>
9d001230:	afb00014 	sw	s0,20(sp)
9d001234:	3c119d00 	lui	s1,0x9d00
9d001238:	3c109d00 	lui	s0,0x9d00
9d00123c:	3c13a000 	lui	s3,0xa000
9d001240:	263128ac 	addiu	s1,s1,10412
9d001244:	261028b0 	addiu	s0,s0,10416
9d001248:	8e6203e4 	lw	v0,996(s3)
9d00124c:	02118023 	subu	s0,s0,s1
9d001250:	00108083 	sra	s0,s0,0x2
9d001254:	2610ffff 	addiu	s0,s0,-1
9d001258:	0050182b 	sltu	v1,v0,s0
9d00125c:	5060000c 	beqzl	v1,9d001290 <__do_global_dtors_aux+0x80>
9d001260:	3c020000 	lui	v0,0x0
9d001264:	24420001 	addiu	v0,v0,1
9d001268:	00021880 	sll	v1,v0,0x2
9d00126c:	02231821 	addu	v1,s1,v1
9d001270:	8c630000 	lw	v1,0(v1)
9d001274:	0060f809 	jalr	v1
9d001278:	ae6203e4 	sw	v0,996(s3)
9d00127c:	8e6203e4 	lw	v0,996(s3)
9d001280:	0050182b 	sltu	v1,v0,s0
9d001284:	1460fff8 	bnez	v1,9d001268 <__do_global_dtors_aux+0x58>
9d001288:	24420001 	addiu	v0,v0,1
9d00128c:	3c020000 	lui	v0,0x0
9d001290:	24420000 	addiu	v0,v0,0
9d001294:	10400005 	beqz	v0,9d0012ac <__do_global_dtors_aux+0x9c>
9d001298:	24020001 	li	v0,1
9d00129c:	3c04a000 	lui	a0,0xa000
9d0012a0:	0c000000 	jal	90000000 <_bmxdudba_address+0x8fffc000>
9d0012a4:	24840200 	addiu	a0,a0,512
9d0012a8:	24020001 	li	v0,1
9d0012ac:	a24203e0 	sb	v0,992(s2)
9d0012b0:	8fbf0024 	lw	ra,36(sp)
9d0012b4:	8fb30020 	lw	s3,32(sp)
9d0012b8:	8fb2001c 	lw	s2,28(sp)
9d0012bc:	8fb10018 	lw	s1,24(sp)
9d0012c0:	8fb00014 	lw	s0,20(sp)
9d0012c4:	03e00008 	jr	ra
9d0012c8:	27bd0028 	addiu	sp,sp,40

9d0012cc <frame_dummy>:
9d0012cc:	3c020000 	lui	v0,0x0
9d0012d0:	27bdffe8 	addiu	sp,sp,-24
9d0012d4:	24420000 	addiu	v0,v0,0
9d0012d8:	10400006 	beqz	v0,9d0012f4 <frame_dummy+0x28>
9d0012dc:	afbf0014 	sw	ra,20(sp)
9d0012e0:	3c04a000 	lui	a0,0xa000
9d0012e4:	3c05a000 	lui	a1,0xa000
9d0012e8:	24840200 	addiu	a0,a0,512
9d0012ec:	0c000000 	jal	90000000 <_bmxdudba_address+0x8fffc000>
9d0012f0:	24a503e8 	addiu	a1,a1,1000
9d0012f4:	3c04a000 	lui	a0,0xa000
9d0012f8:	8c820200 	lw	v0,512(a0)
9d0012fc:	10400007 	beqz	v0,9d00131c <frame_dummy+0x50>
9d001300:	3c190000 	lui	t9,0x0
9d001304:	27390000 	addiu	t9,t9,0
9d001308:	13200004 	beqz	t9,9d00131c <frame_dummy+0x50>
9d00130c:	8fbf0014 	lw	ra,20(sp)
9d001310:	24840200 	addiu	a0,a0,512
9d001314:	03200008 	jr	t9
9d001318:	27bd0018 	addiu	sp,sp,24
9d00131c:	8fbf0014 	lw	ra,20(sp)
9d001320:	03e00008 	jr	ra
9d001324:	27bd0018 	addiu	sp,sp,24

9d001328 <main>:
9d001328:	27bdffe8 	addiu	sp,sp,-24
9d00132c:	afbf0014 	sw	ra,20(sp)
9d001330:	afbe0010 	sw	s8,16(sp)
9d001334:	03a0f021 	move	s8,sp
9d001338:	0f4005be 	jal	9d0016f8 <init>
9d00133c:	00000000 	nop
9d001340:	3c02a000 	lui	v0,0xa000
9d001344:	24440288 	addiu	a0,v0,648
9d001348:	24052580 	li	a1,9600
9d00134c:	0f4006a0 	jal	9d001a80 <_ZN14HardwareSerial5beginEm>
9d001350:	00000000 	nop
9d001354:	0f4004de 	jal	9d001378 <myprog>
9d001358:	00000000 	nop
9d00135c:	00001021 	move	v0,zero
9d001360:	03c0e821 	move	sp,s8
9d001364:	8fbf0014 	lw	ra,20(sp)
9d001368:	8fbe0010 	lw	s8,16(sp)
9d00136c:	27bd0018 	addiu	sp,sp,24
9d001370:	03e00008 	jr	ra
9d001374:	00000000 	nop

9d001378 <myprog>:
9d001378:	0f40058a 	jal	9d001628 <EnableLEDs>
9d00137c:	00000000 	nop
9d001380:	0f400570 	jal	9d0015c0 <EnableSwitches>
9d001384:	00000000 	nop
9d001388:	0f4005b0 	jal	9d0016c0 <LEDallOff>
9d00138c:	00000000 	nop
9d001390:	3c04a000 	lui	a0,0xa000
9d001394:	24840288 	addiu	a0,a0,648
9d001398:	3c05a000 	lui	a1,0xa000
9d00139c:	24a50208 	addiu	a1,a1,520
9d0013a0:	0f40082e 	jal	9d0020b8 <_ZN5Print7printlnEPKc>
9d0013a4:	00000000 	nop
9d0013a8:	3c05a000 	lui	a1,0xa000
9d0013ac:	24a50238 	addiu	a1,a1,568
9d0013b0:	0f40082e 	jal	9d0020b8 <_ZN5Print7printlnEPKc>
9d0013b4:	00000000 	nop
9d0013b8:	3c05a000 	lui	a1,0xa000
9d0013bc:	24a50247 	addiu	a1,a1,583
9d0013c0:	0f40082e 	jal	9d0020b8 <_ZN5Print7printlnEPKc>
9d0013c4:	00000000 	nop
9d0013c8:	3c05a000 	lui	a1,0xa000
9d0013cc:	24a50259 	addiu	a1,a1,601
9d0013d0:	0f40082e 	jal	9d0020b8 <_ZN5Print7printlnEPKc>
9d0013d4:	00000000 	nop
9d0013d8:	3c05a000 	lui	a1,0xa000
9d0013dc:	24a50264 	addiu	a1,a1,612
9d0013e0:	0f40082e 	jal	9d0020b8 <_ZN5Print7printlnEPKc>
9d0013e4:	00000000 	nop

9d0013e8 <loop>:
9d0013e8:	24040001 	li	a0,1
9d0013ec:	0f40057e 	jal	9d0015f8 <readSwitch>
9d0013f0:	00000000 	nop
9d0013f4:	10400003 	beqz	v0,9d001404 <s1off>
9d0013f8:	00000000 	nop
9d0013fc:	0b400508 	j	9d001420 <s1on>
9d001400:	00000000 	nop

9d001404 <s1off>:
9d001404:	24040002 	li	a0,2
9d001408:	0f40057e 	jal	9d0015f8 <readSwitch>
9d00140c:	00000000 	nop
9d001410:	1040004f 	beqz	v0,9d001550 <defaultPattern>
9d001414:	00000000 	nop
9d001418:	0b40051f 	j	9d00147c <pattern2>
9d00141c:	00000000 	nop

9d001420 <s1on>:
9d001420:	24040002 	li	a0,2
9d001424:	0f40057e 	jal	9d0015f8 <readSwitch>
9d001428:	00000000 	nop
9d00142c:	10400003 	beqz	v0,9d00143c <pattern1>
9d001430:	00000000 	nop
9d001434:	0b40053c 	j	9d0014f0 <pattern3>
9d001438:	00000000 	nop

9d00143c <pattern1>:
9d00143c:	0f4005b0 	jal	9d0016c0 <LEDallOff>
9d001440:	00000000 	nop
9d001444:	240c0001 	li	t4,1
9d001448:	240d0008 	li	t5,8

9d00144c <p1Loop>:
9d00144c:	01802021 	move	a0,t4
9d001450:	0f400598 	jal	9d001660 <LEDon>
9d001454:	00000000 	nop
9d001458:	240400c8 	li	a0,200
9d00145c:	0f400562 	jal	9d001588 <mydelay>
9d001460:	00000000 	nop
9d001464:	000c6040 	sll	t4,t4,0x1
9d001468:	21adffff 	addi	t5,t5,-1
9d00146c:	1da0fff7 	bgtz	t5,9d00144c <p1Loop>
9d001470:	00000000 	nop
9d001474:	0b400560 	j	9d001580 <endPattern>
9d001478:	00000000 	nop

9d00147c <pattern2>:
9d00147c:	240c0001 	li	t4,1
9d001480:	240d0007 	li	t5,7

9d001484 <p2LoopLeft>:
9d001484:	0f4005b0 	jal	9d0016c0 <LEDallOff>
9d001488:	00000000 	nop
9d00148c:	01802021 	move	a0,t4
9d001490:	0f400598 	jal	9d001660 <LEDon>
9d001494:	00000000 	nop
9d001498:	24040064 	li	a0,100
9d00149c:	0f400562 	jal	9d001588 <mydelay>
9d0014a0:	00000000 	nop
9d0014a4:	000c6040 	sll	t4,t4,0x1
9d0014a8:	21adffff 	addi	t5,t5,-1
9d0014ac:	1da0fff5 	bgtz	t5,9d001484 <p2LoopLeft>
9d0014b0:	00000000 	nop
9d0014b4:	240d0007 	li	t5,7

9d0014b8 <p2LoopRight>:
9d0014b8:	0f4005b0 	jal	9d0016c0 <LEDallOff>
9d0014bc:	00000000 	nop
9d0014c0:	01802021 	move	a0,t4
9d0014c4:	0f400598 	jal	9d001660 <LEDon>
9d0014c8:	00000000 	nop
9d0014cc:	24040064 	li	a0,100
9d0014d0:	0f400562 	jal	9d001588 <mydelay>
9d0014d4:	00000000 	nop
9d0014d8:	000c6043 	sra	t4,t4,0x1
9d0014dc:	21adffff 	addi	t5,t5,-1
9d0014e0:	1da0fff5 	bgtz	t5,9d0014b8 <p2LoopRight>
9d0014e4:	00000000 	nop
9d0014e8:	0b400560 	j	9d001580 <endPattern>
9d0014ec:	00000000 	nop

9d0014f0 <pattern3>:
9d0014f0:	240c0001 	li	t4,1
9d0014f4:	240d000b 	li	t5,11

9d0014f8 <p3Loop>:
9d0014f8:	0f4005b0 	jal	9d0016c0 <LEDallOff>
9d0014fc:	00000000 	nop
9d001500:	01802021 	move	a0,t4
9d001504:	0f400598 	jal	9d001660 <LEDon>
9d001508:	00000000 	nop
9d00150c:	01802021 	move	a0,t4
9d001510:	00042043 	sra	a0,a0,0x1
9d001514:	0f400598 	jal	9d001660 <LEDon>
9d001518:	00000000 	nop
9d00151c:	01802021 	move	a0,t4
9d001520:	00042083 	sra	a0,a0,0x2
9d001524:	0f400598 	jal	9d001660 <LEDon>
9d001528:	00000000 	nop
9d00152c:	240400c8 	li	a0,200
9d001530:	0f400562 	jal	9d001588 <mydelay>
9d001534:	00000000 	nop
9d001538:	000c6040 	sll	t4,t4,0x1
9d00153c:	21adffff 	addi	t5,t5,-1
9d001540:	1da0ffed 	bgtz	t5,9d0014f8 <p3Loop>
9d001544:	00000000 	nop
9d001548:	0b400560 	j	9d001580 <endPattern>
9d00154c:	00000000 	nop

9d001550 <defaultPattern>:
9d001550:	0f4005a2 	jal	9d001688 <LEDallOn>
9d001554:	00000000 	nop
9d001558:	240403e8 	li	a0,1000
9d00155c:	0f400562 	jal	9d001588 <mydelay>
9d001560:	00000000 	nop
9d001564:	0f4005b0 	jal	9d0016c0 <LEDallOff>
9d001568:	00000000 	nop
9d00156c:	240403e8 	li	a0,1000
9d001570:	0f400562 	jal	9d001588 <mydelay>
9d001574:	00000000 	nop
9d001578:	0b400560 	j	9d001580 <endPattern>
9d00157c:	00000000 	nop

9d001580 <endPattern>:
9d001580:	0b4004fa 	j	9d0013e8 <loop>
9d001584:	00000000 	nop

9d001588 <mydelay>:
9d001588:	24080000 	li	t0,0
9d00158c:	3c0aa000 	lui	t2,0xa000
9d001590:	8d4a0204 	lw	t2,516(t2)

9d001594 <outerloop>:
9d001594:	24090000 	li	t1,0
9d001598:	21080001 	addi	t0,t0,1
9d00159c:	11040006 	beq	t0,a0,9d0015b8 <done>
9d0015a0:	00000000 	nop

9d0015a4 <innerloop>:
9d0015a4:	21290001 	addi	t1,t1,1
9d0015a8:	112afffa 	beq	t1,t2,9d001594 <outerloop>
9d0015ac:	00000000 	nop
9d0015b0:	0b400569 	j	9d0015a4 <innerloop>
9d0015b4:	00000000 	nop

9d0015b8 <done>:
9d0015b8:	03e00008 	jr	ra
9d0015bc:	00000000 	nop

9d0015c0 <EnableSwitches>:
9d0015c0:	24080000 	li	t0,0
9d0015c4:	24090002 	li	t1,2
9d0015c8:	240a0080 	li	t2,128
9d0015cc:	3c18bf88 	lui	t8,0xbf88
9d0015d0:	271860c0 	addiu	t8,t8,24768

9d0015d4 <swEnaLoop>:
9d0015d4:	21080001 	addi	t0,t0,1
9d0015d8:	af0a0008 	sw	t2,8(t8)
9d0015dc:	000a5040 	sll	t2,t2,0x1
9d0015e0:	11090003 	beq	t0,t1,9d0015f0 <doneSwEna>
9d0015e4:	00000000 	nop
9d0015e8:	0b400575 	j	9d0015d4 <swEnaLoop>
9d0015ec:	00000000 	nop

9d0015f0 <doneSwEna>:
9d0015f0:	03e00008 	jr	ra
9d0015f4:	00000000 	nop

9d0015f8 <readSwitch>:
9d0015f8:	3c08bf88 	lui	t0,0xbf88
9d0015fc:	8d0860d0 	lw	t0,24784(t0)
9d001600:	3c09a000 	lui	t1,0xa000
9d001604:	8d290200 	lw	t1,512(t1)
9d001608:	240a0000 	li	t2,0

9d00160c <switchLoop>:
9d00160c:	214a0001 	addi	t2,t2,1
9d001610:	108a0004 	beq	a0,t2,9d001624 <endSwitchLoop>
9d001614:	00000000 	nop
9d001618:	00094840 	sll	t1,t1,0x1
9d00161c:	0b400583 	j	9d00160c <switchLoop>
9d001620:	00000000 	nop

9d001624 <endSwitchLoop>:
9d001624:	01091024 	and	v0,t0,t1

9d001628 <EnableLEDs>:
9d001628:	24080000 	li	t0,0
9d00162c:	24090008 	li	t1,8
9d001630:	240a0001 	li	t2,1
9d001634:	3c18bf88 	lui	t8,0xbf88
9d001638:	27186100 	addiu	t8,t8,24832

9d00163c <enaLoop>:
9d00163c:	21080001 	addi	t0,t0,1
9d001640:	af0a0004 	sw	t2,4(t8)
9d001644:	000a5040 	sll	t2,t2,0x1
9d001648:	11090003 	beq	t0,t1,9d001658 <doneEna>
9d00164c:	00000000 	nop
9d001650:	0b40058f 	j	9d00163c <enaLoop>
9d001654:	00000000 	nop

9d001658 <doneEna>:
9d001658:	03e00008 	jr	ra
9d00165c:	00000000 	nop

9d001660 <LEDon>:
9d001660:	3c18bf88 	lui	t8,0xbf88
9d001664:	27186110 	addiu	t8,t8,24848
9d001668:	af040008 	sw	a0,8(t8)
9d00166c:	03e00008 	jr	ra
9d001670:	00000000 	nop

9d001674 <LEDoff>:
9d001674:	3c18bf88 	lui	t8,0xbf88
9d001678:	27186110 	addiu	t8,t8,24848
9d00167c:	af040004 	sw	a0,4(t8)
9d001680:	03e00008 	jr	ra
9d001684:	00000000 	nop

9d001688 <LEDallOn>:
9d001688:	24080000 	li	t0,0
9d00168c:	24090008 	li	t1,8
9d001690:	240a0001 	li	t2,1
9d001694:	3c18bf88 	lui	t8,0xbf88
9d001698:	27186110 	addiu	t8,t8,24848

9d00169c <onLoop>:
9d00169c:	21080001 	addi	t0,t0,1
9d0016a0:	af0a0008 	sw	t2,8(t8)
9d0016a4:	000a5040 	sll	t2,t2,0x1
9d0016a8:	11090003 	beq	t0,t1,9d0016b8 <doneOn>
9d0016ac:	00000000 	nop
9d0016b0:	0b4005a7 	j	9d00169c <onLoop>
9d0016b4:	00000000 	nop

9d0016b8 <doneOn>:
9d0016b8:	03e00008 	jr	ra
9d0016bc:	00000000 	nop

9d0016c0 <LEDallOff>:
9d0016c0:	24080000 	li	t0,0
9d0016c4:	24090008 	li	t1,8
9d0016c8:	240a0001 	li	t2,1
9d0016cc:	3c18bf88 	lui	t8,0xbf88
9d0016d0:	27186110 	addiu	t8,t8,24848

9d0016d4 <offLoop>:
9d0016d4:	21080001 	addi	t0,t0,1
9d0016d8:	af0a0004 	sw	t2,4(t8)
9d0016dc:	000a5040 	sll	t2,t2,0x1
9d0016e0:	11090003 	beq	t0,t1,9d0016f0 <doneOff>
9d0016e4:	00000000 	nop
9d0016e8:	0b4005b5 	j	9d0016d4 <offLoop>
9d0016ec:	00000000 	nop

9d0016f0 <doneOff>:
9d0016f0:	03e00008 	jr	ra
9d0016f4:	00000000 	nop

9d0016f8 <init>:


//************************************************************************
void init()
{

9d0016f8:	27bdffe0 	addiu	sp,sp,-32
9d0016fc:	afbf001c 	sw	ra,28(sp)
9d001700:	afb10018 	sw	s1,24(sp)
9d001704:	afb00014 	sw	s0,20(sp)
    10. Understand, your callback is being called while executing inside the CoreTimerHandler ISR. Your code should be as fast as possible. If too much
        time is taken, the ISR may never exit and no sketch will ever run!
*/
//************************************************************************
#define read_count(dest) __asm__ __volatile__("mfc0 %0,$9" : "=r" (dest))
#define read_comp(dest) __asm__ __volatile__("mfc0 %0,$11" : "=r" (dest))
9d001708:	41716000 	di	s1
    unsigned int cache_status;
#endif

    int_status=INTDisableInterrupts();

    mBMXDisableDRMWaitState();
9d00170c:	24030040 	li	v1,64
9d001710:	3c02bf88 	lui	v0,0xbf88
9d001714:	ac432004 	sw	v1,8196(v0)
9d001718:	41646000 	di	a0
        wait_states++;
        sys_clock -= FLASH_SPEED_HZ;
    }

    int_status=INTDisableInterrupts();
    mCheConfigure(wait_states);
9d00171c:	3c10bf88 	lui	s0,0xbf88
9d001720:	24020002 	li	v0,2
9d001724:	0f400885 	jal	9d002214 <INTRestoreInterrupts>
    INTRestoreInterrupts(int_status);
9d001728:	ae024000 	sw	v0,16384(s0)


#ifdef _PCACHE
    if(flags & SYS_CFG_PCACHE)
    {
        cache_status = mCheGetCon();
9d00172c:	8e024000 	lw	v0,16384(s0)
        cache_status |= CHE_CONF_PF_ALL;
9d001730:	34420030 	ori	v0,v0,0x30
        mCheConfigure(cache_status);
9d001734:	0f40087f 	jal	9d0021fc <CheKseg0CacheOn>
        CheKseg0CacheOn();
9d001738:	ae024000 	sw	v0,16384(s0)
    }
#endif

    pb_clk = sys_clock;
    pb_clk >>= OSCCONbits.PBDIV;
9d00173c:	3c02bf81 	lui	v0,0xbf81
9d001740:	8c50f000 	lw	s0,-4096(v0)

    INTRestoreInterrupts(int_status);
9d001744:	0f400885 	jal	9d002214 <INTRestoreInterrupts>
9d001748:	02202021 	move	a0,s1
        CheKseg0CacheOn();
    }
#endif

    pb_clk = sys_clock;
    pb_clk >>= OSCCONbits.PBDIV;
9d00174c:	3c0204c4 	lui	v0,0x4c4
9d001750:	3442b400 	ori	v0,v0,0xb400
9d001754:	7e100cc0 	ext	s0,s0,0x13,0x2
9d001758:	02028006 	srlv	s0,v0,s0
	__PIC32_pbClk	=	SYSTEMConfigPerformance(F_CPU);
#endif


	OpenCoreTimer(CORE_TICK_RATE);

9d00175c:	34049c40 	li	a0,0x9c40
9d001760:	0f40087a 	jal	9d0021e8 <OpenCoreTimer>
9d001764:	af908178 	sw	s0,-32392(gp)
	// set up the core timer interrupt with a prioirty of 2 and zero sub-priority
	mConfigIntCoreTimer(CT_INT_ON | _CT_IPL_IPC | (_CT_SPL_IPC << 4));

9d001768:	24020001 	li	v0,1
9d00176c:	3c05bf88 	lui	a1,0xbf88
9d001770:	aca21034 	sw	v0,4148(a1)
9d001774:	3c04bf88 	lui	a0,0xbf88
9d001778:	2405001c 	li	a1,28
9d00177c:	ac851094 	sw	a1,4244(a0)
9d001780:	3c03bf88 	lui	v1,0xbf88
9d001784:	24050008 	li	a1,8
9d001788:	ac651098 	sw	a1,4248(v1)
9d00178c:	24050003 	li	a1,3
9d001790:	ac851094 	sw	a1,4244(a0)
9d001794:	ac601098 	sw	zero,4248(v1)
9d001798:	3c03bf88 	lui	v1,0xbf88
9d00179c:	ac621064 	sw	v0,4196(v1)
9d0017a0:	3c03bf88 	lui	v1,0xbf88
9d0017a4:	0f40088c 	jal	9d002230 <INTEnableSystemMultiVectoredInt>
	// enable multi-vector interrupts
	INTEnableSystemMultiVectoredInt();

9d0017a8:	ac621068 	sw	v0,4200(v1)

#ifdef _ENABLE_PIC_RTC_
	RtccInit();									// init the RTCC
//	while(RtccGetClkStat() != RTCC_CLK_ON);		// wait for the SOSC to be actually running and RTCC to have its clock source
9d0017ac:	0f400899 	jal	9d002264 <RtccInit>
9d0017b0:	00000000 	nop
void delay(unsigned long ms)
{
unsigned long	startMillis;

	startMillis	=	gTimer0_millis;
	while ((gTimer0_millis - startMillis) < ms)
9d0017b4:	8f838018 	lw	v1,-32744(gp)
	{
9d0017b8:	8f828018 	lw	v0,-32744(gp)
9d0017bc:	00431023 	subu	v0,v0,v1
9d0017c0:	2c420032 	sltiu	v0,v0,50
9d0017c4:	1440fffc 	bnez	v0,9d0017b8 <init+0xc0>
9d0017c8:	3c051101 	lui	a1,0x1101
												// could wait here at most 32ms

   // allow for debugging, this will stop the core timer when the debugger takes control
    _CP0_BIC_DEBUG(_CP0_DEBUG_COUNTDM_MASK); 

	delay(50);
9d0017cc:	3c101007 	lui	s0,0x1007
9d0017d0:	26043000 	addiu	a0,s0,12288
9d0017d4:	24a50901 	addiu	a1,a1,2305
9d0017d8:	0f4008e7 	jal	9d00239c <RtccOpen>
9d0017dc:	00003021 	move	a2,zero
	// time is MSb: hour, min, sec, rsvd. date is MSb: year, mon, mday, wday.
9d0017e0:	3c051010 	lui	a1,0x1010
9d0017e4:	36043000 	ori	a0,s0,0x3000
9d0017e8:	0f4008dd 	jal	9d002374 <RtccSetTimeDate>
9d0017ec:	24a51701 	addiu	a1,a1,5889
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif


	//*	as per Al.Rodriguez@microchip.com, Jan 7, 2011
9d0017f0:	3c02bf81 	lui	v0,0xbf81
9d0017f4:	8c43f200 	lw	v1,-3584(v0)
	//* Initialize the periodic task manager
	_initTaskManager();

	//*	Issue #84
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
9d0017f8:	8fbf001c 	lw	ra,28(sp)
9d0017fc:	8fb10018 	lw	s1,24(sp)
	RtccSetTimeDate(0x10073000, 0x10101701);
	// please note that the rsvd field has to be 0 in the time field!
#endif


	//*	as per Al.Rodriguez@microchip.com, Jan 7, 2011
9d001800:	7c0318c4 	ins	v1,zero,0x3,0x1
9d001804:	ac43f200 	sw	v1,-3584(v0)
#endif

	//* Initialize the periodic task manager
	_initTaskManager();

	//*	Issue #84
9d001808:	34038000 	li	v1,0x8000
9d00180c:	3c02bf80 	lui	v0,0xbf80
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
9d001810:	8fb00014 	lw	s0,20(sp)
#endif

	//* Initialize the periodic task manager
	_initTaskManager();

	//*	Issue #84
9d001814:	ac436004 	sw	v1,24580(v0)
	//*	disable the uart so that the pins can be used as general purpose I/O
#if defined(_SER0_BASE)
9d001818:	03e00008 	jr	ra
9d00181c:	27bd0020 	addiu	sp,sp,32

9d001820 <CoreTimerHandler>:
#endif
}



//************************************************************************
9d001820:	415de800 	rdpgpr	sp,sp
9d001824:	401a7000 	mfc0	k0,c0_epc
9d001828:	401b6000 	mfc0	k1,c0_status
9d00182c:	27bdff90 	addiu	sp,sp,-112
9d001830:	afbb0068 	sw	k1,104(sp)
9d001834:	7c1b7844 	ins	k1,zero,0x1,0xf
9d001838:	377b0800 	ori	k1,k1,0x800
9d00183c:	afba006c 	sw	k0,108(sp)
9d001840:	409b6000 	mtc0	k1,c0_status
9d001844:	afbf005c 	sw	ra,92(sp)
9d001848:	afb90058 	sw	t9,88(sp)
9d00184c:	afb80054 	sw	t8,84(sp)
9d001850:	afb00050 	sw	s0,80(sp)
9d001854:	afaf004c 	sw	t7,76(sp)
9d001858:	afae0048 	sw	t6,72(sp)
9d00185c:	afad0044 	sw	t5,68(sp)
9d001860:	afac0040 	sw	t4,64(sp)
9d001864:	afab003c 	sw	t3,60(sp)
9d001868:	afaa0038 	sw	t2,56(sp)
9d00186c:	afa90034 	sw	t1,52(sp)
9d001870:	afa80030 	sw	t0,48(sp)
9d001874:	afa7002c 	sw	a3,44(sp)
9d001878:	afa60028 	sw	a2,40(sp)
9d00187c:	afa50024 	sw	a1,36(sp)
9d001880:	afa40020 	sw	a0,32(sp)
9d001884:	afa3001c 	sw	v1,28(sp)
9d001888:	afa20018 	sw	v0,24(sp)
9d00188c:	afa10014 	sw	at,20(sp)
9d001890:	00001012 	mflo	v0
9d001894:	afa20064 	sw	v0,100(sp)
{
    unsigned int status = 0;

    asm volatile("ei    %0" : "=r"(status));

    return status;
9d001898:	8f828020 	lw	v0,-32736(gp)
#endif
}



//************************************************************************
9d00189c:	00001810 	mfhi	v1
//*	Interrupts are enabled by setting the IE bit in the status register
//************************************************************************
unsigned int __attribute__((nomips16))  INTEnableInterrupts(void)
{
    unsigned int status = 0;
9d0018a0:	8f908018 	lw	s0,-32744(gp)

    asm volatile("ei    %0" : "=r"(status));

    return status;
9d0018a4:	1040003d 	beqz	v0,9d00199c <CoreTimerHandler+0x17c>
9d0018a8:	afa30060 	sw	v1,96(sp)
}

9d0018ac:	0040f809 	jalr	v0
9d0018b0:	00000000 	nop

//************************************************************************
//*	Interrupts are disabled by clearing the IE bit in the status register
9d0018b4:	14400023 	bnez	v0,9d001944 <CoreTimerHandler+0x124>
9d0018b8:	24030001 	li	v1,1
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.

    The rules:

    1.	You do NOT set “compare”!
    2.  Do not do anything that could cause CoreTimerHandler to be called recursively. For example, do not enable interrupts as the CT flag is still set
9d0018bc:	3c02bf88 	lui	v0,0xbf88
9d0018c0:	ac431034 	sw	v1,4148(v0)
        and will immeditely cause the system to call CoreTimerHandler.
9d0018c4:	8fa50064 	lw	a1,100(sp)
9d0018c8:	8fbf005c 	lw	ra,92(sp)
9d0018cc:	8fb90058 	lw	t9,88(sp)
9d0018d0:	00a00013 	mtlo	a1
9d0018d4:	8fa50060 	lw	a1,96(sp)
9d0018d8:	8fb80054 	lw	t8,84(sp)
9d0018dc:	8fb00050 	lw	s0,80(sp)
9d0018e0:	00a00011 	mthi	a1
9d0018e4:	8faf004c 	lw	t7,76(sp)
9d0018e8:	8fae0048 	lw	t6,72(sp)
9d0018ec:	8fad0044 	lw	t5,68(sp)
9d0018f0:	8fac0040 	lw	t4,64(sp)
9d0018f4:	8fab003c 	lw	t3,60(sp)
9d0018f8:	8faa0038 	lw	t2,56(sp)
9d0018fc:	8fa90034 	lw	t1,52(sp)
9d001900:	8fa80030 	lw	t0,48(sp)
9d001904:	8fa7002c 	lw	a3,44(sp)
9d001908:	8fa60028 	lw	a2,40(sp)
9d00190c:	8fa50024 	lw	a1,36(sp)
9d001910:	8fa40020 	lw	a0,32(sp)
9d001914:	8fa3001c 	lw	v1,28(sp)
9d001918:	8fa20018 	lw	v0,24(sp)
9d00191c:	8fa10014 	lw	at,20(sp)
9d001920:	41606000 	di
9d001924:	000000c0 	ehb
9d001928:	8fba006c 	lw	k0,108(sp)
9d00192c:	8fbb0068 	lw	k1,104(sp)
9d001930:	409a7000 	mtc0	k0,c0_epc
9d001934:	27bd0070 	addiu	sp,sp,112
9d001938:	41dde800 	wrpgpr	sp,sp
9d00193c:	409b6000 	mtc0	k1,c0_status
9d001940:	42000018 	eret
    return status;
}


//************************************************************************
//*	Interrupts are disabled by clearing the IE bit in the status register
9d001944:	8f898020 	lw	t1,-32736(gp)
9d001948:	8f828024 	lw	v0,-32732(gp)
}



//************************************************************************
//*	CoreTimerHandler Services (KeithV)
9d00194c:	3c080013 	lui	t0,0x13
//************************************************************************
unsigned int __attribute__((nomips16)) INTDisableInterrupts(void)
{
    unsigned int status = 0;

    asm volatile("di    %0" : "=r"(status));
9d001950:	34049c40 	li	a0,0x9c40
}



//************************************************************************
//*	CoreTimerHandler Services (KeithV)
9d001954:	35088801 	ori	t0,t0,0x8801
//************************************************************************
//*	Interrupts are disabled by clearing the IE bit in the status register
//************************************************************************
unsigned int __attribute__((nomips16)) INTDisableInterrupts(void)
{
    unsigned int status = 0;
9d001958:	26100001 	addiu	s0,s0,1

9d00195c:	40034800 	mfc0	v1,c0_count
    asm volatile("di    %0" : "=r"(status));
9d001960:	00441021 	addu	v0,v0,a0
    return status;
}



//************************************************************************
9d001964:	0044282b 	sltu	a1,v0,a0
/*
    uint32_t CoreTimerService(uint32_t count)

    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
9d001968:	0043302b 	sltu	a2,v0,v1
    return status;
}



//************************************************************************
9d00196c:	10a00003 	beqz	a1,9d00197c <CoreTimerHandler+0x15c>
9d001970:	0068382b 	sltu	a3,v1,t0
//*	CoreTimerHandler Services (KeithV)
9d001974:	10e00003 	beqz	a3,9d001984 <CoreTimerHandler+0x164>
9d001978:	00000000 	nop
/*
    uint32_t CoreTimerService(uint32_t count)

    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
9d00197c:	54c0fff7 	bnezl	a2,9d00195c <CoreTimerHandler+0x13c>
9d001980:	26100001 	addiu	s0,s0,1
    register your callback serivce it should be called within 1 ms of attaching (registering). In some cases if interrupts are diaabled it may be as 
    long as 50 ms before your first call is made. Passed in to your Service is the current value of the CoreTimer count register, this is a rolling count 
9d001984:	11200007 	beqz	t1,9d0019a4 <CoreTimerHandler+0x184>
9d001988:	af828024 	sw	v0,-32732(gp)
    that rolls once every 2^32 / 40000000 ~ 107seconds. The return value from your service should be the next value of count that you want to be notified; 
    logically like setting the compare register; however, CoreTimerHandler is managing several services and will notify you when your value has been hit. 
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.
9d00198c:	af83801c 	sw	v1,-32740(gp)

9d001990:	af908018 	sw	s0,-32744(gp)
    The rules:

    1.	You do NOT set “compare”!
    2.  Do not do anything that could cause CoreTimerHandler to be called recursively. For example, do not enable interrupts as the CT flag is still set
9d001994:	0b40062f 	j	9d0018bc <CoreTimerHandler+0x9c>
9d001998:	24030001 	li	v1,1
{
    unsigned int status = 0;

    asm volatile("ei    %0" : "=r"(status));

    return status;
9d00199c:	0b400652 	j	9d001948 <CoreTimerHandler+0x128>
9d0019a0:	00004821 	move	t1,zero
    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
    register your callback serivce it should be called within 1 ms of attaching (registering). In some cases if interrupts are diaabled it may be as 
    long as 50 ms before your first call is made. Passed in to your Service is the current value of the CoreTimer count register, this is a rolling count 
    that rolls once every 2^32 / 40000000 ~ 107seconds. The return value from your service should be the next value of count that you want to be notified; 
9d0019a4:	40825800 	mtc0	v0,c0_compare
    logically like setting the compare register; however, CoreTimerHandler is managing several services and will notify you when your value has been hit. 
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.
9d0019a8:	af83801c 	sw	v1,-32740(gp)
    A CoreTimer Service is a callback routine that will get called when the core timer value equals the last value returned by your service; 
    also known as your requested compare time. When registering a CoreTimerService callback routine, the routine will be called on the next regularly 
    scheduled event currently waiting the CoreTimerHandler. From system start, there is a millisecond CoreTimerService running, so in most cases once you 
    register your callback serivce it should be called within 1 ms of attaching (registering). In some cases if interrupts are diaabled it may be as 
    long as 50 ms before your first call is made. Passed in to your Service is the current value of the CoreTimer count register, this is a rolling count 
    that rolls once every 2^32 / 40000000 ~ 107seconds. The return value from your service should be the next value of count that you want to be notified; 
9d0019ac:	af828024 	sw	v0,-32732(gp)
    logically like setting the compare register; however, CoreTimerHandler is managing several services and will notify you when your value has been hit. 
    You will totally screw up CoreTimerHandler if you set the compare register directly. Here are the rules for writing a CoreTimerService callback routine.

9d0019b0:	af908018 	sw	s0,-32744(gp)
    The rules:

    1.	You do NOT set “compare”!
    2.  Do not do anything that could cause CoreTimerHandler to be called recursively. For example, do not enable interrupts as the CT flag is still set
9d0019b4:	0b40062f 	j	9d0018bc <CoreTimerHandler+0x9c>
9d0019b8:	24030001 	li	v1,1

9d0019bc <INTEnableInterrupts>:
    5.	Unfortunately, because of things like the EEProm writes, you can be called late and you must “catch-up” however best you can and return 
        the next requested “compare” time on your next call.
    6.	There are limits to how far in the future you can set your next "compare" time. Right now this is limited to 90 seconds. If you need a longer delay you
        should be using something other than a CoreTimer Services to do this. You probably should really limit your next "compare" time to less than few seconds.
    7.	Your next requested “compare” time MUST be equal to or after (in time) the “current” time as passed in to you. You may add up to 90 seconds to the 
        current time, even if this causes uint32 wrap; but do not subtract from the current time and return that. There is a region known to CoreTimerHandler 
9d0019bc:	03e00008 	jr	ra
        that is before the current time, but that uint32 "value" is after the current time + 90 seconds.
     8.	CoreTimerHandler will keep looping until count is less than whatever the next compare is “after” CT was cleared to insure that CT is not missed. 
        It is possible that you could be called a second time before exiting the CoreTimerHandler ISR if you request a new compare time that is very close to 
9d0019c0:	41626020 	ei	v0

9d0019c4 <INTDisableInterrupts>:
    10. Understand, your callback is being called while executing inside the CoreTimerHandler ISR. Your code should be as fast as possible. If too much
        time is taken, the ISR may never exit and no sketch will ever run!
*/
//************************************************************************
#define read_count(dest) __asm__ __volatile__("mfc0 %0,$9" : "=r" (dest))
#define read_comp(dest) __asm__ __volatile__("mfc0 %0,$11" : "=r" (dest))
9d0019c4:	03e00008 	jr	ra
#define write_comp(src) __asm__ __volatile__("mtc0 %0,$11" : : "r" (src))

#define mCTSetIntFlag() (IFS0SET = _IFS0_CTIF_MASK)
9d0019c8:	41626000 	di	v0

9d0019cc <_ZN14HardwareSerial9availableEv>:
**		receive buffer.
*/

int HardwareSerial::available(void)
{
	return (RX_BUFFER_SIZE + rx_buffer.head - rx_buffer.tail) % RX_BUFFER_SIZE;
9d0019cc:	8c8200a0 	lw	v0,160(a0)
9d0019d0:	8c8300a4 	lw	v1,164(a0)
9d0019d4:	24420080 	addiu	v0,v0,128
9d0019d8:	00431023 	subu	v0,v0,v1
9d0019dc:	00021fc3 	sra	v1,v0,0x1f
9d0019e0:	00031e42 	srl	v1,v1,0x19
9d0019e4:	00431021 	addu	v0,v0,v1
9d0019e8:	3042007f 	andi	v0,v0,0x7f
}
9d0019ec:	03e00008 	jr	ra
9d0019f0:	00431023 	subu	v0,v0,v1

9d0019f4 <_ZN14HardwareSerial4peekEv>:
**		removing it from the buffer, or -1 if no characters are in the buffer.
*/

int HardwareSerial::peek()
{
	if (rx_buffer.head == rx_buffer.tail)
9d0019f4:	8c8300a4 	lw	v1,164(a0)
9d0019f8:	8c8500a0 	lw	a1,160(a0)
9d0019fc:	10a30003 	beq	a1,v1,9d001a0c <_ZN14HardwareSerial4peekEv+0x18>
9d001a00:	2402ffff 	li	v0,-1
	{
		return -1;
	}
	else
	{
		return rx_buffer.buffer[rx_buffer.tail];
9d001a04:	00832021 	addu	a0,a0,v1
9d001a08:	90820020 	lbu	v0,32(a0)
	}
}
9d001a0c:	03e00008 	jr	ra
9d001a10:	00000000 	nop

9d001a14 <_ZN14HardwareSerial4readEv>:
int HardwareSerial::read(void)
{
	unsigned char theChar;

	// if the head isn't ahead of the tail, we don't have any characters
	if (rx_buffer.head == rx_buffer.tail)
9d001a14:	8c8300a4 	lw	v1,164(a0)
9d001a18:	8c8500a0 	lw	a1,160(a0)
9d001a1c:	10a3000a 	beq	a1,v1,9d001a48 <_ZN14HardwareSerial4readEv+0x34>
9d001a20:	2402ffff 	li	v0,-1
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d001a24:	24660001 	addiu	a2,v1,1
9d001a28:	00062fc3 	sra	a1,a2,0x1f
9d001a2c:	00052e42 	srl	a1,a1,0x19
9d001a30:	00c53021 	addu	a2,a2,a1
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d001a34:	00831821 	addu	v1,a0,v1
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d001a38:	30c6007f 	andi	a2,a2,0x7f
	{
		return -1;
	}
	else
	{
		theChar			= rx_buffer.buffer[rx_buffer.tail];
9d001a3c:	90620020 	lbu	v0,32(v1)
		rx_buffer.tail	= (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
9d001a40:	00c52823 	subu	a1,a2,a1
9d001a44:	ac8500a4 	sw	a1,164(a0)
		return (theChar);
	}
}
9d001a48:	03e00008 	jr	ra
9d001a4c:	00000000 	nop

9d001a50 <_ZN14HardwareSerial5flushEv>:
	// don't reverse this or there may be problems if the RX interrupt
	// occurs after reading the value of rx_buffer_head but before writing
	// the value to rx_buffer_tail; the previous value of rx_buffer_head
	// may be written to rx_buffer_tail, making it appear as if the buffer
	// were full, not empty.
	rx_buffer.head = rx_buffer.tail;
9d001a50:	8c8200a4 	lw	v0,164(a0)
}
9d001a54:	03e00008 	jr	ra
9d001a58:	ac8200a0 	sw	v0,160(a0)

9d001a5c <_ZN14HardwareSerial5writeEh>:
**		Wait until the transmitter is idle, and then transmit the
**		specified character.
*/

void HardwareSerial::write(uint8_t theChar)
{
9d001a5c:	8c820004 	lw	v0,4(a0)
9d001a60:	30a500ff 	andi	a1,a1,0xff

	while ((uart->uxSta.reg & (1 << _UARTSTA_TMRT)) == 0)	//check the TRMT bit
9d001a64:	8c430010 	lw	v1,16(v0)
9d001a68:	30630100 	andi	v1,v1,0x100
9d001a6c:	1060fffd 	beqz	v1,9d001a64 <_ZN14HardwareSerial5writeEh+0x8>
9d001a70:	00000000 	nop
		{
		//* wait for the transmitter to be clear
		}


	uart->uxTx.reg = theChar;
9d001a74:	ac450020 	sw	a1,32(v0)
}
9d001a78:	03e00008 	jr	ra
9d001a7c:	00000000 	nop

9d001a80 <_ZN14HardwareSerial5beginEm>:
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	flush();
9d001a80:	8c820000 	lw	v0,0(a0)
**		Initialize the UART for use, setting the baud rate to the
**		requested value, data size of 8-bits, and no parity.
*/

void HardwareSerial::begin(unsigned long baudRate)
{
9d001a84:	27bdffe0 	addiu	sp,sp,-32
9d001a88:	afbf001c 	sw	ra,28(sp)
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	flush();
9d001a8c:	8c420018 	lw	v0,24(v0)
**		Initialize the UART for use, setting the baud rate to the
**		requested value, data size of 8-bits, and no parity.
*/

void HardwareSerial::begin(unsigned long baudRate)
{
9d001a90:	afb00018 	sw	s0,24(sp)
	p32_regset *	ipc;	//interrupt priority control register set
	int				irq_shift;

	/* Initialize the receive buffer.
	*/
	flush();
9d001a94:	afa50010 	sw	a1,16(sp)
9d001a98:	0040f809 	jalr	v0
9d001a9c:	00808021 	move	s0,a0
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001aa0:	8f828178 	lw	v0,-32392(gp)
9d001aa4:	8fa50010 	lw	a1,16(sp)
	flush();

	/* Compute the address of the interrupt priority control
	** registers used by this UART
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);	//interrupt priority control reg set
9d001aa8:	92080009 	lbu	t0,9(s0)
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001aac:	00021102 	srl	v0,v0,0x4
9d001ab0:	0045001b 	divu	zero,v0,a1
9d001ab4:	00a001f4 	teq	a1,zero,0x7
	flush();

	/* Compute the address of the interrupt priority control
	** registers used by this UART
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);	//interrupt priority control reg set
9d001ab8:	3c07bf88 	lui	a3,0xbf88
9d001abc:	00081882 	srl	v1,t0,0x2
9d001ac0:	00031900 	sll	v1,v1,0x4

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this IRQ.
	*/
	irq_shift = 8 * (vec % 4);
9d001ac4:	31080003 	andi	t0,t0,0x3
	flush();

	/* Compute the address of the interrupt priority control
	** registers used by this UART
	*/
	ipc = ((p32_regset *)&IPC0) + (vec / 4);	//interrupt priority control reg set
9d001ac8:	24e71090 	addiu	a3,a3,4240
9d001acc:	00e33821 	addu	a3,a3,v1

	/* Compute the number of bit positions to shift to get to the
	** correct position for the priority bits for this IRQ.
	*/
	irq_shift = 8 * (vec % 4);
9d001ad0:	000840c0 	sll	t0,t0,0x3

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
9d001ad4:	2403001f 	li	v1,31
9d001ad8:	01031804 	sllv	v1,v1,t0
9d001adc:	ace30004 	sw	v1,4(a3)
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001ae0:	920a000a 	lbu	t2,10(s0)
9d001ae4:	920c000b 	lbu	t4,11(s0)

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001ae8:	8e040018 	lw	a0,24(s0)
9d001aec:	8e06001c 	lw	a2,28(s0)
9d001af0:	8e0b0014 	lw	t3,20(s0)

	iec->clr = bit_rx + bit_tx + bit_err;	//disable all interrupts
9d001af4:	8e030010 	lw	v1,16(s0)
	ipc->set = ((ipl << 2) + spl) << irq_shift;

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001af8:	8e09000c 	lw	t1,12(s0)
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001afc:	000a5080 	sll	t2,t2,0x2
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001b00:	8e020004 	lw	v0,4(s0)
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001b04:	014c5021 	addu	t2,t2,t4

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001b08:	00863021 	addu	a2,a0,a2
9d001b0c:	00cb3021 	addu	a2,a2,t3
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001b10:	010a4004 	sllv	t0,t2,t0
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
	uart->uxSta.reg = 0;
	uart->uxMode.reg = (1 << _UARTMODE_ON);			//enable UART module
	uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);	//enable transmitter and receiver

}
9d001b14:	8fbf001c 	lw	ra,28(sp)
	irq_shift = 8 * (vec % 4);

	/* Set the interrupt privilege level and sub-privilege level
	*/
	ipc->clr = 	(0x1F << irq_shift);
	ipc->set = ((ipl << 2) + spl) << irq_shift;
9d001b18:	ace80008 	sw	t0,8(a3)

	/* Clear the interrupt flags, and set the interrupt enables for the
	** interrupts used by this UART.
	*/
	ifs->clr = bit_rx + bit_tx + bit_err;	//clear all interrupt flags
9d001b1c:	ad260004 	sw	a2,4(t1)

	iec->clr = bit_rx + bit_tx + bit_err;	//disable all interrupts
9d001b20:	ac660004 	sw	a2,4(v1)
	iec->set = bit_rx;						//enable rx interrupts
9d001b24:	ac640008 	sw	a0,8(v1)
	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
	uart->uxSta.reg = 0;
	uart->uxMode.reg = (1 << _UARTMODE_ON);			//enable UART module
9d001b28:	34038000 	li	v1,0x8000
	uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);	//enable transmitter and receiver

}
9d001b2c:	8fb00018 	lw	s0,24(sp)
9d001b30:	27bd0020 	addiu	sp,sp,32
	iec->set = bit_rx;						//enable rx interrupts

	/* Initialize the UART itself.
	*/
	//	http://www.chipkit.org/forum/viewtopic.php?f=7&t=213&p=948#p948
	uart->uxBrg.reg	 = ((__PIC32_pbClk / 16 / baudRate) - 1);	// calculate actual BAUD generate value.
9d001b34:	00002812 	mflo	a1
9d001b38:	24a5ffff 	addiu	a1,a1,-1
9d001b3c:	ac450040 	sw	a1,64(v0)
	uart->uxSta.reg = 0;
9d001b40:	ac400010 	sw	zero,16(v0)
	uart->uxMode.reg = (1 << _UARTMODE_ON);			//enable UART module
9d001b44:	ac430000 	sw	v1,0(v0)
	uart->uxSta.reg  = (1 << _UARTSTA_UTXEN) + (1 << _UARTSTA_URXEN);	//enable transmitter and receiver
9d001b48:	24031400 	li	v1,5120
9d001b4c:	ac430010 	sw	v1,16(v0)

}
9d001b50:	03e00008 	jr	ra
9d001b54:	00000000 	nop

9d001b58 <_ZN14HardwareSerial11doSerialIntEv>:
	uint8_t	ch;

	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
9d001b58:	8c82000c 	lw	v0,12(a0)
9d001b5c:	8c830018 	lw	v1,24(a0)
9d001b60:	8c450000 	lw	a1,0(v0)
9d001b64:	00652824 	and	a1,v1,a1
9d001b68:	10a00010 	beqz	a1,9d001bac <_ZN14HardwareSerial11doSerialIntEv+0x54>
9d001b6c:	00000000 	nop
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d001b70:	8c8700a0 	lw	a3,160(a0)
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d001b74:	8c890004 	lw	t1,4(a0)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d001b78:	8c8800a4 	lw	t0,164(a0)
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
		bufIndex	= (rx_buffer.head + 1) % RX_BUFFER_SIZE;
9d001b7c:	24e60001 	addiu	a2,a3,1
9d001b80:	00062fc3 	sra	a1,a2,0x1f
9d001b84:	00052e42 	srl	a1,a1,0x19
9d001b88:	00c53021 	addu	a2,a2,a1
9d001b8c:	30c6007f 	andi	a2,a2,0x7f
9d001b90:	00c52823 	subu	a1,a2,a1
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d001b94:	8d260030 	lw	a2,48(t1)
		/* If we should be storing the received character into the location
		** just before the tail (meaning that the head would advance to the
		** current location of the tail), we're about to overflow the buffer
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
9d001b98:	11050003 	beq	t0,a1,9d001ba8 <_ZN14HardwareSerial11doSerialIntEv+0x50>
9d001b9c:	00873821 	addu	a3,a0,a3
	/* If it's a receive interrupt, get the character and store
	** it in the receive buffer.
	*/
	if ((ifs->reg & bit_rx) != 0)
	{
		ch = uart->uxRx.reg;
9d001ba0:	a0e60020 	sb	a2,32(a3)
		** and so we don't write the character or advance the head.
		*/
		if (bufIndex != rx_buffer.tail)
		{
			rx_buffer.buffer[rx_buffer.head] = ch;
			rx_buffer.head = bufIndex;
9d001ba4:	ac8500a0 	sw	a1,160(a0)
		}

		/* Clear the interrupt flag.
		*/
		ifs->clr = bit_rx;
9d001ba8:	ac430004 	sw	v1,4(v0)
	}

	/* If it's a transmit interrupt, ignore it, as we don't current
	** have interrupt driven i/o on the transmit side.
	*/
	if ((ifs->reg & bit_tx) != 0)
9d001bac:	8c450000 	lw	a1,0(v0)
9d001bb0:	8c83001c 	lw	v1,28(a0)
9d001bb4:	00652024 	and	a0,v1,a1
9d001bb8:	54800001 	bnezl	a0,9d001bc0 <_ZN14HardwareSerial11doSerialIntEv+0x68>
9d001bbc:	ac430004 	sw	v1,4(v0)
9d001bc0:	03e00008 	jr	ra
9d001bc4:	00000000 	nop

9d001bc8 <IntSer0Handler>:
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __ISR(_SER0_VECTOR, _SER0_IPL_ISR) IntSer0Handler(void)
{
9d001bc8:	415de800 	rdpgpr	sp,sp
9d001bcc:	401a7000 	mfc0	k0,c0_epc
9d001bd0:	401b6000 	mfc0	k1,c0_status
9d001bd4:	27bdff98 	addiu	sp,sp,-104
9d001bd8:	afbb0060 	sw	k1,96(sp)
9d001bdc:	7c1b7844 	ins	k1,zero,0x1,0xf
9d001be0:	377b0800 	ori	k1,k1,0x800
9d001be4:	afba0064 	sw	k0,100(sp)
9d001be8:	409b6000 	mtc0	k1,c0_status
9d001bec:	afbf0054 	sw	ra,84(sp)
9d001bf0:	afb90050 	sw	t9,80(sp)
9d001bf4:	afb8004c 	sw	t8,76(sp)
9d001bf8:	afaf0048 	sw	t7,72(sp)
9d001bfc:	afae0044 	sw	t6,68(sp)
9d001c00:	afad0040 	sw	t5,64(sp)
9d001c04:	afac003c 	sw	t4,60(sp)
9d001c08:	afab0038 	sw	t3,56(sp)
9d001c0c:	afaa0034 	sw	t2,52(sp)
9d001c10:	afa90030 	sw	t1,48(sp)
9d001c14:	afa8002c 	sw	t0,44(sp)
9d001c18:	afa70028 	sw	a3,40(sp)
9d001c1c:	afa60024 	sw	a2,36(sp)
9d001c20:	afa50020 	sw	a1,32(sp)
9d001c24:	afa4001c 	sw	a0,28(sp)
9d001c28:	afa30018 	sw	v1,24(sp)
9d001c2c:	afa20014 	sw	v0,20(sp)
9d001c30:	afa10010 	sw	at,16(sp)
9d001c34:	00001012 	mflo	v0
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
#else
	Serial.doSerialInt();
9d001c38:	27848028 	addiu	a0,gp,-32728
**		serial port 0.
*/
#if defined(_SER0_VECTOR)

void __ISR(_SER0_VECTOR, _SER0_IPL_ISR) IntSer0Handler(void)
{
9d001c3c:	afa2005c 	sw	v0,92(sp)
9d001c40:	00001810 	mfhi	v1
#if defined(_USB) && defined(_USE_USB_FOR_SERIAL_)
	Serial0.doSerialInt();
#else
	Serial.doSerialInt();
9d001c44:	0f4006d6 	jal	9d001b58 <_ZN14HardwareSerial11doSerialIntEv>
9d001c48:	afa30058 	sw	v1,88(sp)
#endif
}
9d001c4c:	8fa5005c 	lw	a1,92(sp)
9d001c50:	8fbf0054 	lw	ra,84(sp)
9d001c54:	8fb90050 	lw	t9,80(sp)
9d001c58:	00a00013 	mtlo	a1
9d001c5c:	8fa50058 	lw	a1,88(sp)
9d001c60:	8fb8004c 	lw	t8,76(sp)
9d001c64:	8faf0048 	lw	t7,72(sp)
9d001c68:	00a00011 	mthi	a1
9d001c6c:	8fae0044 	lw	t6,68(sp)
9d001c70:	8fad0040 	lw	t5,64(sp)
9d001c74:	8fac003c 	lw	t4,60(sp)
9d001c78:	8fab0038 	lw	t3,56(sp)
9d001c7c:	8faa0034 	lw	t2,52(sp)
9d001c80:	8fa90030 	lw	t1,48(sp)
9d001c84:	8fa8002c 	lw	t0,44(sp)
9d001c88:	8fa70028 	lw	a3,40(sp)
9d001c8c:	8fa60024 	lw	a2,36(sp)
9d001c90:	8fa50020 	lw	a1,32(sp)
9d001c94:	8fa4001c 	lw	a0,28(sp)
9d001c98:	8fa30018 	lw	v1,24(sp)
9d001c9c:	8fa20014 	lw	v0,20(sp)
9d001ca0:	8fa10010 	lw	at,16(sp)
9d001ca4:	41606000 	di
9d001ca8:	000000c0 	ehb
9d001cac:	8fba0064 	lw	k0,100(sp)
9d001cb0:	8fbb0060 	lw	k1,96(sp)
9d001cb4:	409a7000 	mtc0	k0,c0_epc
9d001cb8:	27bd0068 	addiu	sp,sp,104
9d001cbc:	41dde800 	wrpgpr	sp,sp
9d001cc0:	409b6000 	mtc0	k1,c0_status
9d001cc4:	42000018 	eret

9d001cc8 <IntSer1Handler>:
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __ISR(_SER1_VECTOR, _SER1_IPL_ISR) IntSer1Handler(void)
{
9d001cc8:	415de800 	rdpgpr	sp,sp
9d001ccc:	401a7000 	mfc0	k0,c0_epc
9d001cd0:	401b6000 	mfc0	k1,c0_status
9d001cd4:	27bdff98 	addiu	sp,sp,-104
9d001cd8:	afbb0060 	sw	k1,96(sp)
9d001cdc:	7c1b7844 	ins	k1,zero,0x1,0xf
9d001ce0:	377b0800 	ori	k1,k1,0x800
9d001ce4:	afba0064 	sw	k0,100(sp)
9d001ce8:	409b6000 	mtc0	k1,c0_status
9d001cec:	afbf0054 	sw	ra,84(sp)
9d001cf0:	afb90050 	sw	t9,80(sp)
9d001cf4:	afb8004c 	sw	t8,76(sp)
9d001cf8:	afaf0048 	sw	t7,72(sp)
9d001cfc:	afae0044 	sw	t6,68(sp)
9d001d00:	afad0040 	sw	t5,64(sp)
9d001d04:	afac003c 	sw	t4,60(sp)
9d001d08:	afab0038 	sw	t3,56(sp)
9d001d0c:	afaa0034 	sw	t2,52(sp)
9d001d10:	afa90030 	sw	t1,48(sp)
9d001d14:	afa8002c 	sw	t0,44(sp)
9d001d18:	afa70028 	sw	a3,40(sp)
9d001d1c:	afa60024 	sw	a2,36(sp)
9d001d20:	afa50020 	sw	a1,32(sp)
9d001d24:	afa4001c 	sw	a0,28(sp)
9d001d28:	afa30018 	sw	v1,24(sp)
9d001d2c:	afa20014 	sw	v0,20(sp)
9d001d30:	afa10010 	sw	at,16(sp)
9d001d34:	00001012 	mflo	v0
	Serial1.doSerialInt();
9d001d38:	278480d0 	addiu	a0,gp,-32560
**		serial port 1.
*/
#if defined(_SER1_VECTOR)

void __ISR(_SER1_VECTOR, _SER1_IPL_ISR) IntSer1Handler(void)
{
9d001d3c:	afa2005c 	sw	v0,92(sp)
9d001d40:	00001810 	mfhi	v1
	Serial1.doSerialInt();
9d001d44:	0f4006d6 	jal	9d001b58 <_ZN14HardwareSerial11doSerialIntEv>
9d001d48:	afa30058 	sw	v1,88(sp)
}
9d001d4c:	8fa5005c 	lw	a1,92(sp)
9d001d50:	8fbf0054 	lw	ra,84(sp)
9d001d54:	8fb90050 	lw	t9,80(sp)
9d001d58:	00a00013 	mtlo	a1
9d001d5c:	8fa50058 	lw	a1,88(sp)
9d001d60:	8fb8004c 	lw	t8,76(sp)
9d001d64:	8faf0048 	lw	t7,72(sp)
9d001d68:	00a00011 	mthi	a1
9d001d6c:	8fae0044 	lw	t6,68(sp)
9d001d70:	8fad0040 	lw	t5,64(sp)
9d001d74:	8fac003c 	lw	t4,60(sp)
9d001d78:	8fab0038 	lw	t3,56(sp)
9d001d7c:	8faa0034 	lw	t2,52(sp)
9d001d80:	8fa90030 	lw	t1,48(sp)
9d001d84:	8fa8002c 	lw	t0,44(sp)
9d001d88:	8fa70028 	lw	a3,40(sp)
9d001d8c:	8fa60024 	lw	a2,36(sp)
9d001d90:	8fa50020 	lw	a1,32(sp)
9d001d94:	8fa4001c 	lw	a0,28(sp)
9d001d98:	8fa30018 	lw	v1,24(sp)
9d001d9c:	8fa20014 	lw	v0,20(sp)
9d001da0:	8fa10010 	lw	at,16(sp)
9d001da4:	41606000 	di
9d001da8:	000000c0 	ehb
9d001dac:	8fba0064 	lw	k0,100(sp)
9d001db0:	8fbb0060 	lw	k1,96(sp)
9d001db4:	409a7000 	mtc0	k0,c0_epc
9d001db8:	27bd0068 	addiu	sp,sp,104
9d001dbc:	41dde800 	wrpgpr	sp,sp
9d001dc0:	409b6000 	mtc0	k1,c0_status
9d001dc4:	42000018 	eret

9d001dc8 <_GLOBAL__I__ZN14HardwareSerialC2EP8p32_uartiiii>:
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d001dc8:	3c04bf88 	lui	a0,0xbf88
9d001dcc:	24841060 	addiu	a0,a0,4192
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
9d001dd0:	24020002 	li	v0,2
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
9d001dd4:	3c06bf80 	lui	a2,0xbf80
**	Description:
**		Object constructor. Initialize member variables, and
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
9d001dd8:	3c039d00 	lui	v1,0x9d00
9d001ddc:	246328bc 	addiu	v1,v1,10428
{
	uart = uartP;
9d001de0:	24c96000 	addiu	t1,a2,24576
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d001de4:	24870010 	addiu	a3,a0,16
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001de8:	3c05bf88 	lui	a1,0xbf88
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
9d001dec:	a3828032 	sb	v0,-32718(gp)
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d001df0:	af848038 	sw	a0,-32712(gp)
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
9d001df4:	a38280da 	sb	v0,-32550(gp)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d001df8:	3c040400 	lui	a0,0x400
9d001dfc:	24020100 	li	v0,256
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001e00:	24a51030 	addiu	a1,a1,4144
**	Description:
**		Object constructor. Initialize member variables, and
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
9d001e04:	af838028 	sw	v1,-32728(gp)
{
	uart = uartP;
9d001e08:	af89802c 	sw	t1,-32724(gp)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d001e0c:	af84803c 	sw	a0,-32708(gp)
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d001e10:	2409001a 	li	t1,26
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d001e14:	3c040800 	lui	a0,0x800
**	Description:
**		Object constructor. Initialize member variables, and
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
9d001e18:	af8380d0 	sw	v1,-32560(gp)
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
9d001e1c:	af8280e4 	sw	v0,-32540(gp)
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d001e20:	24030028 	li	v1,40
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d001e24:	24020200 	li	v0,512
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
9d001e28:	24c66200 	addiu	a2,a2,25088
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001e2c:	24a80010 	addiu	t0,a1,16
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d001e30:	a3898030 	sb	t1,-32720(gp)
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d001e34:	af848040 	sw	a0,-32704(gp)

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
9d001e38:	24090018 	li	t1,24
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d001e3c:	3c041000 	lui	a0,0x1000
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
9d001e40:	a38380d8 	sb	v1,-32552(gp)
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
9d001e44:	af8280e8 	sw	v0,-32536(gp)

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
9d001e48:	24030020 	li	v1,32
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d001e4c:	24020400 	li	v0,1024

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
	irq  = irqP;
	vec  = vecP;
9d001e50:	a3898031 	sb	t1,-32719(gp)
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
	spl  = (uint8_t)splP;
9d001e54:	a3808033 	sb	zero,-32717(gp)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001e58:	af858034 	sw	a1,-32716(gp)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set

	bit_err = 1 << (irq % 32);		//error interrupt flag/enable bit
	bit_rx  = 1 << ((irq+1) % 32);	//rx interrupt flag/enable bit
	bit_tx  = 1 << ((irq+2) % 32);	//tx interrupt flag/enable bit
9d001e5c:	af848044 	sw	a0,-32700(gp)
**		any global variables used by the object.
*/

HardwareSerial::HardwareSerial(p32_uart * uartP, int irqP, int vecP, int iplP, int splP)
{
	uart = uartP;
9d001e60:	af8680d4 	sw	a2,-32556(gp)
	irq  = irqP;
	vec  = vecP;
9d001e64:	a38380d9 	sb	v1,-32551(gp)
	irq  = (uint8_t)irqP;
	vec  = (uint8_t)vecP;
	ipl  = (uint8_t)iplP;
	spl  = (uint8_t)splP;
9d001e68:	a38080db 	sb	zero,-32549(gp)
	** can be computed from the vector number. Each IPC register contains the
	** the priority bits for four vectors. Each byte of an IPC registger contains
	** the priority and sub-priority bits arranged such that  bits 0-1 are
	** the sub-priority, bits 2-4 the priority, and bits 5-7 unused.
	*/
	ifs = ((p32_regset *)&IFS0) + (irq / 32);	//interrupt flag register set
9d001e6c:	af8880dc 	sw	t0,-32548(gp)
	iec = ((p32_regset *)&IEC0) + (irq / 32);	//interrupt enable control reg set
9d001e70:	af8780e0 	sw	a3,-32544(gp)
#endif

#endif	//defined(_USB) && defined(_USE_USB_FOR_SERIAL_)

#if defined(_SER1_BASE)
HardwareSerial Serial1((p32_uart *)_SER1_BASE, _SER1_IRQ, _SER1_VECTOR, _SER1_IPL, _SER1_SPL);
9d001e74:	03e00008 	jr	ra
9d001e78:	af8280ec 	sw	v0,-32532(gp)

9d001e7c <_ZN5Print5writeEPKc>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
9d001e7c:	27bdffe0 	addiu	sp,sp,-32
9d001e80:	afb10018 	sw	s1,24(sp)
9d001e84:	afb00014 	sw	s0,20(sp)
9d001e88:	afbf001c 	sw	ra,28(sp)
9d001e8c:	00a08021 	move	s0,a1
	while (*str)
9d001e90:	80a50000 	lb	a1,0(a1)
9d001e94:	10a0000a 	beqz	a1,9d001ec0 <_ZN5Print5writeEPKc+0x44>
9d001e98:	00808821 	move	s1,a0
	{
		write(*str++);
9d001e9c:	8e220000 	lw	v0,0(s1)
9d001ea0:	30a500ff 	andi	a1,a1,0xff
9d001ea4:	26100001 	addiu	s0,s0,1
9d001ea8:	8c420000 	lw	v0,0(v0)
9d001eac:	0040f809 	jalr	v0
9d001eb0:	02202021 	move	a0,s1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const char *str)
{
	while (*str)
9d001eb4:	82050000 	lb	a1,0(s0)
9d001eb8:	54a0fff9 	bnezl	a1,9d001ea0 <_ZN5Print5writeEPKc+0x24>
9d001ebc:	8e220000 	lw	v0,0(s1)
	{
		write(*str++);
	}
}
9d001ec0:	8fbf001c 	lw	ra,28(sp)
9d001ec4:	8fb10018 	lw	s1,24(sp)
9d001ec8:	8fb00014 	lw	s0,20(sp)
9d001ecc:	03e00008 	jr	ra
9d001ed0:	27bd0020 	addiu	sp,sp,32

9d001ed4 <_ZN5Print5writeEPKhm>:

//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
9d001ed4:	27bdffe0 	addiu	sp,sp,-32
9d001ed8:	afb20018 	sw	s2,24(sp)
9d001edc:	afb10014 	sw	s1,20(sp)
9d001ee0:	afb00010 	sw	s0,16(sp)
9d001ee4:	afbf001c 	sw	ra,28(sp)
9d001ee8:	00c08021 	move	s0,a2
9d001eec:	00809021 	move	s2,a0
	while (size--)
9d001ef0:	10c0000a 	beqz	a2,9d001f1c <_ZN5Print5writeEPKhm+0x48>
9d001ef4:	00a08821 	move	s1,a1
	{
		write(*buffer++);
9d001ef8:	8e420000 	lw	v0,0(s2)
9d001efc:	92250000 	lbu	a1,0(s1)
9d001f00:	2610ffff 	addiu	s0,s0,-1
9d001f04:	8c420000 	lw	v0,0(v0)
9d001f08:	02402021 	move	a0,s2
9d001f0c:	0040f809 	jalr	v0
9d001f10:	26310001 	addiu	s1,s1,1
//************************************************************************
/* default implementation: may be overridden */
//************************************************************************
void Print::write(const uint8_t *buffer, size_t size)
{
	while (size--)
9d001f14:	5600fff9 	bnezl	s0,9d001efc <_ZN5Print5writeEPKhm+0x28>
9d001f18:	8e420000 	lw	v0,0(s2)
	{
		write(*buffer++);
	}
}
9d001f1c:	8fbf001c 	lw	ra,28(sp)
9d001f20:	8fb20018 	lw	s2,24(sp)
9d001f24:	8fb10014 	lw	s1,20(sp)
9d001f28:	8fb00010 	lw	s0,16(sp)
9d001f2c:	03e00008 	jr	ra
9d001f30:	27bd0020 	addiu	sp,sp,32

9d001f34 <_ZN5Print11printNumberEmh>:

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
{
9d001f34:	27bdffc0 	addiu	sp,sp,-64
9d001f38:	afb10038 	sw	s1,56(sp)
9d001f3c:	afb00034 	sw	s0,52(sp)
9d001f40:	afbf003c 	sw	ra,60(sp)
9d001f44:	00808021 	move	s0,a0
9d001f48:	30c600ff 	andi	a2,a2,0xff
unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars.
unsigned long i = 0;

	if (n == 0)
9d001f4c:	10a00020 	beqz	a1,9d001fd0 <_ZN5Print11printNumberEmh+0x9c>
9d001f50:	00008821 	move	s1,zero
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d001f54:	00a6001b 	divu	zero,a1,a2
9d001f58:	00c001f4 	teq	a2,zero,0x7
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d001f5c:	27a40010 	addiu	a0,sp,16
9d001f60:	00911021 	addu	v0,a0,s1
		return;
	}

	while (n > 0)
	{
		buf[i++] = n % base;
9d001f64:	26310001 	addiu	s1,s1,1
9d001f68:	00001810 	mfhi	v1
9d001f6c:	00002812 	mflo	a1
	{
		print('0');
		return;
	}

	while (n > 0)
9d001f70:	14a0fff8 	bnez	a1,9d001f54 <_ZN5Print11printNumberEmh+0x20>
9d001f74:	a0430000 	sb	v1,0(v0)
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d001f78:	12200011 	beqz	s1,9d001fc0 <_ZN5Print11printNumberEmh+0x8c>
9d001f7c:	8fbf003c 	lw	ra,60(sp)
}

// Private Methods /////////////////////////////////////////////////////////////

//************************************************************************
void Print::printNumber(unsigned long n, uint8_t base)
9d001f80:	27a30010 	addiu	v1,sp,16
9d001f84:	00711021 	addu	v0,v1,s1
		n /= base;
	}

	for (; i > 0; i--)
	{
		print((char) (buf[i - 1] < 10 ?
9d001f88:	9042ffff 	lbu	v0,-1(v0)
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
9d001f8c:	24450030 	addiu	a1,v0,48
9d001f90:	2c43000a 	sltiu	v1,v0,10
9d001f94:	7c052c20 	seb	a1,a1
9d001f98:	14600002 	bnez	v1,9d001fa4 <_ZN5Print11printNumberEmh+0x70>
9d001f9c:	24420037 	addiu	v0,v0,55
9d001fa0:	7c022c20 	seb	a1,v0
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d001fa4:	2631ffff 	addiu	s1,s1,-1
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d001fa8:	02002021 	move	a0,s0
9d001fac:	0f4007fb 	jal	9d001fec <_ZN5Print5printEli>
9d001fb0:	00003021 	move	a2,zero
	{
		buf[i++] = n % base;
		n /= base;
	}

	for (; i > 0; i--)
9d001fb4:	1620fff3 	bnez	s1,9d001f84 <_ZN5Print11printNumberEmh+0x50>
9d001fb8:	27a30010 	addiu	v1,sp,16
	{
		print((char) (buf[i - 1] < 10 ?
					'0' + buf[i - 1] :
					'A' + buf[i - 1] - 10));
	}
}
9d001fbc:	8fbf003c 	lw	ra,60(sp)
9d001fc0:	8fb10038 	lw	s1,56(sp)
9d001fc4:	8fb00034 	lw	s0,52(sp)
9d001fc8:	03e00008 	jr	ra
9d001fcc:	27bd0040 	addiu	sp,sp,64
9d001fd0:	8fbf003c 	lw	ra,60(sp)
9d001fd4:	8fb10038 	lw	s1,56(sp)
9d001fd8:	8fb00034 	lw	s0,52(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d001fdc:	24050030 	li	a1,48
9d001fe0:	00003021 	move	a2,zero
9d001fe4:	0b4007fb 	j	9d001fec <_ZN5Print5printEli>
9d001fe8:	27bd0040 	addiu	sp,sp,64

9d001fec <_ZN5Print5printEli>:
	print((unsigned long) n, base);
}

//************************************************************************
void Print::print(long n, int base)
{
9d001fec:	27bdffe0 	addiu	sp,sp,-32
9d001ff0:	afb10018 	sw	s1,24(sp)
9d001ff4:	afb00014 	sw	s0,20(sp)
9d001ff8:	afbf001c 	sw	ra,28(sp)
9d001ffc:	00808821 	move	s1,a0
	if (base == 0)
9d002000:	10c00013 	beqz	a2,9d002050 <_ZN5Print5printEli+0x64>
9d002004:	00a08021 	move	s0,a1
	{
		write(n);
	}
	else if (base == 10)
9d002008:	2402000a 	li	v0,10
9d00200c:	10c20006 	beq	a2,v0,9d002028 <_ZN5Print5printEli+0x3c>
9d002010:	8fbf001c 	lw	ra,28(sp)
	}
	else
	{
		printNumber(n, base);
	}
}
9d002014:	8fb10018 	lw	s1,24(sp)
9d002018:	8fb00014 	lw	s0,20(sp)
		}
		printNumber(n, 10);
	}
	else
	{
		printNumber(n, base);
9d00201c:	30c600ff 	andi	a2,a2,0xff
9d002020:	0b4007cd 	j	9d001f34 <_ZN5Print11printNumberEmh>
9d002024:	27bd0020 	addiu	sp,sp,32
	{
		write(n);
	}
	else if (base == 10)
	{
		if (n < 0)
9d002028:	04a00011 	bltz	a1,9d002070 <_ZN5Print5printEli+0x84>
9d00202c:	2405002d 	li	a1,45
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d002030:	02202021 	move	a0,s1
9d002034:	02002821 	move	a1,s0
	}
	else
	{
		printNumber(n, base);
	}
}
9d002038:	8fbf001c 	lw	ra,28(sp)
9d00203c:	8fb10018 	lw	s1,24(sp)
9d002040:	8fb00014 	lw	s0,20(sp)
		if (n < 0)
		{
			print('-');
			n = -n;
		}
		printNumber(n, 10);
9d002044:	2406000a 	li	a2,10
	}
	else
	{
		printNumber(n, base);
9d002048:	0b4007cd 	j	9d001f34 <_ZN5Print11printNumberEmh>
9d00204c:	27bd0020 	addiu	sp,sp,32
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d002050:	8c820000 	lw	v0,0(a0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d002054:	8fbf001c 	lw	ra,28(sp)
9d002058:	8fb10018 	lw	s1,24(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d00205c:	8c590000 	lw	t9,0(v0)
	}
	else
	{
		printNumber(n, base);
	}
}
9d002060:	8fb00014 	lw	s0,20(sp)
//************************************************************************
void Print::print(long n, int base)
{
	if (base == 0)
	{
		write(n);
9d002064:	30a500ff 	andi	a1,a1,0xff
9d002068:	03200008 	jr	t9
9d00206c:	27bd0020 	addiu	sp,sp,32
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002070:	0f4007fb 	jal	9d001fec <_ZN5Print5printEli>
9d002074:	00003021 	move	a2,zero
	else if (base == 10)
	{
		if (n < 0)
		{
			print('-');
			n = -n;
9d002078:	0b40080c 	j	9d002030 <_ZN5Print5printEli+0x44>
9d00207c:	00108023 	negu	s0,s0

9d002080 <_ZN5Print7printlnEv>:
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d002080:	27bdffe8 	addiu	sp,sp,-24
9d002084:	afb00010 	sw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002088:	2405000d 	li	a1,13
	printFloat(n, digits);
}

//************************************************************************
void Print::println(void)
{
9d00208c:	00808021 	move	s0,a0
9d002090:	afbf0014 	sw	ra,20(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d002094:	0f4007fb 	jal	9d001fec <_ZN5Print5printEli>
9d002098:	00003021 	move	a2,zero
9d00209c:	02002021 	move	a0,s0
//************************************************************************
void Print::println(void)
{
	print('\r');
	print('\n');
}
9d0020a0:	8fbf0014 	lw	ra,20(sp)
9d0020a4:	8fb00010 	lw	s0,16(sp)
}

//************************************************************************
void Print::print(char c, int base)
{
	print((long) c, base);
9d0020a8:	2405000a 	li	a1,10
9d0020ac:	00003021 	move	a2,zero
9d0020b0:	0b4007fb 	j	9d001fec <_ZN5Print5printEli>
9d0020b4:	27bd0018 	addiu	sp,sp,24

9d0020b8 <_ZN5Print7printlnEPKc>:
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d0020b8:	8c820000 	lw	v0,0(a0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d0020bc:	27bdffe8 	addiu	sp,sp,-24
9d0020c0:	afbf0014 	sw	ra,20(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d0020c4:	8c420004 	lw	v0,4(v0)
	print(argString);
	println();
}
//************************************************************************
void Print::println(const char c[])
{
9d0020c8:	afb00010 	sw	s0,16(sp)
	}
}
//************************************************************************
void Print::print(const char str[])
{
	write(str);
9d0020cc:	0040f809 	jalr	v0
9d0020d0:	00808021 	move	s0,a0
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d0020d4:	02002021 	move	a0,s0
}
9d0020d8:	8fbf0014 	lw	ra,20(sp)
9d0020dc:	8fb00010 	lw	s0,16(sp)
}
//************************************************************************
void Print::println(const char c[])
{
	print(c);
	println();
9d0020e0:	0b400820 	j	9d002080 <_ZN5Print7printlnEv>
9d0020e4:	27bd0018 	addiu	sp,sp,24

9d0020e8 <_general_exception_context>:
9d0020e8:	27bdffa8 	addiu	sp,sp,-88
9d0020ec:	afa10004 	sw	at,4(sp)
9d0020f0:	afa20008 	sw	v0,8(sp)
9d0020f4:	afa3000c 	sw	v1,12(sp)
9d0020f8:	afa40010 	sw	a0,16(sp)
9d0020fc:	afa50014 	sw	a1,20(sp)
9d002100:	afa60018 	sw	a2,24(sp)
9d002104:	afa7001c 	sw	a3,28(sp)
9d002108:	afa80020 	sw	t0,32(sp)
9d00210c:	afa90024 	sw	t1,36(sp)
9d002110:	afaa0028 	sw	t2,40(sp)
9d002114:	afab002c 	sw	t3,44(sp)
9d002118:	afac0030 	sw	t4,48(sp)
9d00211c:	afad0034 	sw	t5,52(sp)
9d002120:	afae0038 	sw	t6,56(sp)
9d002124:	afaf003c 	sw	t7,60(sp)
9d002128:	afb80040 	sw	t8,64(sp)
9d00212c:	afb90044 	sw	t9,68(sp)
9d002130:	afbf0048 	sw	ra,72(sp)
9d002134:	00004012 	mflo	t0
9d002138:	afa8004c 	sw	t0,76(sp)
9d00213c:	00004010 	mfhi	t0
9d002140:	afa80050 	sw	t0,80(sp)
9d002144:	40046800 	mfc0	a0,c0_cause
9d002148:	40056000 	mfc0	a1,c0_status
9d00214c:	0f40086e 	jal	9d0021b8 <_general_exception_handler>
9d002150:	00000000 	nop
9d002154:	8fa80050 	lw	t0,80(sp)
9d002158:	01000011 	mthi	t0
9d00215c:	8fa8004c 	lw	t0,76(sp)
9d002160:	01000013 	mtlo	t0
9d002164:	8fa10004 	lw	at,4(sp)
9d002168:	8fa20008 	lw	v0,8(sp)
9d00216c:	8fa3000c 	lw	v1,12(sp)
9d002170:	8fa40010 	lw	a0,16(sp)
9d002174:	8fa50014 	lw	a1,20(sp)
9d002178:	8fa60018 	lw	a2,24(sp)
9d00217c:	8fa7001c 	lw	a3,28(sp)
9d002180:	8fa80020 	lw	t0,32(sp)
9d002184:	8fa90024 	lw	t1,36(sp)
9d002188:	8faa0028 	lw	t2,40(sp)
9d00218c:	8fab002c 	lw	t3,44(sp)
9d002190:	8fac0030 	lw	t4,48(sp)
9d002194:	8fad0034 	lw	t5,52(sp)
9d002198:	8fae0038 	lw	t6,56(sp)
9d00219c:	8faf003c 	lw	t7,60(sp)
9d0021a0:	8fb80040 	lw	t8,64(sp)
9d0021a4:	8fb90044 	lw	t9,68(sp)
9d0021a8:	8fbf0048 	lw	ra,72(sp)
9d0021ac:	27bd0058 	addiu	sp,sp,88
9d0021b0:	000000c0 	ehb
9d0021b4:	42000018 	eret

9d0021b8 <_general_exception_handler>:
9d0021b8:	0b40086e 	j	9d0021b8 <_general_exception_handler>
9d0021bc:	00000000 	nop

9d0021c0 <_on_reset>:
9d0021c0:	03e00008 	jr	ra
9d0021c4:	00000000 	nop

9d0021c8 <_on_bootstrap>:
9d0021c8:	03e00008 	jr	ra
9d0021cc:	00000000 	nop

9d0021d0 <_nmi_handler>:
9d0021d0:	401a6000 	mfc0	k0,c0_status
9d0021d4:	3c1bffbf 	lui	k1,0xffbf
9d0021d8:	377bffff 	ori	k1,k1,0xffff
9d0021dc:	035bd024 	and	k0,k0,k1
9d0021e0:	409a6000 	mtc0	k0,c0_status
9d0021e4:	42000018 	eret

9d0021e8 <OpenCoreTimer>:
9d0021e8:	40804800 	mtc0	zero,c0_count
9d0021ec:	03e00008 	jr	ra
9d0021f0:	40845800 	mtc0	a0,c0_compare

9d0021f4 <ReadCoreTimer>:
9d0021f4:	03e00008 	jr	ra
9d0021f8:	40024800 	mfc0	v0,c0_count

9d0021fc <CheKseg0CacheOn>:
9d0021fc:	2402fff8 	li	v0,-8
9d002200:	40038000 	mfc0	v1,c0_config
9d002204:	00621024 	and	v0,v1,v0
9d002208:	34420003 	ori	v0,v0,0x3
9d00220c:	03e00008 	jr	ra
9d002210:	40828000 	mtc0	v0,c0_config

9d002214 <INTRestoreInterrupts>:
9d002214:	30840001 	andi	a0,a0,0x1
9d002218:	14800003 	bnez	a0,9d002228 <INTRestoreInterrupts+0x14>
9d00221c:	00000000 	nop
9d002220:	03e00008 	jr	ra
9d002224:	41606000 	di
9d002228:	03e00008 	jr	ra
9d00222c:	41606020 	ei

9d002230 <INTEnableSystemMultiVectoredInt>:
9d002230:	27bdffe8 	addiu	sp,sp,-24
9d002234:	afbf0014 	sw	ra,20(sp)
9d002238:	40036800 	mfc0	v1,c0_cause
9d00223c:	3c020080 	lui	v0,0x80
9d002240:	00621025 	or	v0,v1,v0
9d002244:	40826800 	mtc0	v0,c0_cause
9d002248:	24031000 	li	v1,4096
9d00224c:	3c02bf88 	lui	v0,0xbf88
9d002250:	0f40066f 	jal	9d0019bc <INTEnableInterrupts>
9d002254:	ac431008 	sw	v1,4104(v0)
9d002258:	8fbf0014 	lw	ra,20(sp)
9d00225c:	03e00008 	jr	ra
9d002260:	27bd0018 	addiu	sp,sp,24

9d002264 <RtccInit>:
9d002264:	27bdffd8 	addiu	sp,sp,-40
9d002268:	00002821 	move	a1,zero
9d00226c:	24040036 	li	a0,54
9d002270:	afbf0024 	sw	ra,36(sp)
9d002274:	afb40020 	sw	s4,32(sp)
9d002278:	afb3001c 	sw	s3,28(sp)
9d00227c:	afb20018 	sw	s2,24(sp)
9d002280:	afb10014 	sw	s1,20(sp)
9d002284:	0f400946 	jal	9d002518 <INTEnable>
9d002288:	afb00010 	sw	s0,16(sp)
9d00228c:	0f400671 	jal	9d0019c4 <INTDisableInterrupts>
9d002290:	00000000 	nop
9d002294:	00402021 	move	a0,v0
9d002298:	3c02aa99 	lui	v0,0xaa99
9d00229c:	3c03bf81 	lui	v1,0xbf81
9d0022a0:	24426655 	addiu	v0,v0,26197
9d0022a4:	ac60f230 	sw	zero,-3536(v1)
9d0022a8:	ac62f230 	sw	v0,-3536(v1)
9d0022ac:	3c025566 	lui	v0,0x5566
9d0022b0:	344299aa 	ori	v0,v0,0x99aa
9d0022b4:	ac62f230 	sw	v0,-3536(v1)
9d0022b8:	24140002 	li	s4,2
9d0022bc:	3c02bf81 	lui	v0,0xbf81
9d0022c0:	ac54f008 	sw	s4,-4088(v0)
9d0022c4:	3c023333 	lui	v0,0x3333
9d0022c8:	3c11bf80 	lui	s1,0xbf80
9d0022cc:	34108000 	li	s0,0x8000
9d0022d0:	24423333 	addiu	v0,v0,13107
9d0022d4:	3c13bf80 	lui	s3,0xbf80
9d0022d8:	24120008 	li	s2,8
9d0022dc:	ae720208 	sw	s2,520(s3)
9d0022e0:	ac62f230 	sw	v0,-3536(v1)
9d0022e4:	0f400885 	jal	9d002214 <INTRestoreInterrupts>
9d0022e8:	00000000 	nop
9d0022ec:	ae300204 	sw	s0,516(s1)
9d0022f0:	0f4009c5 	jal	9d002714 <_RtccWaitClockOff>
9d0022f4:	00000000 	nop
9d0022f8:	3c02bf80 	lui	v0,0xbf80
9d0022fc:	24040036 	li	a0,54
9d002300:	ac500214 	sw	s0,532(v0)
9d002304:	0f40093b 	jal	9d0024ec <INTClearFlag>
9d002308:	00000000 	nop
9d00230c:	24020001 	li	v0,1
9d002310:	ae700208 	sw	s0,520(s3)
9d002314:	3c03bf81 	lui	v1,0xbf81
9d002318:	ae320204 	sw	s2,516(s1)
9d00231c:	ae220204 	sw	v0,516(s1)
9d002320:	8c64f000 	lw	a0,-4096(v1)
9d002324:	30840002 	andi	a0,a0,0x2
9d002328:	1080000b 	beqz	a0,9d002358 <RtccInit+0xf4>
9d00232c:	8fbf0024 	lw	ra,36(sp)
9d002330:	8c63f000 	lw	v1,-4096(v1)
9d002334:	7c630580 	ext	v1,v1,0x16,0x1
9d002338:	50600008 	beqzl	v1,9d00235c <RtccInit+0xf8>
9d00233c:	8fb40020 	lw	s4,32(sp)
9d002340:	3c02bf80 	lui	v0,0xbf80
9d002344:	8c420200 	lw	v0,512(v0)
9d002348:	30420040 	andi	v0,v0,0x40
9d00234c:	0002a00b 	movn	s4,zero,v0
9d002350:	02801021 	move	v0,s4
9d002354:	8fbf0024 	lw	ra,36(sp)
9d002358:	8fb40020 	lw	s4,32(sp)
9d00235c:	8fb3001c 	lw	s3,28(sp)
9d002360:	8fb20018 	lw	s2,24(sp)
9d002364:	8fb10014 	lw	s1,20(sp)
9d002368:	8fb00010 	lw	s0,16(sp)
9d00236c:	03e00008 	jr	ra
9d002370:	27bd0028 	addiu	sp,sp,40

9d002374 <RtccSetTimeDate>:
9d002374:	27bdffe8 	addiu	sp,sp,-24
9d002378:	afa40018 	sw	a0,24(sp)
9d00237c:	afa5001c 	sw	a1,28(sp)
9d002380:	27a40018 	addiu	a0,sp,24
9d002384:	afbf0014 	sw	ra,20(sp)
9d002388:	0f40095c 	jal	9d002570 <_RtccSetTimeAndDate>
9d00238c:	27a5001c 	addiu	a1,sp,28
9d002390:	8fbf0014 	lw	ra,20(sp)
9d002394:	03e00008 	jr	ra
9d002398:	27bd0018 	addiu	sp,sp,24

9d00239c <RtccOpen>:
9d00239c:	27bdffc8 	addiu	sp,sp,-56
9d0023a0:	afb2001c 	sw	s2,28(sp)
9d0023a4:	afb10018 	sw	s1,24(sp)
9d0023a8:	00809021 	move	s2,a0
9d0023ac:	00a08821 	move	s1,a1
9d0023b0:	24040036 	li	a0,54
9d0023b4:	00002821 	move	a1,zero
9d0023b8:	afbf0034 	sw	ra,52(sp)
9d0023bc:	afb70030 	sw	s7,48(sp)
9d0023c0:	afb6002c 	sw	s6,44(sp)
9d0023c4:	afb50028 	sw	s5,40(sp)
9d0023c8:	afb40024 	sw	s4,36(sp)
9d0023cc:	afb30020 	sw	s3,32(sp)
9d0023d0:	afb00014 	sw	s0,20(sp)
9d0023d4:	0f400946 	jal	9d002518 <INTEnable>
9d0023d8:	00069c00 	sll	s3,a2,0x10
9d0023dc:	0f400671 	jal	9d0019c4 <INTDisableInterrupts>
9d0023e0:	00000000 	nop
9d0023e4:	00402021 	move	a0,v0
9d0023e8:	3c02aa99 	lui	v0,0xaa99
9d0023ec:	3c03bf81 	lui	v1,0xbf81
9d0023f0:	24426655 	addiu	v0,v0,26197
9d0023f4:	ac60f230 	sw	zero,-3536(v1)
9d0023f8:	ac62f230 	sw	v0,-3536(v1)
9d0023fc:	3c025566 	lui	v0,0x5566
9d002400:	344299aa 	ori	v0,v0,0x99aa
9d002404:	ac62f230 	sw	v0,-3536(v1)
9d002408:	24170002 	li	s7,2
9d00240c:	3c02bf81 	lui	v0,0xbf81
9d002410:	ac57f008 	sw	s7,-4088(v0)
9d002414:	3c023333 	lui	v0,0x3333
9d002418:	3c14bf80 	lui	s4,0xbf80
9d00241c:	3c15bf80 	lui	s5,0xbf80
9d002420:	34108000 	li	s0,0x8000
9d002424:	24423333 	addiu	v0,v0,13107
9d002428:	24160008 	li	s6,8
9d00242c:	aeb60208 	sw	s6,520(s5)
9d002430:	ac62f230 	sw	v0,-3536(v1)
9d002434:	0f400885 	jal	9d002214 <INTRestoreInterrupts>
9d002438:	00000000 	nop
9d00243c:	ae900204 	sw	s0,516(s4)
9d002440:	0f4009c5 	jal	9d002714 <_RtccWaitClockOff>
9d002444:	00000000 	nop
9d002448:	3c02bf80 	lui	v0,0xbf80
9d00244c:	24040036 	li	a0,54
9d002450:	ac500214 	sw	s0,532(v0)
9d002454:	0f40093b 	jal	9d0024ec <INTClearFlag>
9d002458:	00000000 	nop
9d00245c:	3c02bf80 	lui	v0,0xbf80
9d002460:	ac520220 	sw	s2,544(v0)
9d002464:	3c02bf80 	lui	v0,0xbf80
9d002468:	ac510230 	sw	s1,560(v0)
9d00246c:	3c0203ff 	lui	v0,0x3ff
9d002470:	ae820204 	sw	v0,516(s4)
9d002474:	24020001 	li	v0,1
9d002478:	aeb30208 	sw	s3,520(s5)
9d00247c:	3c03bf81 	lui	v1,0xbf81
9d002480:	aeb00208 	sw	s0,520(s5)
9d002484:	ae960204 	sw	s6,516(s4)
9d002488:	ae820204 	sw	v0,516(s4)
9d00248c:	8c64f000 	lw	a0,-4096(v1)
9d002490:	30840002 	andi	a0,a0,0x2
9d002494:	1080000b 	beqz	a0,9d0024c4 <RtccOpen+0x128>
9d002498:	8fbf0034 	lw	ra,52(sp)
9d00249c:	8c63f000 	lw	v1,-4096(v1)
9d0024a0:	7c630580 	ext	v1,v1,0x16,0x1
9d0024a4:	50600008 	beqzl	v1,9d0024c8 <RtccOpen+0x12c>
9d0024a8:	8fb70030 	lw	s7,48(sp)
9d0024ac:	3c02bf80 	lui	v0,0xbf80
9d0024b0:	8c420200 	lw	v0,512(v0)
9d0024b4:	30420040 	andi	v0,v0,0x40
9d0024b8:	0002b80b 	movn	s7,zero,v0
9d0024bc:	02e01021 	move	v0,s7
9d0024c0:	8fbf0034 	lw	ra,52(sp)
9d0024c4:	8fb70030 	lw	s7,48(sp)
9d0024c8:	8fb6002c 	lw	s6,44(sp)
9d0024cc:	8fb50028 	lw	s5,40(sp)
9d0024d0:	8fb40024 	lw	s4,36(sp)
9d0024d4:	8fb30020 	lw	s3,32(sp)
9d0024d8:	8fb2001c 	lw	s2,28(sp)
9d0024dc:	8fb10018 	lw	s1,24(sp)
9d0024e0:	8fb00014 	lw	s0,20(sp)
9d0024e4:	03e00008 	jr	ra
9d0024e8:	27bd0038 	addiu	sp,sp,56

9d0024ec <INTClearFlag>:
9d0024ec:	00041080 	sll	v0,a0,0x2
9d0024f0:	00042100 	sll	a0,a0,0x4
9d0024f4:	00822023 	subu	a0,a0,v0
9d0024f8:	3c029d00 	lui	v0,0x9d00
9d0024fc:	244228d8 	addiu	v0,v0,10456
9d002500:	00822021 	addu	a0,a0,v0
9d002504:	8c820000 	lw	v0,0(a0)
9d002508:	8c830008 	lw	v1,8(a0)
9d00250c:	ac430004 	sw	v1,4(v0)
9d002510:	03e00008 	jr	ra
9d002514:	00000000 	nop

9d002518 <INTEnable>:
9d002518:	14a0000b 	bnez	a1,9d002548 <INTEnable+0x30>
9d00251c:	00041080 	sll	v0,a0,0x2
9d002520:	00042100 	sll	a0,a0,0x4
9d002524:	00822023 	subu	a0,a0,v0
9d002528:	3c029d00 	lui	v0,0x9d00
9d00252c:	244228d8 	addiu	v0,v0,10456
9d002530:	00442021 	addu	a0,v0,a0
9d002534:	8c820004 	lw	v0,4(a0)
9d002538:	8c830008 	lw	v1,8(a0)
9d00253c:	ac430004 	sw	v1,4(v0)
9d002540:	03e00008 	jr	ra
9d002544:	00000000 	nop
9d002548:	00042100 	sll	a0,a0,0x4
9d00254c:	00822023 	subu	a0,a0,v0
9d002550:	3c029d00 	lui	v0,0x9d00
9d002554:	244228d8 	addiu	v0,v0,10456
9d002558:	00442021 	addu	a0,v0,a0
9d00255c:	8c820004 	lw	v0,4(a0)
9d002560:	8c830008 	lw	v1,8(a0)
9d002564:	ac430008 	sw	v1,8(v0)
9d002568:	03e00008 	jr	ra
9d00256c:	00000000 	nop

9d002570 <_RtccSetTimeAndDate>:
9d002570:	27bdffd8 	addiu	sp,sp,-40
9d002574:	afb30020 	sw	s3,32(sp)
9d002578:	3c13bf80 	lui	s3,0xbf80
9d00257c:	afb00014 	sw	s0,20(sp)
9d002580:	8e700200 	lw	s0,512(s3)
9d002584:	afb2001c 	sw	s2,28(sp)
9d002588:	afb10018 	sw	s1,24(sp)
9d00258c:	7e1000c0 	ext	s0,s0,0x3,0x1
9d002590:	afbf0024 	sw	ra,36(sp)
9d002594:	00808821 	move	s1,a0
9d002598:	12000049 	beqz	s0,9d0026c0 <_RtccSetTimeAndDate+0x150>
9d00259c:	00a09021 	move	s2,a1
9d0025a0:	8e620200 	lw	v0,512(s3)
9d0025a4:	30428000 	andi	v0,v0,0x8000
9d0025a8:	10400021 	beqz	v0,9d002630 <_RtccSetTimeAndDate+0xc0>
9d0025ac:	00000000 	nop
9d0025b0:	0f400671 	jal	9d0019c4 <INTDisableInterrupts>
9d0025b4:	00000000 	nop
9d0025b8:	3c03bf80 	lui	v1,0xbf80
9d0025bc:	8c630200 	lw	v1,512(v1)
9d0025c0:	30630004 	andi	v1,v1,0x4
9d0025c4:	1460002a 	bnez	v1,9d002670 <_RtccSetTimeAndDate+0x100>
9d0025c8:	3c03bf80 	lui	v1,0xbf80
9d0025cc:	8c640210 	lw	a0,528(v1)
9d0025d0:	30848000 	andi	a0,a0,0x8000
9d0025d4:	14800022 	bnez	a0,9d002660 <_RtccSetTimeAndDate+0xf0>
9d0025d8:	00000000 	nop
9d0025dc:	12200003 	beqz	s1,9d0025ec <_RtccSetTimeAndDate+0x7c>
9d0025e0:	3c03bf80 	lui	v1,0xbf80
9d0025e4:	8e240000 	lw	a0,0(s1)
9d0025e8:	ac640220 	sw	a0,544(v1)
9d0025ec:	12400003 	beqz	s2,9d0025fc <_RtccSetTimeAndDate+0x8c>
9d0025f0:	3c03bf80 	lui	v1,0xbf80
9d0025f4:	8e440000 	lw	a0,0(s2)
9d0025f8:	ac640230 	sw	a0,560(v1)
9d0025fc:	0f400885 	jal	9d002214 <INTRestoreInterrupts>
9d002600:	00402021 	move	a0,v0
9d002604:	16000003 	bnez	s0,9d002614 <_RtccSetTimeAndDate+0xa4>
9d002608:	24030008 	li	v1,8
9d00260c:	3c02bf80 	lui	v0,0xbf80
9d002610:	ac430204 	sw	v1,516(v0)
9d002614:	8fbf0024 	lw	ra,36(sp)
9d002618:	8fb30020 	lw	s3,32(sp)
9d00261c:	8fb2001c 	lw	s2,28(sp)
9d002620:	8fb10018 	lw	s1,24(sp)
9d002624:	8fb00014 	lw	s0,20(sp)
9d002628:	03e00008 	jr	ra
9d00262c:	27bd0028 	addiu	sp,sp,40
9d002630:	0f4009c5 	jal	9d002714 <_RtccWaitClockOff>
9d002634:	00000000 	nop
9d002638:	12200003 	beqz	s1,9d002648 <_RtccSetTimeAndDate+0xd8>
9d00263c:	3c02bf80 	lui	v0,0xbf80
9d002640:	8e230000 	lw	v1,0(s1)
9d002644:	ac430220 	sw	v1,544(v0)
9d002648:	1240ffee 	beqz	s2,9d002604 <_RtccSetTimeAndDate+0x94>
9d00264c:	3c02bf80 	lui	v0,0xbf80
9d002650:	8e430000 	lw	v1,0(s2)
9d002654:	ac430230 	sw	v1,560(v0)
9d002658:	0b400981 	j	9d002604 <_RtccSetTimeAndDate+0x94>
9d00265c:	00000000 	nop
9d002660:	8c630210 	lw	v1,528(v1)
9d002664:	30630f00 	andi	v1,v1,0xf00
9d002668:	1460ffdc 	bnez	v1,9d0025dc <_RtccSetTimeAndDate+0x6c>
9d00266c:	00000000 	nop
9d002670:	0f400885 	jal	9d002214 <INTRestoreInterrupts>
9d002674:	00402021 	move	a0,v0
9d002678:	34038000 	li	v1,0x8000
9d00267c:	3c02bf80 	lui	v0,0xbf80
9d002680:	ac430204 	sw	v1,516(v0)
9d002684:	0f4009c5 	jal	9d002714 <_RtccWaitClockOff>
9d002688:	00000000 	nop
9d00268c:	12200003 	beqz	s1,9d00269c <_RtccSetTimeAndDate+0x12c>
9d002690:	3c02bf80 	lui	v0,0xbf80
9d002694:	8e230000 	lw	v1,0(s1)
9d002698:	ac430220 	sw	v1,544(v0)
9d00269c:	12400003 	beqz	s2,9d0026ac <_RtccSetTimeAndDate+0x13c>
9d0026a0:	3c02bf80 	lui	v0,0xbf80
9d0026a4:	8e430000 	lw	v1,0(s2)
9d0026a8:	ac430230 	sw	v1,560(v0)
9d0026ac:	34038000 	li	v1,0x8000
9d0026b0:	3c02bf80 	lui	v0,0xbf80
9d0026b4:	ac430208 	sw	v1,520(v0)
9d0026b8:	0b400981 	j	9d002604 <_RtccSetTimeAndDate+0x94>
9d0026bc:	00000000 	nop
9d0026c0:	0f400671 	jal	9d0019c4 <INTDisableInterrupts>
9d0026c4:	00000000 	nop
9d0026c8:	00402021 	move	a0,v0
9d0026cc:	3c02aa99 	lui	v0,0xaa99
9d0026d0:	3c03bf81 	lui	v1,0xbf81
9d0026d4:	24426655 	addiu	v0,v0,26197
9d0026d8:	ac60f230 	sw	zero,-3536(v1)
9d0026dc:	ac62f230 	sw	v0,-3536(v1)
9d0026e0:	3c025566 	lui	v0,0x5566
9d0026e4:	344299aa 	ori	v0,v0,0x99aa
9d0026e8:	ac62f230 	sw	v0,-3536(v1)
9d0026ec:	24050008 	li	a1,8
9d0026f0:	3c02bf80 	lui	v0,0xbf80
9d0026f4:	ac450208 	sw	a1,520(v0)
9d0026f8:	3c023333 	lui	v0,0x3333
9d0026fc:	24423333 	addiu	v0,v0,13107
9d002700:	ac62f230 	sw	v0,-3536(v1)
9d002704:	0f400885 	jal	9d002214 <INTRestoreInterrupts>
9d002708:	00000000 	nop
9d00270c:	0b400968 	j	9d0025a0 <_RtccSetTimeAndDate+0x30>
9d002710:	00000000 	nop

9d002714 <_RtccWaitClockOff>:
9d002714:	27bdffd0 	addiu	sp,sp,-48
9d002718:	afb30020 	sw	s3,32(sp)
9d00271c:	3c13bf81 	lui	s3,0xbf81
9d002720:	8e62f000 	lw	v0,-4096(s3)
9d002724:	afbf002c 	sw	ra,44(sp)
9d002728:	afb50028 	sw	s5,40(sp)
9d00272c:	30420002 	andi	v0,v0,0x2
9d002730:	afb40024 	sw	s4,36(sp)
9d002734:	afb2001c 	sw	s2,28(sp)
9d002738:	afb10018 	sw	s1,24(sp)
9d00273c:	1040001c 	beqz	v0,9d0027b0 <_RtccWaitClockOff+0x9c>
9d002740:	afb00014 	sw	s0,20(sp)
9d002744:	3c02a000 	lui	v0,0xa000
9d002748:	8c520274 	lw	s2,628(v0)
9d00274c:	3c140040 	lui	s4,0x40
9d002750:	3c15bf80 	lui	s5,0xbf80
9d002754:	12400016 	beqz	s2,9d0027b0 <_RtccWaitClockOff+0x9c>
9d002758:	3c11a000 	lui	s1,0xa000
9d00275c:	8e62f000 	lw	v0,-4096(s3)
9d002760:	00541024 	and	v0,v0,s4
9d002764:	10400012 	beqz	v0,9d0027b0 <_RtccWaitClockOff+0x9c>
9d002768:	00000000 	nop
9d00276c:	8ea20200 	lw	v0,512(s5)
9d002770:	30420040 	andi	v0,v0,0x40
9d002774:	1040000e 	beqz	v0,9d0027b0 <_RtccWaitClockOff+0x9c>
9d002778:	00000000 	nop
9d00277c:	0f40087d 	jal	9d0021f4 <ReadCoreTimer>
9d002780:	00000000 	nop
9d002784:	00408021 	move	s0,v0
9d002788:	0f40087d 	jal	9d0021f4 <ReadCoreTimer>
9d00278c:	00000000 	nop
9d002790:	8e230270 	lw	v1,624(s1)
9d002794:	00501023 	subu	v0,v0,s0
9d002798:	0043182b 	sltu	v1,v0,v1
9d00279c:	1460fffa 	bnez	v1,9d002788 <_RtccWaitClockOff+0x74>
9d0027a0:	00000000 	nop
9d0027a4:	2652ffff 	addiu	s2,s2,-1
9d0027a8:	1640ffec 	bnez	s2,9d00275c <_RtccWaitClockOff+0x48>
9d0027ac:	00000000 	nop
9d0027b0:	8e63f000 	lw	v1,-4096(s3)
9d0027b4:	30630002 	andi	v1,v1,0x2
9d0027b8:	1060000b 	beqz	v1,9d0027e8 <_RtccWaitClockOff+0xd4>
9d0027bc:	24020001 	li	v0,1
9d0027c0:	3c03bf81 	lui	v1,0xbf81
9d0027c4:	8c63f000 	lw	v1,-4096(v1)
9d0027c8:	7c630580 	ext	v1,v1,0x16,0x1
9d0027cc:	10600007 	beqz	v1,9d0027ec <_RtccWaitClockOff+0xd8>
9d0027d0:	8fbf002c 	lw	ra,44(sp)
9d0027d4:	3c02bf80 	lui	v0,0xbf80
9d0027d8:	8c430200 	lw	v1,512(v0)
9d0027dc:	24020002 	li	v0,2
9d0027e0:	30630040 	andi	v1,v1,0x40
9d0027e4:	0003100b 	movn	v0,zero,v1
9d0027e8:	8fbf002c 	lw	ra,44(sp)
9d0027ec:	8fb50028 	lw	s5,40(sp)
9d0027f0:	8fb40024 	lw	s4,36(sp)
9d0027f4:	8fb30020 	lw	s3,32(sp)
9d0027f8:	8fb2001c 	lw	s2,28(sp)
9d0027fc:	8fb10018 	lw	s1,24(sp)
9d002800:	8fb00014 	lw	s0,20(sp)
9d002804:	03e00008 	jr	ra
9d002808:	27bd0030 	addiu	sp,sp,48

9d00280c <__do_global_ctors_aux>:
9d00280c:	3c029d00 	lui	v0,0x9d00
9d002810:	8c4228a4 	lw	v0,10404(v0)
9d002814:	27bdffe0 	addiu	sp,sp,-32
9d002818:	2403ffff 	li	v1,-1
9d00281c:	afbf001c 	sw	ra,28(sp)
9d002820:	afb10018 	sw	s1,24(sp)
9d002824:	10430009 	beq	v0,v1,9d00284c <__do_global_ctors_aux+0x40>
9d002828:	afb00014 	sw	s0,20(sp)
9d00282c:	3c119d00 	lui	s1,0x9d00
9d002830:	263128a4 	addiu	s1,s1,10404
9d002834:	2410ffff 	li	s0,-1
9d002838:	0040f809 	jalr	v0
9d00283c:	2631fffc 	addiu	s1,s1,-4
9d002840:	8e220000 	lw	v0,0(s1)
9d002844:	1450fffc 	bne	v0,s0,9d002838 <__do_global_ctors_aux+0x2c>
9d002848:	00000000 	nop
9d00284c:	8fbf001c 	lw	ra,28(sp)
9d002850:	8fb10018 	lw	s1,24(sp)
9d002854:	8fb00014 	lw	s0,20(sp)
9d002858:	03e00008 	jr	ra
9d00285c:	27bd0020 	addiu	sp,sp,32

Disassembly of section .init:

9d002860 <_init>:
9d002860:	27bdffe0 	addiu	sp,sp,-32
9d002864:	afbf0014 	sw	ra,20(sp)
9d002868:	0f4004b3 	jal	9d0012cc <frame_dummy>
9d00286c:	00000000 	nop
9d002870:	0f400a03 	jal	9d00280c <__do_global_ctors_aux>
9d002874:	00000000 	nop
9d002878:	8fbf0014 	lw	ra,20(sp)
9d00287c:	03e00008 	jr	ra
9d002880:	27bd0020 	addiu	sp,sp,32

Disassembly of section .fini:

9d002884 <_fini>:
9d002884:	27bdffe0 	addiu	sp,sp,-32
9d002888:	afbf0014 	sw	ra,20(sp)
9d00288c:	0f400484 	jal	9d001210 <__do_global_dtors_aux>
9d002890:	00000000 	nop
9d002894:	8fbf0014 	lw	ra,20(sp)
9d002898:	03e00008 	jr	ra
9d00289c:	27bd0020 	addiu	sp,sp,32

Disassembly of section .rodata:

9d0028b4 <_ZTV14HardwareSerial>:
	...
9d0028bc:	9d001a5c 9d001e7c 9d001ed4 9d0019cc     \...|...........
9d0028cc:	9d001a14 9d0019f4 9d001a50              ........P...

9d0028d8 <__IntSrcTbl>:
9d0028d8:	bf881030 bf881060 00000001 bf881030     0...`.......0...
9d0028e8:	bf881060 00000002 bf881030 bf881060     `.......0...`...
9d0028f8:	00000004 bf881030 bf881060 00000008     ....0...`.......
9d002908:	bf881030 bf881060 00000080 bf881030     0...`.......0...
9d002918:	bf881060 00000800 bf881030 bf881060     `.......0...`...
9d002928:	00008000 bf881030 bf881060 00080000     ....0...`.......
9d002938:	bf881030 bf881060 00000010 bf881030     0...`.......0...
9d002948:	bf881060 00000100 bf881030 bf881060     `.......0...`...
9d002958:	00001000 bf881030 bf881060 00010000     ....0...`.......
9d002968:	bf881030 bf881060 00100000 bf881030     0...`.......0...
9d002978:	bf881060 00000020 bf881030 bf881060     `... ...0...`...
9d002988:	00000200 bf881030 bf881060 00002000     ....0...`.... ..
9d002998:	bf881030 bf881060 00020000 bf881030     0...`.......0...
9d0029a8:	bf881060 00200000 bf881030 bf881060     `..... .0...`...
9d0029b8:	00000040 bf881030 bf881060 00000400     @...0...`.......
9d0029c8:	bf881030 bf881060 00004000 bf881030     0...`....@..0...
9d0029d8:	bf881060 00040000 bf881030 bf881060     `.......0...`...
9d0029e8:	00400000 bf881040 bf881070 00000001     ..@.@...p.......
9d0029f8:	bf881030 bf881060 00800000 bf881040     0...`.......@...
9d002a08:	bf881070 00000020 bf881030 bf881060     p... ...0...`...
9d002a18:	01000000 bf881040 bf881070 00000040     ....@...p...@...
9d002a28:	bf881030 bf881060 02000000 bf881040     0...`.......@...
9d002a38:	bf881070 00000080 bf881030 bf881060     p.......0...`...
9d002a48:	03800000 bf881040 bf881070 000000e0     ....@...p.......
9d002a58:	bf881030 bf881060 04000000 bf881040     0...`.......@...
9d002a68:	bf881070 00000100 bf881030 bf881060     p.......0...`...
9d002a78:	08000000 bf881040 bf881070 00000200     ....@...p.......
9d002a88:	bf881030 bf881060 10000000 bf881040     0...`.......@...
9d002a98:	bf881070 00000400 bf881030 bf881060     p.......0...`...
9d002aa8:	1c000000 bf881040 bf881070 00000700     ....@...p.......
9d002ab8:	bf881030 bf881060 20000000 bf881040     0...`...... @...
9d002ac8:	bf881070 00000800 bf881030 bf881060     p.......0...`...
9d002ad8:	40000000 bf881040 bf881070 00001000     ...@@...p.......
9d002ae8:	bf881030 bf881060 80000000 bf881040     0...`.......@...
9d002af8:	bf881070 00002000 bf881030 bf881060     p.... ..0...`...
9d002b08:	e0000000 bf881040 bf881070 00003800     ....@...p....8..
9d002b18:	bf881040 bf881070 00000002 bf881040     @...p.......@...
9d002b28:	bf881070 00000004 bf881040 bf881070     p.......@...p...
9d002b38:	00000008 bf881040 bf881070 00000010     ....@...p.......
9d002b48:	bf881040 bf881070 00004000 bf881040     @...p....@..@...
9d002b58:	bf881070 01000000 bf881040 bf881070     p.......@...p...
9d002b68:	00008000 00000000 00000000 00000000     ................
	...

9d002bd8 <__IntVectorTbl>:
9d002bd8:	bf881090 00000000 00000002 bf881090     ................
9d002be8:	00000008 0000000a bf881090 00000010     ................
9d002bf8:	00000012 bf881090 00000018 0000001a     ................
9d002c08:	bf8810a0 00000018 0000001a bf8810b0     ................
9d002c18:	00000018 0000001a bf8810c0 00000018     ................
9d002c28:	0000001a bf8810d0 00000018 0000001a     ................
9d002c38:	bf8810a0 00000000 00000002 bf8810b0     ................
9d002c48:	00000000 00000002 bf8810c0 00000000     ................
9d002c58:	00000002 bf8810d0 00000000 00000002     ................
9d002c68:	bf8810e0 00000000 00000002 bf8810a0     ................
9d002c78:	00000008 0000000a bf8810b0 00000008     ................
9d002c88:	0000000a bf8810c0 00000008 0000000a     ................
9d002c98:	bf8810d0 00000008 0000000a bf8810e0     ................
9d002ca8:	00000008 0000000a bf8810a0 00000010     ................
9d002cb8:	00000012 bf8810b0 00000010 00000012     ................
9d002cc8:	bf8810c0 00000010 00000012 bf8810d0     ................
9d002cd8:	00000010 00000012 bf8810e0 00000010     ................
9d002ce8:	00000012 bf8810e0 00000018 0000001a     ................
9d002cf8:	bf881100 00000018 0000001a bf8810f0     ................
9d002d08:	00000000 00000002 bf881110 00000000     ................
9d002d18:	00000002 bf8810f0 00000008 0000000a     ................
9d002d28:	bf881110 00000008 0000000a bf8810f0     ................
9d002d38:	00000010 00000012 bf8810f0 00000018     ................
9d002d48:	0000001a bf881100 00000000 00000002     ................
9d002d58:	bf881100 00000008 0000000a bf881100     ................
9d002d68:	00000010 00000012 bf881110 00000010     ................
9d002d78:	00000012 bf881110 00000018 0000001a     ................
	...
9d002de8:	bf881140 00000000 00000002 00000000     @...............
	...
